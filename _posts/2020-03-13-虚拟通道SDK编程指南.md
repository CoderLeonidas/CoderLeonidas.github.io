---
layout:     post
title:      "虚拟通道SDK编程指南"
date:       2020-03-13 19:08:02
author:     "CoderLeonidas"
catalog: true
tags:

- VDI
- 虚拟化技术
- 翻译


---

# 虚拟通道SDK编程指南

## Chapter 1 Using the Virtual Channel SDK

## Chapter 2 Architecture


ICA)虚拟通道是运行Citrix XenApp的服务器和客户端设备之间交换通用数据包数据的双向无错误连接。开发人员可以使用虚拟通道向客户端添加功能。虚拟通道的使用包括

1. 支持管理功能
1. 新的数据流(音频和视频)
1. 新设备，如扫描仪、读卡器和操纵杆)


## 虚拟通道概述

ICA虚拟通道是双向通用交换的无错连接客户端和运行Citrix XenApp或XenDesktop的服务器之间的数据包数据。 每个ICA虚拟通道的实现包含两个组件：

- 运行XenApp或XenDesktop的计算机上的服务器端部分

- 客户端设备上的客户端部分
> 客户端虚拟通道驱动程序是一个可动态加载的模块(. dll)，在客户端上下文中执行。您必须编写您的虚拟驱动程序。


该图演示了虚拟通道客户机-服务器连接

![](https://i.loli.net/2020/03/13/7bWZ1cMBekvYza2.png)


**WinStation**驱动程序负责从ICA数据流中多路分解(demultiplexed)虚拟通道数据，并将其路由到正确的处理模块(在本例中是虚拟驱动程序DLL)。WinStation驱动程序还负责通过ICA连接收集和发送虚拟通道数据到服务器。在客户端，WinStation驱动程序也称为客户端引擎，或简称为引擎。


下面是使用虚拟通道进行客户机-服务器数据交换的概述

- 客户端连接到运行XenApp或XenDesktop的服务器。客户机将有关它支持的虚拟通道的信息传递给服务器。
- 服务器端应用程序启动，获取虚拟通道的句柄，并可选地查询关于该通道的其他信息。
-  客户端虚拟驱动程序和服务器端应用程序使用以下两种方法传递数据：
 - 如果服务器应用程序有数据要发送给客户机，则立即将数据发送给客户机。当客户端接收到数据时，WinStation驱动程序从ICA流中解复用虚拟通道数据，并立即将其传递给客户端虚拟驱动程序。
 - 如果客户端虚拟驱动程序要向服务器发送数据，则可以立即发送数据，或者在下一次WinStation驱动程序轮询虚拟驱动程序时发送数据。当服务器接收到数据时，它将排队，直到虚拟通道应用程序读取它。无法通知服务器虚拟通道应用程序接收到数据。
-  当服务器虚拟通道应用程序完成时，它关闭虚拟通道并释放所有分配的资源。



### ICA和虚拟信道数据包

虚拟通道数据包封装在客户端和服务器之间的ICA流中。因为ICA是表示层协议，并且运行在几种不同的传输上，所以虚拟通道应用程序编程接口(API)允许开发人员编写自己的协议，而不必担心底层的传输。数据包被保留。

例如，如果向服务器发送100个字节，则当虚拟通道从ICA数据流进行多路复用(demultiplexed)时，服务器将接收相同的100个字节。编译后的代码独立于当前配置的传输协议运行。

ICA引擎为虚拟通道提供以下服务：

- 打包封包
> ICA虚拟通道是基于包的，这意味着如果一端使用一定数量的数据执行写操作，另一端在执行读操作时接收整个数据块。这与TCP形成了对比，例如，TCP是基于流的，需要更高级别的协议来解析包边界。换句话说，虚拟信道包包含在ICA流中，ICA流由系统软件单独管理。

- 误差校正
> 即使基础传输不可靠，ICA也提供自己的可靠性机制。这保证了连接是无错误的，并且数据是按照发送的顺序接收的。

- 流程控制
> 虚拟通道API提供了几种类型的流控制。这允许设计人员在任何时候都只处理特定数量的数据。


### 客户端WinStation驱动程序和虚拟驱动程序交互

客户端虚拟驱动程序可以选择以两种模式之一发送数据

- 轮询模式(Polling mode)

- 立即模式(Immediate mode)

如果运行在轮询模式，WinStation驱动程序通过调用它的DriverPoll函数来定期轮询每个虚拟驱动程序。当调用DriverPoll时，虚拟驱动程序应该立即检查任何必要的状态信息，发送任何排队的数据，并将控制权返回给WinStation驱动程序。 

如果在立即模式下操作，虚拟驱动程序可以在任何时候发送数据。例如，假设驱动程序在ICADataArrival函数中收到来自服务器的数据包。在即时发送数据模式下，驱动程序可以对收到的数据包立即发送数据，然后控制权将从ICADataArrival函数返回到WinStation驱动程序。


当虚拟驱动程序试图向服务器发送数据时，它应该准备好数据发送操作，有时会被拒绝。可能会出现这种情况，因为WinStation驱动程序支持合理但不过量的排队等待发送到服务器的backlog。如果发送操作被拒绝，虚拟驱动程序必须安排稍后重试发送。

在任何情况下，无论是轮询模式还是立即模式，虚拟驱动程序都不能阻塞。当WinStation驱动程序调用任何驱动程序函数时，虚拟驱动程序必须立即检查任何必要的状态信息，发送任何排队的数据，并将控制权返回给WinStation驱动程序。

当用户启动客户机时，将执行以下过程：

- 1 在客户端加载时，客户端引擎读取注册表中的配置存储以确定要配置的模块，包括如何配置虚拟通道驱动程序。
- 2 客户端引擎通过调用Load函数加载注册表中配置存储中定义的虚拟通道驱动程序，该函数必须由虚拟通道驱动程序. dll显式导出。Load函数是在静态库文件 Vdapi.lib中定义的。 Vdapi.lib，在这个SDK中提供。每个驱动程序都必须链接到这个库文件。Load函数将. dll中定义的驱动入口点转发给客户端引擎。
- 3 对于每个虚拟通道，WinStation驱动程序调用DriverOpen函数，该函数建立并初始化虚拟通道。WinStation驱动程序将WinStation驱动程序中的一个发送数据输出函数的地址传递给虚拟通道驱动程序。虚拟通道驱动程序将ICADataArrival函数的地址传递给WinStation驱动程序。WinStation驱动程序在客户端加载时为每个虚拟驱动程序调用DriverOpen函数，而不是在服务器端应用程序打开虚拟通道时调用
- 4 当虚拟通道数据从服务器到达时，WinStation驱动程序为该虚拟驱动程序调用ICADataArrival函数。
- 5如果使用发送数据轮询模式，则虚拟驱动程序无法启动数据传输。相反，WinStation驱动程序调用DriverPoll来轮询要发送到服务器的数据。要发送数据，虚拟通道驱动程序可以使用QueueVirtualWrite函数(这个地址是在初始化期间获得的)将数据块发送到服务器端版本的通道。DriverPoll期间,虚拟驱动程序可能试图发送一个或多个包(VirtualWrites),直到没有更多的数据发送,或QueueVirtualWrite函数返回错误代码`CLIENT_ERROR_NO_OUTBUF`,表明没有更多的缓冲空间,和数据没有被接受,而且必须稍后重试(通常在后来DriverPoll)。
- 6 如果使用立即发送数据模式，则虚拟驱动程序可以随时发送数据。 要发送数据，虚拟通道驱动程序将使用SendData函数（此地址在初始化期间获得）将数据块发送到通道的服务器端版本。 虚拟驱动程序可能会尝试发送一个或多个数据包（VirtualWrites），直到没有更多数据要发送，或者SendData函数返回错误代码`CLIENT_ERROR_NO_OUTBUF`，以指示没有更多的缓冲区空间，并且所讨论的数据具有 不被接受，必须稍后重试。 当WinStation驱动程序向虚拟驱动程序的DriverPoll函数发出特殊的“通知”调用时，通常会发生重试。 当WinStation驱动程序检测到缓冲区已被释放并且可以重试发送数据操作时，将发出通知DriverPoll调用。

### Module.ini

### 虚拟通道数据包

ICA不定义虚拟信道包的内容。内容特定于特定的虚拟通道，不由ICA数据流管理器解释或管理。您必须为虚拟通道数据开发自己的协议。

虚拟信道包的长度可以是ICA连接所支持的最大大小。这个大小独立于底层传输的大小限制。这些限制会影响服务器端WFVirtualChannelRead和WFVirtualChannelWrite函数，以及客户端的QueueVirtualWrite和SendData函数。最大数据包大小为5000字节(4996个数据字节加上ICA datastream管理器生成的数据包开销的4个字节)。

虚拟驱动程序和服务器端应用程序都可以查询最大数据包大小。有关查询客户端最大数据包大小的示例，请参见DriverOpen

### 流程控制

ICA虚拟通道为下游(服务器到客户端)流控制提供支持，但目前不支持上游流控制。服务器接收到的数据将排队等待使用。

某些传输协议（例如TCP / IP）提供流控制，而其他传输协议（例如IPX）不提供流控制。 如果需要数据流控制，您可能需要将其设计到虚拟通道中。

为ICA虚拟通道选择三种流控制类型之一：“None”，“Delay”或“ ACK”。 每个虚拟通道可以具有自己的流量控制方法。 流量控制方法由初始化期间使用虚拟驱动程序。

- None

> ICA不控制数据流。假设客户端可以处理所有发送的数据。您必须将任何所需的流控制实现为虚拟通道协议的一部分。这种方法是最难实现的，但是提供了最大的灵活性。Ping示例不使用流控制，也不需要它
 
- Delay

> 延迟流控制是一种对从服务器发送的数据进行定速的简单方法。当客户端虚拟驱动程序指定延迟流控制时，它还提供以毫秒为单位的延迟时间。服务器在它发送的每个数据包之间等待指定的延迟时间。

- ACK

> ACK流控制提供了所谓的滑动窗口。使用ACK流控制，客户机指定它的最大缓冲区大小(它在任何时候可以处理的最大数据量)。服务器将发送到该数量的数据。当客户端虚拟驱动程序完成对其全部或部分缓冲区的处理时，发送一个ACK ICA包，指示处理了多少数据。然后，服务器可以发送更多的数据字节，直到客户端确认的字节数为止。
> 
> 此ACK是不透明的，虚拟驱动程序必须显式地构造ACK包并将其发送到服务器。服务器发送整个数据包;如果下一个要发送的包比窗口大，服务器将阻止发送，直到窗口足够大以容纳整个包为止。

### WIndows监控API

#### 概述

这些api允许创建同步在主机(XenApp或XenDesktop)上运行的应用程序的可视方面与运行在Citrix插件上的相应可视元素的解决方案。api由两个不同的部分组成:客户端和主机端。客户端组件向第三方公开了以前不可用的功能。这包括在客户端桌面获取关于ICA窗口的信息(如句柄、尺寸、平移和缩放)、给定主机窗口的对应客户端窗口，以及设置一个回调函数，以便在ICA窗口更改时调用。主机组件是WinFrame API的一部分，它允许通过内核模式调用跟踪主机上的窗口位置。

#### 关键点

这些API包涵以下特性：

- 允许通过WinFrame API有效地跟踪主机上的窗口
- 提供使用虚拟通道SDK与客户端桌面显示同步的方法。
- 为第三方应用程序提供更好的视觉体验和支持，以更好地集成ICA。

#### API的使用

##### 准备开始
-  Headers: wdapi.h
- Libraries: wdica30.lib 

##### 架构

api提供了两个有它们自己的体系结构的不同的组件：主机端和客户端。主机组件是WinFrame API的一部分，它提供对被跟踪的窗口的更新。然后可以将此数据与Citrix插件通信，以便同步窗口位置。然后，虚拟通道SDK中的客户端组件允许第三方与ICA窗口进行同步。它为他们提供关于ICA窗口的大小和句柄的信息，以及它是平移还是缩放。总的来说，这些api允许第三方应用程序更好地与ICA集成，并提供更好的视觉体验。

客户端在虚拟通道SDK中扩展了当前的WdQueryInformation系统，以公开第三方以前无法使用的功能。用户调用预先存在的VdCallWd函数来调用WinStation驱动程序的QueryInformation函数，该函数执行请求的任务。

##### 例子

- 获取ICA窗口信息

> 这个示例展示了如何收集关于ICA窗口的信息。它用关于ICA窗口当前状态的信息填充一个结构体。这包括它的尺寸、句柄、视图区域尺寸和偏移量(例如，平移)，以及它当前的模式(例如，缩放、平移、无缝)。

```c++
WDQUERYINFORMATION wdQueryInfo;
UINT16 uiSize;
int rc;
WDICAWINDOWINFO infoParam;
wdQueryInfo.WdInformationClass = WdGetICAWindowInfo;
wdQueryInfo.pWdInformation = &infoParam;
wdQueryInfo.WdInformationLength = sizeof(infoParam);
uiSize = sizeof(wdQueryInfo);
rc = VdCallWd(g_pVd, WDxQUERYINFORMATION, &wdQueryInfo, &uiSize);
if(CLIENT_STATUS_SUCCESS == rc)
{
// Successfully populated infoParam with ICA window
// information
}
```

- 获取相应的客户端窗口

> 这个示例展示了如何为给定的服务器窗口获取相应的客户端窗口。

```c++
WDQUERYINFORMATION wdQueryInfo;
UINT16 uiSize;
int rc;
HWND window = 0x42; // example server window handle
wdQueryInfo.WdInformationClass = WdGetClientWindowFromServerWindow;
wdQueryInfo.pWdInformation = &window;
wdQueryInfo.WdInformationLength = sizeof(window);
uiSize = sizeof(wdQueryInfo);
rc = VdCallWd(g_pVd, WDxQUERYINFORMATION, &wdQueryInfo, &uiSize);
if(CLIENT_STATUS_SUCCESS == rc)
{
// Success, pWdInformation now points to the
//corresponding client window hwnd.
}
```

- 注册ICA窗口回调

> 这个示例展示了如何注册一个在ICA窗口更改时调用的回调函数。它注册一个名为Foo的用户定义回调函数。之后，每当ICA窗口发生变化时，就会调用Foo，并传入当前ICA窗口模式。然后使用WdGetICAWindowInfo信息类收集关于ICA窗口的更多信息，如第一个示例所示。

```c++
WDQUERYINFORMATION wdQueryInfo;
UINT16 uiSize;
int rc;
WDREGISTERWINDOWCALLBACKPARAMS callbackParams;
callbackParams.pfnCallback = &Foo; // Your callback function
wdQueryInfo.WdInformationClass = WdRegisterWindowChangeCallback;
wdQueryInfo.pWdInformation = &callbackParams;
wdQueryInfo.WdInformationLength = sizeof(callbackParams);
uiSize = sizeof(wdQueryInfo);
rc = VdCallWd(g_pVd, WDxQUERYINFORMATION, &wdQueryInfo, &uiSize);
if(CLIENT_STATUS_SUCCESS == rc)
{
// Callback successfully registered.
// Function Foo will be called whenever the ICA window
// mode, position, or size changes.
}
```

- 取消注册ICA窗口回调

> 这个示例展示了如何取消注册以前的ICA窗口更改回调函数。它从前面的示例中注销回调函数Foo。当ICA窗口改变时，回调函数不再被调用。

```c++
WDQUERYINFORMATION wdQueryInfo;
UINT16 uiSize;
int rc;
wdQueryInfo.WdInformationClass = WdUnregisterWindowChangeCallback
wdQueryInfo.pWdInformation = &callbackParams.Handle;
// Previously returned handle
wdQueryInfo.WdInformationLength = sizeof(callbackParams.Handle);
uiSize = sizeof(wdQueryInfo);
rc = VdCallWd(g_pVd, WDxQUERYINFORMATION, &wdQueryInfo, &uiSize);
if(CLIENT_STATUS_SUCCESS == rc)
{
// Callback successfully unregistered
}
```


#### 编程指南

作为一个整体，api为那些在主机和客户端桌面之间协调窗口的应用程序提供了更好的窗口控制。通常，主机使用API的WinFrame API组件来跟踪感兴趣的窗口。主机监听指定的邮件槽，以跟踪关于其窗口的更新。然后这些更新被传递到Citrix插件，在那里它们被用来正确地定位相应的窗口。Citrix插件使用Virtual Channel SDK中的api的客户端部分来同步它的窗口和ICA窗口。当ICA窗口发生更改时，可以通知Citrix插件，从而对其他第三方应用程序进行任何必要的更改。

#### 编程参考

##### 结构体

- WDQUERYINFORMATION

> 已存在的，传递给WinStation驱动程序的QueryInformation方法的结构体。存储输入的同时也存储结果输出。

```c++
typedef struct _WDQUERYINFORMATION
{
WDINFOCLASS WdInformationClass;
LPVOID pWdInformation;
USHORT WdInformationLength;
USHORT WdReturnLength;
} WDQUERYINFORMATION, * PWDQUERYINFORMATION;
```

> - WdInformationonClass: 设置为与要调用的API函数对应的enum值。
> -  pWdInformation: 此函数调用的必要输入参数(如果有)。如果调用返回任何内容，它也存储在这里。
> -  WdInformationLength: 设置pWdInformation指向的输入数据的大小。
> -  WdReturnLength: 返回时填写;pWdInformation指向的返回值的大小。

- WDICAWINDOWINFO


> 结构体在使用WdGetICAWindowInfo类时作为输入传递。成功返回后，它将填充关于ICA窗口的信息。

```c++
typedef struct _WDICAWINDOWINFO
{
HWND hwnd;
WDICAWINDOWMODE mode;
UINT32 xWinWidth, yWinHeight, xViewWidth, yViewHeight;
INT xViewOffset, yViewOffset;
} WDICAWINDOWINFO, * PWDICAWINDOWINFO;
```

> - hwnd: ICA 窗口句柄.
> -  mode: ICA 窗口的当前模式(如拉伸、平移、无缝等)
> -  xWinWidth: ICA 窗口宽度.
> -  yWinHeight: ICA 窗口高度.
> -  xViewWidth: ICA 窗口视图区域宽度.
> -  yViewHeight: ICA 窗口视图区域高度.
> -  xViewOffset: 视图区域在x维度上的偏移量 (水平平移).
> -  yViewOffset: 视图区域在y维度上的偏移量(垂直平移 ).


- WDREGISTERWINDOWCALLBACKPARAMS

> 结构体在使用WdRegisterWindowChangeCallback信息类时作为输入传递。

```c++
typedef struct _WDREGISTERWINDOWCALLBACKPARAMS
{
PFNWD_WINDOWCHANGED pfnCallback;
UINT32 Handle;
} WDREGISTERWINDOWCALLBACKPARAMS, *PWDREGISTERWINDOWCALLBACKPARAMS;
```

> - pfnCallback: T当ICA窗口更改(例如，其模式、维度、视图)时将调用的用户定义函数。这个函数应该有以下头部，UINT参数是ICA窗口的当前模式(参见WDICAWINDOWMODE): `typedef VOID (cdecl * PFNWD WINDOWCHANGED) (UINT32)`

> - Handle: 成功返回时，将填充此句柄。稍后，当取消注册回调时，可以使用它来标识句柄。

##### 联合

- WDICAWINDOWMODE

> 用于存储ICA窗口的当前模式

```c++
typedef union _WDICAWINDOWMODE
{
struct
{
UINT Reserved : 1;
UINT Seamless : 1;
UINT Panning : 1;
UINT Scaling : 1;
} Flags;
UINT Value;
} WDICAWINDOWMODE;
```

> - Reserved: 模式的保留部分，当前未使用。
> - Seamless: ICA窗口目前处于无缝模式。
> - Panning: ICA窗口当前正在平移（即，垂直/水平滚动）.
> - Scaling: ICA窗口当前正在缩放.
> - Value: 模式的原始值.

##### 枚举

- WDINFOCLASS

> WDINFOCLASS枚举有四个值供Windows监控API使用

> - WdGetICAWindowInfo
> - WdGetClientWindowFromServerWindow
> - WdRegisterWindowChangeCallback
> - WdUnregisterWindowChangeCallback

## Chapter 4 Programming Guide

## Chapter 5 Programming Reference
