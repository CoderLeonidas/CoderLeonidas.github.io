---
layout:     post
title:      "虚拟通道SDK编程指南"
date:       2020-03-13 19:08:02
author:     "CoderLeonidas"
catalog: true
tags:

- VDI
- 虚拟化技术
- 翻译


---

# 虚拟通道SDK编程指南

## Chapter 1 Using the Virtual Channel SDK

## Chapter 2 Architecture


ICA)虚拟通道是运行Citrix XenApp的服务器和客户端设备之间交换通用数据包数据的双向无错误连接。开发人员可以使用虚拟通道向客户端添加功能。虚拟通道的使用包括

1. 支持管理功能
1. 新的数据流(音频和视频)
1. 新设备，如扫描仪、读卡器和操纵杆)


## 虚拟通道概述

ICA虚拟通道是双向通用交换的无错连接客户端和运行Citrix XenApp或XenDesktop的服务器之间的数据包数据。 每个ICA虚拟通道的实现包含两个组件：

- 运行XenApp或XenDesktop的计算机上的服务器端部分

- 客户端设备上的客户端部分
> 客户端虚拟通道驱动程序是一个可动态加载的模块(. dll)，在客户端上下文中执行。您必须编写您的虚拟驱动程序。


该图演示了虚拟通道客户机-服务器连接

![](https://i.loli.net/2020/03/13/7bWZ1cMBekvYza2.png)


**WinStation**驱动程序负责从ICA数据流中多路分解(demultiplexed)虚拟通道数据，并将其路由到正确的处理模块(在本例中是虚拟驱动程序DLL)。WinStation驱动程序还负责通过ICA连接收集和发送虚拟通道数据到服务器。在客户端，WinStation驱动程序也称为客户端引擎，或简称为引擎。


下面是使用虚拟通道进行客户机-服务器数据交换的概述

- 客户端连接到运行XenApp或XenDesktop的服务器。客户机将有关它支持的虚拟通道的信息传递给服务器。
- 服务器端应用程序启动，获取虚拟通道的句柄，并可选地查询关于该通道的其他信息。
-  客户端虚拟驱动程序和服务器端应用程序使用以下两种方法传递数据：
 - 如果服务器应用程序有数据要发送给客户机，则立即将数据发送给客户机。当客户端接收到数据时，WinStation驱动程序从ICA流中解复用虚拟通道数据，并立即将其传递给客户端虚拟驱动程序。
 - 如果客户端虚拟驱动程序要向服务器发送数据，则可以立即发送数据，或者在下一次WinStation驱动程序轮询虚拟驱动程序时发送数据。当服务器接收到数据时，它将排队，直到虚拟通道应用程序读取它。无法通知服务器虚拟通道应用程序接收到数据。
-  当服务器虚拟通道应用程序完成时，它关闭虚拟通道并释放所有分配的资源。



### ICA和虚拟信道数据包

虚拟通道数据包封装在客户端和服务器之间的ICA流中。因为ICA是表示层协议，并且运行在几种不同的传输上，所以虚拟通道应用程序编程接口(API)允许开发人员编写自己的协议，而不必担心底层的传输。数据包被保留。

例如，如果向服务器发送100个字节，则当虚拟通道从ICA数据流进行多路复用(demultiplexed)时，服务器将接收相同的100个字节。编译后的代码独立于当前配置的传输协议运行。

ICA引擎为虚拟通道提供以下服务：

- 打包封包
> ICA虚拟通道是基于包的，这意味着如果一端使用一定数量的数据执行写操作，另一端在执行读操作时接收整个数据块。这与TCP形成了对比，例如，TCP是基于流的，需要更高级别的协议来解析包边界。换句话说，虚拟信道包包含在ICA流中，ICA流由系统软件单独管理。

- 误差校正
> 即使基础传输不可靠，ICA也提供自己的可靠性机制。这保证了连接是无错误的，并且数据是按照发送的顺序接收的。

- 流程控制
> 虚拟通道API提供了几种类型的流控制。这允许设计人员在任何时候都只处理特定数量的数据。


### 客户端WinStation驱动程序和虚拟驱动程序交互

客户端虚拟驱动程序可以选择以两种模式之一发送数据

- 轮询模式(Polling mode)

- 立即模式(Immediate mode)

如果运行在轮询模式，WinStation驱动程序通过调用它的DriverPoll函数来定期轮询每个虚拟驱动程序。当调用DriverPoll时，虚拟驱动程序应该立即检查任何必要的状态信息，发送任何排队的数据，并将控制权返回给WinStation驱动程序。 

如果在立即模式下操作，虚拟驱动程序可以在任何时候发送数据。例如，假设驱动程序在ICADataArrival函数中收到来自服务器的数据包。在即时发送数据模式下，驱动程序可以对收到的数据包立即发送数据，然后控制权将从ICADataArrival函数返回到WinStation驱动程序。


当虚拟驱动程序试图向服务器发送数据时，它应该准备好数据发送操作，有时会被拒绝。可能会出现这种情况，因为WinStation驱动程序支持合理但不过量的排队等待发送到服务器的backlog。如果发送操作被拒绝，虚拟驱动程序必须安排稍后重试发送。

在任何情况下，无论是轮询模式还是立即模式，虚拟驱动程序都不能阻塞。当WinStation驱动程序调用任何驱动程序函数时，虚拟驱动程序必须立即检查任何必要的状态信息，发送任何排队的数据，并将控制权返回给WinStation驱动程序。

当用户启动客户机时，将执行以下过程：

- 1 在客户端加载时，客户端引擎读取注册表中的配置存储以确定要配置的模块，包括如何配置虚拟通道驱动程序。
- 2 客户端引擎通过调用Load函数加载注册表中配置存储中定义的虚拟通道驱动程序，该函数必须由虚拟通道驱动程序. dll显式导出。Load函数是在静态库文件 Vdapi.lib中定义的。 Vdapi.lib，在这个SDK中提供。每个驱动程序都必须链接到这个库文件。Load函数将. dll中定义的驱动入口点转发给客户端引擎。
- 3 对于每个虚拟通道，WinStation驱动程序调用DriverOpen函数，该函数建立并初始化虚拟通道。WinStation驱动程序将WinStation驱动程序中的一个发送数据输出函数的地址传递给虚拟通道驱动程序。虚拟通道驱动程序将ICADataArrival函数的地址传递给WinStation驱动程序。WinStation驱动程序在客户端加载时为每个虚拟驱动程序调用DriverOpen函数，而不是在服务器端应用程序打开虚拟通道时调用
- 4 当虚拟通道数据从服务器到达时，WinStation驱动程序为该虚拟驱动程序调用ICADataArrival函数。
- 5如果使用发送数据轮询模式，则虚拟驱动程序无法启动数据传输。相反，WinStation驱动程序调用DriverPoll来轮询要发送到服务器的数据。要发送数据，虚拟通道驱动程序可以使用QueueVirtualWrite函数(这个地址是在初始化期间获得的)将数据块发送到服务器端版本的通道。DriverPoll期间,虚拟驱动程序可能试图发送一个或多个包(VirtualWrites),直到没有更多的数据发送,或QueueVirtualWrite函数返回错误代码`CLIENT_ERROR_NO_OUTBUF`,表明没有更多的缓冲空间,和数据没有被接受,而且必须稍后重试(通常在后来DriverPoll)。
- 6 如果使用立即发送数据模式，则虚拟驱动程序可以随时发送数据。 要发送数据，虚拟通道驱动程序将使用SendData函数（此地址在初始化期间获得）将数据块发送到通道的服务器端版本。 虚拟驱动程序可能会尝试发送一个或多个数据包（VirtualWrites），直到没有更多数据要发送，或者SendData函数返回错误代码`CLIENT_ERROR_NO_OUTBUF`，以指示没有更多的缓冲区空间，并且所讨论的数据具有 不被接受，必须稍后重试。 当WinStation驱动程序向虚拟驱动程序的DriverPoll函数发出特殊的“通知”调用时，通常会发生重试。 当WinStation驱动程序检测到缓冲区已被释放并且可以重试发送数据操作时，将发出通知DriverPoll调用。

### Module.ini

### 虚拟通道数据包

ICA不定义虚拟信道包的内容。内容特定于特定的虚拟通道，不由ICA数据流管理器解释或管理。您必须为虚拟通道数据开发自己的协议。

虚拟信道包的长度可以是ICA连接所支持的最大大小。这个大小独立于底层传输的大小限制。这些限制会影响服务器端WFVirtualChannelRead和WFVirtualChannelWrite函数，以及客户端的QueueVirtualWrite和SendData函数。最大数据包大小为5000字节(4996个数据字节加上ICA datastream管理器生成的数据包开销的4个字节)。

虚拟驱动程序和服务器端应用程序都可以查询最大数据包大小。有关查询客户端最大数据包大小的示例，请参见DriverOpen

### 流程控制

ICA虚拟通道为下游(服务器到客户端)流控制提供支持，但目前不支持上游流控制。服务器接收到的数据将排队等待使用。

某些传输协议（例如TCP / IP）提供流控制，而其他传输协议（例如IPX）不提供流控制。 如果需要数据流控制，您可能需要将其设计到虚拟通道中。

为ICA虚拟通道选择三种流控制类型之一：“None”，“Delay”或“ ACK”。 每个虚拟通道可以具有自己的流量控制方法。 流量控制方法由初始化期间使用虚拟驱动程序。

- None

> ICA不控制数据流。假设客户端可以处理所有发送的数据。您必须将任何所需的流控制实现为虚拟通道协议的一部分。这种方法是最难实现的，但是提供了最大的灵活性。Ping示例不使用流控制，也不需要它
 
- Delay

> 延迟流控制是一种对从服务器发送的数据进行定速的简单方法。当客户端虚拟驱动程序指定延迟流控制时，它还提供以毫秒为单位的延迟时间。服务器在它发送的每个数据包之间等待指定的延迟时间。

- ACK

> ACK流控制提供了所谓的滑动窗口。使用ACK流控制，客户机指定它的最大缓冲区大小(它在任何时候可以处理的最大数据量)。服务器将发送到该数量的数据。当客户端虚拟驱动程序完成对其全部或部分缓冲区的处理时，发送一个ACK ICA包，指示处理了多少数据。然后，服务器可以发送更多的数据字节，直到客户端确认的字节数为止。
> 
> 此ACK是不透明的，虚拟驱动程序必须显式地构造ACK包并将其发送到服务器。服务器发送整个数据包;如果下一个要发送的包比窗口大，服务器将阻止发送，直到窗口足够大以容纳整个包为止。

### WIndows监控API

#### 概述

这些api允许创建同步在主机(XenApp或XenDesktop)上运行的应用程序的可视方面与运行在Citrix插件上的相应可视元素的解决方案。api由两个不同的部分组成:客户端和主机端。客户端组件向第三方公开了以前不可用的功能。这包括在客户端桌面获取关于ICA窗口的信息(如句柄、尺寸、平移和缩放)、给定主机窗口的对应客户端窗口，以及设置一个回调函数，以便在ICA窗口更改时调用。主机组件是WinFrame API的一部分，它允许通过内核模式调用跟踪主机上的窗口位置。

#### 关键点

这些API包涵以下特性：

- 允许通过WinFrame API有效地跟踪主机上的窗口
- 提供使用虚拟通道SDK与客户端桌面显示同步的方法。
- 为第三方应用程序提供更好的视觉体验和支持，以更好地集成ICA。

#### API的使用

##### 准备开始
-  Headers: wdapi.h
- Libraries: wdica30.lib 

##### 架构

api提供了两个有它们自己的体系结构的不同的组件：主机端和客户端。主机组件是WinFrame API的一部分，它提供对被跟踪的窗口的更新。然后可以将此数据与Citrix插件通信，以便同步窗口位置。然后，虚拟通道SDK中的客户端组件允许第三方与ICA窗口进行同步。它为他们提供关于ICA窗口的大小和句柄的信息，以及它是平移还是缩放。总的来说，这些api允许第三方应用程序更好地与ICA集成，并提供更好的视觉体验。

客户端在虚拟通道SDK中扩展了当前的WdQueryInformation系统，以公开第三方以前无法使用的功能。用户调用预先存在的VdCallWd函数来调用WinStation驱动程序的QueryInformation函数，该函数执行请求的任务。

##### 例子

- 获取ICA窗口信息

> 这个示例展示了如何收集关于ICA窗口的信息。它用关于ICA窗口当前状态的信息填充一个结构体。这包括它的尺寸、句柄、视图区域尺寸和偏移量(例如，平移)，以及它当前的模式(例如，缩放、平移、无缝)。

```c++
WDQUERYINFORMATION wdQueryInfo;
UINT16 uiSize;
int rc;
WDICAWINDOWINFO infoParam;
wdQueryInfo.WdInformationClass = WdGetICAWindowInfo;
wdQueryInfo.pWdInformation = &infoParam;
wdQueryInfo.WdInformationLength = sizeof(infoParam);
uiSize = sizeof(wdQueryInfo);
rc = VdCallWd(g_pVd, WDxQUERYINFORMATION, &wdQueryInfo, &uiSize);
if(CLIENT_STATUS_SUCCESS == rc)
{
// Successfully populated infoParam with ICA window
// information
}
```

- 获取相应的客户端窗口

> 这个示例展示了如何为给定的服务器窗口获取相应的客户端窗口。

```c++
WDQUERYINFORMATION wdQueryInfo;
UINT16 uiSize;
int rc;
HWND window = 0x42; // example server window handle
wdQueryInfo.WdInformationClass = WdGetClientWindowFromServerWindow;
wdQueryInfo.pWdInformation = &window;
wdQueryInfo.WdInformationLength = sizeof(window);
uiSize = sizeof(wdQueryInfo);
rc = VdCallWd(g_pVd, WDxQUERYINFORMATION, &wdQueryInfo, &uiSize);
if(CLIENT_STATUS_SUCCESS == rc)
{
// Success, pWdInformation now points to the
//corresponding client window hwnd.
}
```

- 注册ICA窗口回调

> 这个示例展示了如何注册一个在ICA窗口更改时调用的回调函数。它注册一个名为Foo的用户定义回调函数。之后，每当ICA窗口发生变化时，就会调用Foo，并传入当前ICA窗口模式。然后使用WdGetICAWindowInfo信息类收集关于ICA窗口的更多信息，如第一个示例所示。

```c++
WDQUERYINFORMATION wdQueryInfo;
UINT16 uiSize;
int rc;
WDREGISTERWINDOWCALLBACKPARAMS callbackParams;
callbackParams.pfnCallback = &Foo; // Your callback function
wdQueryInfo.WdInformationClass = WdRegisterWindowChangeCallback;
wdQueryInfo.pWdInformation = &callbackParams;
wdQueryInfo.WdInformationLength = sizeof(callbackParams);
uiSize = sizeof(wdQueryInfo);
rc = VdCallWd(g_pVd, WDxQUERYINFORMATION, &wdQueryInfo, &uiSize);
if(CLIENT_STATUS_SUCCESS == rc)
{
// Callback successfully registered.
// Function Foo will be called whenever the ICA window
// mode, position, or size changes.
}
```

- 取消注册ICA窗口回调

> 这个示例展示了如何取消注册以前的ICA窗口更改回调函数。它从前面的示例中注销回调函数Foo。当ICA窗口改变时，回调函数不再被调用。

```c++
WDQUERYINFORMATION wdQueryInfo;
UINT16 uiSize;
int rc;
wdQueryInfo.WdInformationClass = WdUnregisterWindowChangeCallback
wdQueryInfo.pWdInformation = &callbackParams.Handle;
// Previously returned handle
wdQueryInfo.WdInformationLength = sizeof(callbackParams.Handle);
uiSize = sizeof(wdQueryInfo);
rc = VdCallWd(g_pVd, WDxQUERYINFORMATION, &wdQueryInfo, &uiSize);
if(CLIENT_STATUS_SUCCESS == rc)
{
// Callback successfully unregistered
}
```


#### 编程指南

作为一个整体，api为那些在主机和客户端桌面之间协调窗口的应用程序提供了更好的窗口控制。通常，主机使用API的WinFrame API组件来跟踪感兴趣的窗口。主机监听指定的邮件槽，以跟踪关于其窗口的更新。然后这些更新被传递到Citrix插件，在那里它们被用来正确地定位相应的窗口。Citrix插件使用Virtual Channel SDK中的api的客户端部分来同步它的窗口和ICA窗口。当ICA窗口发生更改时，可以通知Citrix插件，从而对其他第三方应用程序进行任何必要的更改。

#### 编程参考

##### 结构体

- WDQUERYINFORMATION

> 已存在的，传递给WinStation驱动程序的QueryInformation方法的结构体。存储输入的同时也存储结果输出。

```c++
typedef struct _WDQUERYINFORMATION
{
WDINFOCLASS WdInformationClass;
LPVOID pWdInformation;
USHORT WdInformationLength;
USHORT WdReturnLength;
} WDQUERYINFORMATION, * PWDQUERYINFORMATION;
```

> - WdInformationonClass: 设置为与要调用的API函数对应的enum值。
> -  pWdInformation: 此函数调用的必要输入参数(如果有)。如果调用返回任何内容，它也存储在这里。
> -  WdInformationLength: 设置pWdInformation指向的输入数据的大小。
> -  WdReturnLength: 返回时填写;pWdInformation指向的返回值的大小。

- WDICAWINDOWINFO


> 结构体在使用WdGetICAWindowInfo类时作为输入传递。成功返回后，它将填充关于ICA窗口的信息。

```c++
typedef struct _WDICAWINDOWINFO
{
HWND hwnd;
WDICAWINDOWMODE mode;
UINT32 xWinWidth, yWinHeight, xViewWidth, yViewHeight;
INT xViewOffset, yViewOffset;
} WDICAWINDOWINFO, * PWDICAWINDOWINFO;
```

> - hwnd: ICA 窗口句柄.
> -  mode: ICA 窗口的当前模式(如拉伸、平移、无缝等)
> -  xWinWidth: ICA 窗口宽度.
> -  yWinHeight: ICA 窗口高度.
> -  xViewWidth: ICA 窗口视图区域宽度.
> -  yViewHeight: ICA 窗口视图区域高度.
> -  xViewOffset: 视图区域在x维度上的偏移量 (水平平移).
> -  yViewOffset: 视图区域在y维度上的偏移量(垂直平移 ).


- WDREGISTERWINDOWCALLBACKPARAMS

> 结构体在使用WdRegisterWindowChangeCallback信息类时作为输入传递。

```c++
typedef struct _WDREGISTERWINDOWCALLBACKPARAMS
{
PFNWD_WINDOWCHANGED pfnCallback;
UINT32 Handle;
} WDREGISTERWINDOWCALLBACKPARAMS, *PWDREGISTERWINDOWCALLBACKPARAMS;
```

> - pfnCallback: T当ICA窗口更改(例如，其模式、维度、视图)时将调用的用户定义函数。这个函数应该有以下头部，UINT参数是ICA窗口的当前模式(参见WDICAWINDOWMODE): `typedef VOID (cdecl * PFNWD WINDOWCHANGED) (UINT32)`

> - Handle: 成功返回时，将填充此句柄。稍后，当取消注册回调时，可以使用它来标识句柄。

##### 联合

- WDICAWINDOWMODE

> 用于存储ICA窗口的当前模式

```c++
typedef union _WDICAWINDOWMODE
{
struct
{
UINT Reserved : 1;
UINT Seamless : 1;
UINT Panning : 1;
UINT Scaling : 1;
} Flags;
UINT Value;
} WDICAWINDOWMODE;
```

> - Reserved: 模式的保留部分，当前未使用。
> - Seamless: ICA窗口目前处于无缝模式。
> - Panning: ICA窗口当前正在平移（即，垂直/水平滚动）.
> - Scaling: ICA窗口当前正在缩放.
> - Value: 模式的原始值.

##### 枚举

- WDINFOCLASS

> WDINFOCLASS枚举有四个值供Windows监控API使用

> - WdGetICAWindowInfo
> - WdGetClientWindowFromServerWindow
> - WdRegisterWindowChangeCallback
> - WdUnregisterWindowChangeCallback

### Cirix动态虚拟通道协议

#### 架构

DVC协议的主要目的是在传统静态虚拟通道(SVCs)上提供一个通用的基于连接的通信基础设施

动态虚拟通道(DVCs)通过SVCs进行多路复用。一般来说，在ICA上每一项技术使用一个SVC。DVC协议提供了在逻辑上连接的动态虚拟通道端点之间创建和通信的能力。

动态虚拟通道是在ICA主机上运行的应用程序(第一个端点)和ICA客户机上运行的应用程序(第二个端点，称为DVC侦听器)之间创建的端到端连接。端到端DVC连接是通过ICA连接建立和维护的。

单独的DVC实例由DVC管理器创建和维护。有一个DVC管理器在主机上运行(作为设备驱动程序和服务实现)，另一个在客户机上运行(作为虚拟驱动程序DLL实现)。主机负责创建动态虚拟通道，客户机负责创建和维护到客户端DVC应用程序的连接。

一旦建立了DVC连接，主机和客户端DVC应用程序就可以互相发送数据消息。这些消息可以由任何一方发起，发送和接收消息在任何一方都是相同的。

该协议允许DVC使用多个静态通道。默认情况下，每个代表特定技术的DVC插件都在单独的SVC上运行。这允许管理员通过管理各自的SVC的优先级来对各个DVC-remoted技术进行优先级排序。但是，还可以配置DVC客户端，以便两个或多个DVC插件可以共享SVC。 在极少数情况下，当DVC插件的数量大于可用SVC的数量时，这可能是理想的。 当前，ICA上最多支持64个SVC。

#### 如何写在ICA上的DVC组件

Microsoft s DVC是在远程桌面协议上实现的，Citrix DVC协议是在ICA协议上实现的。要在ICA上编写DVC组件，可以使用Microsoft的DVC API。

[DVC服务端API](https://docs.microsoft.com/zh-cn/windows/win32/termserv/dvc-server-apis?redirectedfrom=MSDN)

[DVC客户端API](https://docs.microsoft.com/zh-cn/windows/win32/termserv/dvc-client-apis?redirectedfrom=MSDN)

#### Cirix动态虚拟通道设置

以下步骤在动态虚拟通道的生存期内执行：




#### 命名静态虚拟通道

#### 在ICA上编写DVC组件的步骤

## Chapter 3 Using Example Programs

## Chapter 4 Programming Guide

虚拟通道由一个7个字符(或更短)的ASCII名称引用。在以前的几个ICA协议版本中，对虚拟通道进行了编号;数字现在是根据ASCII名称动态分配的，这使得实现更加容易。

在开发仅供内部使用的虚拟通道代码时，可以使用与现有虚拟通道不冲突的任何7个字符的名称。只使用大写和小写的ASCII字母和数字。在添加自己的虚拟通道时，请遵循现有的命名约定。

预定义的通道以OEM标识符CTX开头，仅供Citrix使用

### 设计建议

遵循这些建议，可使您的虚拟通道更容易设计和增强

- 在设计自己的虚拟通道协议时，要考虑添加特性的灵活性。虚拟通道具有在初始化期间交换的版本号，以便客户机和服务器都能检测到可以使用的最大功能级别。例如，如果客户端在版本3，而服务器在版本5，服务器不会发送任何功能超过版本3的包，因为客户端不知道如何解释新的包。

- - 因为虚拟通道协议的服务器端可以作为一个单独的进程实现，所以在服务器上编写使用citrix提供的虚拟通道支持进行接口的代码要比在客户机上编写(在客户机上，代码必须适合现有的代码结构)容易得多。虚拟通道的服务器端简单地打开通道，对通道进行读写操作，完成后关闭通道。
- - 为服务器端编写代码与编写应用程序类似，后者使用系统导出的服务。编写一个应用程序来处理虚拟通道通信比较容易，因为它可以为每个支持虚拟通道的ICA连接运行一次。
- - 为客户端编写类似于编写驱动程序，除了使用系统服务外，驱动程序还必须向系统提供服务。如果编写了一个服务，它必须管理多个连接。

- 如果您正在设计用于新的虚拟通道的新硬件(例如，一种改进的压缩视频格式)，请确保能够检测到硬件，以便客户端能够确定是否安装了硬件。如果在服务器使用新数据格式之前硬件可用，则客户机可以与服务器通信。或者，您可以让虚拟驱动程序转换新的数据格式，以便与旧的硬件一起使用。

- 可能会有一些限制阻止您的新虚拟通道以最佳水平执行。如果客户端通过调制解调器或串行连接连接到运行XenApp的服务器，带宽可能不够大，无法正确支持音频或视频数据。您可以使您的协议具有自适应能力，因此当带宽减少时，性能会优雅地下降，可能通过正常发送声音而降低视频的帧速率来适应可用的带宽。


- 要确定问题发生在何处(连接、实现或协议)，首先要使连接和通信工作。然后，在虚拟通道完成并调试之后，进行一些时间试验并记录结果。这些结果为测量进一步的优化(如压缩和其他增强)奠定了基础，从而使通道所需的带宽更少。


- `pVdPoll`变量中的时间戳有助于解决虚拟驱动程序中的计时问题。它是一个包含当前时间(以毫秒为单位)的**ULONG**。`pVdPoll`变量是指向`DLLPOLL`或`DLL_HPC_POLL`结构的指针。有关这些结构的定义，请参见`Dllapi.h`(在src\inc\中)。


### 服务端函数概述

### 客户端函数概述

客户端软件构建在模块化的可配置体系结构上，允许可替换的、可配置的模块(如虚拟通道驱动程序)处理ICA连接的各个方面。这些模块经过特殊的格式化并可动态加载。为了实现这种模块化功能，每个模块(包括虚拟通道驱动程序)实现一组固定的功能入口点。

有三组函数:用户定义的、虚拟驱动程序助手和内存INI。


#### 用户定义函数

为了使编写虚拟通道更容易，动态加载由WinStation驱动程序处理，而WinStation驱动程序又调用用户定义的函数。这简化了虚拟通道的创建，因为您所要做的就是填充函数并将您的虚拟通道驱动程序与Vdapi.lib链接起来。(由这个SDK提供)。

函数  | 描述
---- | ----
DriverClose   |  释放私有驱动程序数据。在卸载虚拟驱动程序之前调用(通常在客户端退出时)。
DriverGetLastError    | 返回虚拟驱动程序设置的最后一个错误。未使用; 与通用前端VDAPI的链接。
DriverInfo    | 获取虚拟驱动的信息
DriverOpen   | 执行虚拟驱动程序的所有初始化。在客户端加载虚拟驱动程序时调用一次(在启动时)
DriverPoll   | 允许驱动程序检查计时器和其他状态信息，将排队的数据发送到服务器，并执行任何其他需要的处理。定期调用，以查看虚拟驱动程序是否有要写入的数据。
DriverQueryInformation   | 从虚拟驱动程序获取运行时信息。
DriverSetInformation   | 设置虚拟驱动程序中的运行时信息
ICADataArrival   | 指示数据已交付。当数据到达虚拟信道时调用

#### 虚拟驱动程序助手函数

虚拟驱动程序使用助手函数来发送数据和管理虚拟通道。当WinStation驱动程序初始化虚拟驱动程序时，WinStation驱动程序将指针传递给助手函数，而虚拟驱动程序将指针传递给用户定义的函数。

VdCallWd作为VDAPI的一部分被链接进来，并且可以在所有用户实现的函数中使用。其他参数是在使用`WDxSETINFORMATION`参数调用VdCallWd时的`DriverOpen`期间获得的。

虚拟通道驱动程序可以通过在驱动程序打开期间获得的SendData或QueueVirtualWrite函数从私有缓冲区发送数据。如果win驱动程序本身不能缓冲数据，这两个函数中的任何一个都可能拒绝接受数据。然后，该通道需要在下一个驱动轮询上重试发送操作。

函数  | 描述
---- | ----
SendData   |  向服务器发送一个信道协议包，附带一个通知选项
QueueVirtualWrite   |  向服务器发送一个信道协议包。这是一个遗留功能。对新的虚拟驱动程序使用上面的SendData
VdCallWd   |  用于从WinStation驱动程序(WD)查询和设置信息


#### 内存INI函数


内存INI函数读取客户端引擎从注册表中的配置存储中读取并存储在内存INI结构中的数据。 必须使用这些函数，因为一些客户端设备将这些信息存储在ROM中，只有引擎可以访问这些INI数据。内存INI函数从这个内存INI结构中读取值，就像从配置存储中读取值一样。用于指定虚拟通道的配置存储在`Software\Citrix\ICA Client\Configuration\Advanced\Modules\`中。

>  重要：根据安全限制，对配置数据的访问可能受到限制。特别是，虚拟通道可能无法访问ICA文件的所有内容。这是由 `HKEY_LOCAL_MACHINE\SOFTWARE
\Citrix\ICA Client\Engine\Lock down Profiles\All Regions\Lock down` 这个注册表键来控制的。您可以使用组策略文件来修改注册表项。

函数  | 描述
---- | ----
miGetPrivateProfileBool | 返回一个bool
miGetPrivateProfileInt | 返回一个integer
miGetPrivateProfileLong | 返回一个long
miGetPrivateProfileString | 返回一个string


## Chapter 5 Programming Reference
