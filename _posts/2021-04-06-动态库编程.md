# 动态库编程

## 简介

应用程序很少作为一个单一代码模块来实现，因为操作系统实现了应用程序在库中需要的大部分功能。为了开发应用程序，程序员将他们的自定义代码链接到这些库中，以获得基本的功能，比如编写标准输出或使用显卡绘制复杂\_的能力。然而，链接到库会创建很大的可执行文件并浪费内存。**减少应用文件大小和内存占用**的一种方法是减少应用启动时加载的代码量。

要在运行时加载动态库，应用程序应该使用一组高效且可移植的函数(dynamic loader compatibility functions)，称为动态加载器兼容函数。使用这些函数可以确保以最有效的方式加载动态库，并方便将应用程序从一个平台移植到另一个平台。

本文档适用于动态库的开发人员以及在应用程序中使用动态库的开发人员。熟悉Mac OS、UNIX、Solaris和Linux操作系统。你也应该是一个有经验的C、c++或Objective-C程序员。

## 动态库概览

决定应用性能的两个重要因素是它们的启动时间和内存占用。减少应用程序的可执行文件的大小，并在它启动时最小化它的内存使用，能使应用程序启动时更快，使用更少的内存。使用动态库而不是静态库可以减少应用程序的可执行文件大小。它们还允许应用程序只有在需要的时候才延迟加载具有特殊功能的库，而不是在启动时。这个特性进一步减少了启动时间和有效的内存使用。

本章节介绍了动态库，并展示了如何使用动态库而不是静态库来减少使用它们的应用程序的文件大小和初始内存占用。本章节还概述了应用程序在运行时使用动态库时使用的动态加载器兼容函数。

### 什么是动态库

应用程序的大部分功能是在可执行代码库中实现的。当应用程序使用静态链接器与库链接时，应用程序使用的代码将被复制到生成的可执行文件中。静态链接器将已编译的源代码(称为目标代码object code)和库代码library code收集到一个可执行文件中，该文件在运行时全部加载到内存中。成为应用程序可执行文件一部分的那种库称为静态库。静态库是目标文件的集合或归档。

> 注意：静态库也称为静态归档库和静态链接共享库。


当一个应用程序被启动时，包含了它所链接的静态库代码的应用程序代码会被加载到应用程序的地址空间中。将许多静态库链接到应用程序中会生成大型应用程序可执行文件。图1显示了使用静态库中实现的功能的应用程序的内存使用情况。具有大型可执行文件的应用程序启动时间慢，内存占用大。此外，当一个静态库被更新时，它的客户端应用程序不会从对它的改进中受益。要访问改进后的功能，应用开发者必须将应用的目标文件与新版本的库链接起来。而这些应用程序的用户必须用最新版本替换他们的应用程序副本。因此，使用静态库提供的最新功能来更新应用程序需要开发人员和终端用户进行破坏性的工作。

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp5fqez453j30gp0c13z4.jpg)

一个更好的方法是当应用程序确实需要时，才加载代码到它的地址空间时，无论是在启动时或运行时。提供这种灵活性的库类型称为动态库。动态库不是静态地链接到客户端应用程序;它们不会成为可执行文件的一部分。相反，动态库可以在应用程序启动或运行时加载(并链接)到应用程序中。

> 注意：动态库也称为动态共享库、共享对象或动态链接库。

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp5fu6kfibj30gn0avaaw.jpg)

使用动态库，程序可以从自动使用的库的改进中受益，因为它们到库的链接是动态的，而不是静态的。也就是说，客户端应用程序的功能可以得到改进和扩展，而不需要应用程序开发人员重新编译应用程序。为OS X编写的应用程序可以从这个特性中受益，因为OS X中的所有系统库都是动态库。这就是使用Carbon 或 Cocoa 技术的应用程序从OS X的改进中受益的原因。

### 如何使用动态库

当一个应用程序启动时，OS X内核将应用程序的代码和数据加载到一个新进程的地址空间中。内核还将动态加载程序（/ usr / lib / dyld）加载到进程中，并将控制权传递给该进程。然后动态加载器加载应用程序的依赖库。这些都是应用程序链接到的动态库。静态链接器在链接应用程序时记录每个依赖库的文件名。此文件名称为动态库的安装名称(install name)。动态加载器使用应用程序依赖库的安装名(install name)在文件系统中定位它们。如果动态加载器在启动时没有找到应用程序的所有依赖库，或者如果任何库与应用程序不兼容，启动过程将中止。动态库开发人员可以在使用gcc -install name选项编译库时为库设置不同的安装名称。有关依赖库兼容性的更多信息，请参见《Managing Client Compatibility With Dependent Libraries》。有关详细信息，请参阅gcc手册页。

动态加载器只解析应用程序在启动过程中实际使用的未定义的外部符号。其他的符号在应用程序使用之前都没有解决。当应用程序启动时，动态加载器的详细过程可以参考 [Executing Mach-O Files](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/executing_files.html#//apple_ref/doc/uid/TP40001829)

除了在启动时自动加载动态库之外，动态加载器还会在运行时根据应用程序的请求加载动态库。也就是说，如果应用在启动时不需要加载动态库，开发人员可以选择不将应用的对象文件与动态库链接，而是只在需要的部分加载动态库。以这种方式使用动态库可以加快启动过程。在运行时加载的动态库称为动态加载库。为了在运行时加载库，应用程序可以使用与其所运行系统的动态加载器交互的函数。

> 注意:客户端和动态库的目标架构必须相同。否则，动态加载器不会加载库。


不同的平台以不同的方式实现它们的动态加载器。它们还可能具有定制的动态代码加载接口，这使得代码难以跨平台移植。例如，为了方便将应用程序从UNIX移植到Linux, Jorge Acereda和Peter O’gorman开发了动态加载器兼容(DLC)函数。它们为开发者提供了一种标准的、可移植的方式来在他们的应用程序中使用动态库。

DLC函数在/usr/include/dlfcn.h中声明。 其中有五个: 

* **dlopen**(3) OS X Developer Tools Manual Page: 
 - 打开一个动态库。应用程序在使用任何库导出的符号之前调用这个函数。如果当前进程还没有打开动态库，那么这个库就会被加载到进程的地址空间中。这个函数返回一个句柄，这个句柄在dlsym和dlclose调用中用来引用打开的库。这个句柄称为动态库句柄。这个函数维护一个引用计数，它指示当前进程使用dlopen打开特定动态库的次数。

* **dlsym**(3) OS X Developer Tools Manual Page: 
 - 返回动态加载库导出的符号的地址。应用程序在通过调用dlopen获得库句柄后调用这个函数。dlsym函数以dlopen返回的句柄或指定符号搜索范围和符号名称的常量作为参数。

* **dladdr**(3) OS X Developer Tools Manual Page:
 - 返回所提供地址的信息。如果这个地址对应于应用程序地址空间中动态加载的库，这个函数将返回关于这个地址的信息。该信息以Dl info结构返回，该结构封装了动态库的路径名、库的基址以及与提供的地址最近的符号的地址和值。如果在提供的地址中没有找到动态库，那么该函数将不返回任何信息。

*** dlclose(3) OS X Developer Tools Manual Page: 
** - 关闭动态加载的库。这个函数接受dlopen返回的句柄作为参数。当该句柄的引用计数达到0时，库将从当前进程的地址空间中卸载。


* **dlerror**(3) OS X Developer Tools Manual Page:
 - 返回一个字符串，该字符串描述最后一次调用dlopen、dlsym或dlclose时遇到的错误条件。

有关DLC函数的更多信息，请参见《OS X ABI Dynamic Loader Reference.》。

## 动态库设计指南
动态库除了对常用功能进行分组外，还有助于减少应用程序的启动时间。然而，如果设计不当，动态库可能会降低其客户端的性能。(A dynamic library client is an app or a library that either is linked with the library or loads the library at runtime. 。本文档还使用image来指代动态库客户端。)因此，在创建动态库之前，必须定义它的用途和预期用途。为库的功能设计一个小而有效的接口对促进其他库或应用程序采用它有很长的路要走。

本章节讨论了动态库开发人员在设计和实现动态库时面临的主要问题。本文的重点是向您展示如何以一种方式设计库，使其能够通过版本来促进改进，并使库用户能够轻松地正确地与库交互。

### 设计一个最佳的库

动态库包含可以被用户计算机中的多个应用程序共享的代码。因此，它们应该包含一些应用程序可以使用的代码。它们不应该包含特定于一个应用程序的代码。这些是最优动态库的特性：

- 目标明确: 
 - 动态库应该专注于少数的、高度相关的目标。高度专注的库比多功能库更容易实现和使用。

- 易于使用: 
 - 库的接口，即库的客户端用来与之交互的符号，应该少且容易理解。一个简单的接口可以让库的用户更快地理解它的功能，而不是理解一个大型的接口。

- 易于维护:
 - 库的开发人员必须能够对库进行更改，以提高其性能并添加特性。库的私有接口和公共接口的明确分离，使库开发人员可以自由地对库的内部工作进行深入的改变，而对客户端的影响最小。如果设计得当，使用库的早期版本创建的客户端可以不加修改地使用库的最新版本，并从其提供的改进中获益。


### 管理客户端与依赖库的兼容性

动态库的客户端可以以两种方式使用该库：

- 作为依赖库
- 作为运行时加载的库

从客户端的角度来看，依赖库是客户端所链接的动态库。依赖库被加载到客户端正在加载的同一进程中，作为其加载进程的一部分。例如，当一个应用程序启动时，它的依赖库在主函数执行之前，作为启动过程的一部分加载。当动态库加载到正在运行的进程中时，在将控制传递给打开该库的例程（routine）之前，将其相关库加载到该进程中。

#### 定义客户端兼容性

当现有客户所依赖的库被修改时，对它的更改可能会影响客户使用新版本库的能力。客户端可以使用与其链接的依赖库的早期或晚期版本的程度称为客户端兼容性( client compatibility)。

有些变化很小;其中包括添加客户端未知的符号。其他变化也很大：这些改变包括删除一个符号，改变符号的大小或可见性，以及改变函数的语义。一个库向客户端公开的所有符号组成了库的ABI (app binary interface)。库的API只包含库为其客户端提供的函数。对于使用较早版本的库开发的客户端来说，库的ABI保持一致的程度决定了库的稳定性。确保库的ABI保持稳定，可以确保客户端可以使用更新版本的库。也就是说，依赖于定期更新的库的应用程序的用户可以在更新库(想想OS X软件更新机制)时看到他们的应用程序的性能改善，而不需要获得应用程序的新版本。

图1说明了Draw动态库及其一个客户端的生命周期。

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp5hfrjh81j30j50cc0uf.jpg)

这个列表描述了库和客户端的版本:

- Draw 1.0是这个库的初始版本。它输出了两个函数，`draw_line`和`draw_square`。
- Client 1.0链接了Draw 1.0。因此，它可以使用库导出的两个符号。
- Draw 1.1有更快的`draw_line`和`draw_square`版本，但是它们的语义没有改变，保持了客户端兼容性。这是一个兼容的小版本，因为客户端1.0可以使用Draw 1.1。
- Draw 1.2介绍了`draw_polygon`的功能。新版本的API是以前版本API的超集。1.2版本的Draw 1.1 API子集没有改变。因此，Client 1.0可以使用Draw 1.2。然而，Client 1.0不知道draw_polygon的存在，因此，它没有使用它。这是一个小的版本，因为API Client 1.0知道的在Draw 1.2中没有改变。但这也是一个不兼容的版本，因为API发生了变化。与该库的此版本(1.2)链接的Client不能使用较早的版本(如1.0)。
- Client 1.1链接了Draw 1.2，并使用draw_polygon。Client 1.1不能使用该库的早期版本，因为它使用了`draw_polygon`函数，这些版本没有导出该函数。但是，如果库的开发人员将weak_import属性添加到符号定义中，Client 1.1将能够使用该库的早期版本，方法是在使用它之前确保`draw_polygon`存在于其名称空间中。如果符号没有定义，客户端可以使用其他方法来执行所需的任务，或者不执行该任务。有关详细信息，请参阅《Symbol Exporting Strategies》。
- Draw没有导出`draw_square`。这是一个重要的版本，因为在库的前一个版本中导出的符号在这个版本中不导出。与该库的此版本链接的客户端不能使用较早的版本。

客户端应该能够使用他们所链接的库的所有小版本，而不需要重新链接。一般来说，要使用库的主要版本版本，客户端必须链接到新版本。客户端也可能需要更改以利用新的符号，以适应其对已修改的符号的使用，或者不使用新版本未导出的符号。

> 注意:库的头文件应该只包含库客户端实际应该使用的符号。如果客户端使用的符号不是您指定的符号，它们将限制其产品与您的库的新版本或早期版本的兼容性。

#### 指定版本信息


动态库的文件名通常包含带有**lib**前缀和**.dylib**扩展名。例如，一个名为Dynamo的库的文件名为`libDynamo.dylib`。但是，如果一个库在发布后可能会经历一个或多个版本，那么它的文件名必须包含该版本的主版本号。链接了文件名包含了版本的主版本号的客户端，永远不会使用一个新的该库的主版本，因为主版本是在不同的文件名下发布的。这种版本控制模型防止客户端使用API与客户端已知API不兼容的库版本。

当你发布一个动态库以获得未来的修订版时，你必须在它的文件名中披露库的主版本号。例如，在定义客户端兼容性时引入的Draw库第一个版本的文件名可以是`libDraw.A.dylib`。字母A表示首次发布的主版本号。主版本可以使用任何命名法。例如，绘制库也可以命名为`libDraw.1.dylib`或`libDraw.I.dylib`。重要的是，库的后续主要修订的文件名具有不同的(最好是增量的)主要版本号。继续Draw库的例子，对库的主要修订可以命名为libDraw.B.dylib libDraw.2.dylib或libDraw.II.dylib。库的小修订版以与前一个大修订版相同的文件名发布。


除了主版本号之外，库还有次要版本号。次要版本号是使用这种格式的增量号: **X[.Y[.Z]]**，其中X为0 ~ 65535之间的数字，Y和Z为0 ~ 255之间的数字。例如，Draw库第一次发布的次要版本号可以是1.0。要设置动态库的次要版本号，使用clang -current version <version number>选项。

兼容版本号与次要版本号相似;它是通过编译器`-compatibility_version`命令行选项设置的。一个库发行版的兼容性版本号指定了与该发行版相链接的客户端可以使用的最早的小版本。比如，定义客户端兼容性的例子表明，Client 1.1不能使用1.2之前的Draw库版本，因为它们不导出draw_polygon函数。要查看库的当前版本和兼容性版本，使用`otool -L <library>`命令。

在加载动态库之前，动态加载器会将用户文件系统中的.dylib文件的当前版本与客户端在开发人员文件系统中链接的.dylib文件的兼容版本进行比较。如果当前版本比兼容版本早(少)，则不加载依赖库。因此，启动进程(针对客户端应用程序)或加载进程(针对客户端库)将被中止。

> 注意:动态加载器只对依赖库执行版本兼容性测试。使用**dlopen**在运行时打开的动态库不会通过这个测试。


### 指定库的接口

在实现动态库之前要定义的最重要的方面是它与客户端的接口。公共接口影响客户端对库的使用、库的开发和维护以及使用库的应用程序的性能等几个方面:

- 易用：带有一些容易理解的公共符号的库要比导出它定义的所有符号的库容易得多。
- 易维护： 拥有一小组公共符号和一组足够的私有符号的库维护起来要容易得多，因为需要测试的客户端入口点很少。此外，开发人员可以更改私有符号，以在较新的版本中改进库，而不会影响与较早版本链接的客户端的功能。
- 性能：设计动态库以使其导出最小数量的符号，可优化动态加载器将库加载到进程中所花费的时间。库中导出的符号越少，动态加载器加载它的速度就越快。

下面几节将展示如何确定导出哪些库符号、如何命名它们以及如何导出它们。

#### 决定输出什么符号

减少库导出的符号集使库易于使用和维护。通过简化符号集，库的用户只会看到与他们相关的符号。使用很少的公共符号，您可以自由地对内部接口进行实质性的更改，例如添加或删除不影响库客户端的内部符号。

不应该导出全局变量。对库的全局变量提供不受控制的访问，会使库容易因客户端给这些变量赋值不当而引起问题。在库的一个版本到另一个版本之间更改全局变量，而不做出与未链接它们的客户端不兼容的新版本，也是很困难的。动态库的主要特性之一是，如果正确实现，客户端可以使用它们的新版本，而无需重新链接。如果客户端需要访问存储在全局变量中的值，那么库应该**导出访问器函数，而不是全局变量本身**。遵循这一准则，库开发人员可以在库的不同版本之间更改全局变量的定义，而不会引入不兼容的修订版本。

如果您的库需要由它导出的函数实现的功能，您应该考虑实现函数的内部版本，向它们添加包装函数，并导出包装器。例如，您的库可能有一个必须验证其参数的函数，但您确定在调用该函数时库总是提供有效值。函数的内部版本可以通过删除验证代码来进行优化，使内部使用更有效。然后可以将验证代码放在包装器函数中，为客户端维护验证过程。此外，您可以进一步更改函数的内部实现，以包含更多的参数，同时保持外部版本相同。

让包装函数调用内部版本会降低应用程序的性能，特别是当该函数被客户端反复调用时。然而，灵活的维护和客户端稳定的接口的优点远远超过了这种微不足道的性能影响。


#### 命名导出的符号

动态加载器不会检测它所加载的动态库导出的符号之间的命名冲突。当一个客户端包含对一个符号的引用，该符号被两个或多个依赖库导出时，动态加载器将该引用绑定到客户端依赖库列表中导出该符号的**第一个**依赖库。依赖库列表是客户端依赖库的列表，顺序是在客户端与它们链接时指定的顺序。同样，当`dlsym`函数被调用时，动态加载器返回它在指定范围(全局、本地或next)中找到的第一个符号的地址，该符号具有匹配的名称。有关符号搜索范围的详细信息，请参见《Using Symbols》

为了确保库的客户端总是能够访问库导出的符号，这些符号在进程的命名空间中必须具有唯一的名称。一种方法是应用程序使用两级名称空间。另一种方法是为每个导出的符号添加前缀。这是大多数OS X框架使用的约定，比如Carbon和Cocoa。有关两级命名空间的更多信息，see Executing Mach-O Files in Mach-O Programming Topics.

#### 符号导出策略

在确定了希望向库用户公开的符号之后，必须设计出导出这些符号或不导出其余符号的策略。这个过程也被称为设置符号的可见性，也就是说，它们是否可以被客户端访问。客户端可以访问公共或导出的符号;客户端无法访问私有、隐藏或未导出的符号。在OS X中，有几种方法可以指定库符号的可见性：

- `static`存储类:这是表示不想导出符号的最简单方法。
- 导出的符号列表或未导出的符号列表: 该列表是一个文件，包含要导出的符号名称或要保持私有的符号列表。符号名称必须包含下划线 (_) 前缀。在生成动态库文件时，只能使用一种类型的列表。
- `visibility`属性:将此属性放置在实现文件中的符号定义中，以单独设置符号的可见性。它可以让你更细致地控制哪些符号是公共的，哪些是私有的。
- 编译器的`-fvisibility`命令行选项:该选项指定编译时实现文件中未指定可见性的符号的可见性。该选项结合可见性属性，是识别公共符号最安全、最方便的方式。
- `weak_import`属性:把这个属性放在头文件中的符号声明中，告诉编译器生成一个对该符号的弱引用。这种特性被称为弱链接;带有弱导入属性的符号称为弱链接符号。使用弱链接，当在启动时或加载时找到的依赖库版本没有导出客户端引用的弱链接符号时，客户端不会启动失败。在库的客户端源文件使用的头文件中放置`weak_import`属性是很重要的，这样客户端开发人员就知道他们在使用该符号之前必须确保该符号的存在。否则，客户端在尝试使用该符号时将崩溃或功能不正确。有关弱链接符号的详细信息，请参阅《Using Weakly Linked Symbols 》。有关符号定义的更多信息，see [Executing Mach-O Files ]()in [Mach-O Programming Topics]()。
- 编译器 -`weak_library`命令行选项:这个选项告诉编译器将所有库导出的符号视为弱链接符号。

清单1 一个简单的动态库

```c++
* File: Person.h */
char* name(void);
void set_name(char* name);
 
/* File: Person.c */
#include "Person.h"
#include <string.h>
char _person_name[30] = {'\0'};
char* name(void) {
    return _person_name;
}
 
void _set_name(char* name) {
   strcpy(_person_name, name);
}
 
void set_name(char* name) {
    if (name == NULL) {
        _set_name("");
    }
    else {
        _set_name(name);
    }
}
```

库开发人员的目的是为客户端提供使用`set_name`函数设置`_person_name`值的能力，并让客户端使用`name`函数获取变量的值。但是，库导出的不仅仅是`name`和`set name`函数，如**nm**命令行工具的输出所示:

```c++
% clang -dynamiclib Person.c -o libPerson.dylib
% nm -gm libPerson.dylib
                 (undefined) external ___strcpy_chk (from libSystem)
0000000000001020 (__DATA,__common) external __person_name     // Inadvertently exported
0000000000000e80 (__TEXT,__text) external __set_name          // Inadvertently exported
0000000000000e70 (__TEXT,__text) external _name
0000000000000ec0 (__TEXT,__text) external _set_name
                 (undefined) external dyld_stub_binder (from libSystem)
```

注意，_person_name全局变量和_set_name函数与name和set_name函数一起导出。有许多选项可以从库导出的符号中删除_person_name和_set_name。本节将探讨一些。

第一个选项是将静态存储类添加到在Person .c中的_person_name和 _set_name的定义中，如清单2所示。

清单2 Person模块用静态存储类隐藏了一个符号

```c++
/* File: Person.c */
#include "Person.h"
#include <string.h>
 
static char _person_name[30] = {'\0'};        // Added 'static' storage class
char* name(void) {
    return _person_name;
}
 
static void _set_name(char* name) {           // Added 'static' storage class
   strcpy(_person_name, name);
}
 
void set_name(char* name) {
    if (name == NULL) {
        _set_name("");
    }
    else {
        _set_name(name);
    }
}
```

现在，nm输出，像这样:

```c++
                 (undefined) external ___strcpy_chk (from libSystem)
0000000000000e80 (__TEXT,__text) external _name
0000000000000e90 (__TEXT,__text) external _set_name
                 (undefined) external dyld_stub_binder (from libSystem)
```

这意味着库只导出name和set name。实际上，标准库还导出了一些未定义的符号，包括strcpy。它们是对库从其相关库中获得的符号的引用。

> 注意:您应该始终使用静态存储类来存储您希望为特定文件保留私有的符号。这是一种非常有效的自动防故障措施，防止无意中暴露本应对客户端隐藏的符号。

这种方法的问题是，它对库中的其他模块隐藏了内部_set_name函数。如果库的开发人员相信任何对_set_name的内部调用不需要验证，但想要验证所有的客户端调用，则该符号必须对库中的其他模块可见，但对库的客户端不可见。因此，静态存储类不适合对客户端隐藏符号，而是向所有库模块公开它们。

仅公开用于客户端使用的符号的第二种选择是拥有一个导出符号文件，该文件列出了要导出的符号;所有其他的符号都被隐藏起来了。清单3显示了**export_list**文件。

清单3文件列出了要导出的符号的名称

```c++
# File: export_list
_name
_set_name
```

要编译这个库，可以使用`clang -exported_symbols_list`选项来指定包含要导出的符号名称的文件，如下所示

```c++
clang -dynamiclib Person.c -exported_symbols_list export_list -o libPerson.dylib
```
仅公开name和set_name的第三个也是最方便的选项是，在编译库的源文件时，将实现中的visibility属性设置为“default”，并将-fvisibility 编译器命令行选项设置为hidden。清单4显示了为要导出的符号设置visibility属性后的Person.c文件的样子。

清单4使用visibility属性导出符号的Person模块

```c++
/* File: Person.c */
#include "Person.h"
#include <string.h>
 
// Symbolic name for visibility("default") attribute.
#define EXPORT __attribute__((visibility("default")))
 
char _person_name[30] = {'\0'};
 
EXPORT                        // Symbol to export
char* name(void) {
    return _person_name;
}
 
void _set_name(char* name) {
   strcpy(_person_name, name);
}
 
EXPORT                        // Symbol to export
void set_name(char* name) {
    if (name == NULL) {
        _set_name("");
    }
    else {
        _set_name(name);
    }
}
```
然后使用以下命令编译库:

```c++
 % clang -dynamiclib Person.c -fvisibility=hidden -o libPerson.dylib
```

fvisibility=hidden命令行选项告诉编译器将任何没有可见性属性的符号的可见性设置为hidden，从而对库的客户端隐藏它们。

遵循这些符号导出指导原则可以确保库只导出您想让客户端可用的符号，从而简化了客户端对库的使用，并便利了开发人员对库的维护。

### 查找外部资源

当您需要定位库或程序在运行时需要的资源(如框架、\_等)时，您可以使用下列方法之一:

- Executable-relative location： 要指定相对于主可执行文件位置的文件路径，而不是相对于引用库的文件路径，请将**@executable_path**宏放在路径的开头。例如，在包含私有框架（又包含共享库）的应用程序包中，任何一个库都可以通过指定路径@executable_path/../Resources/MyImage.tiff在包内找到名为MyImage.tiff的应用程序资源。因为@executable路径解析为app bundle中的MacOS目录中的二进制文件，所以资源文件路径必须将Resources目录指定为MacOS父目录(Contents目录)的子目录。有关目录绑定包的详细讨论，请参见《Bundle Programming Guide》。
- Library-relative location： 要指定相对于库本身位置的文件路径，请将**@loader_path**宏放在路径名的开头。库相对位置允许您在目录层次结构中定位库资源，而不管主可执行文件位于何处。



###  库依赖

在开发动态库时，可以通过链接源代码来指定其依赖库。当库的客户端试图加载库时，与库相关的库必须存在于文件系统中，才能成功加载库。（请参阅运行路径依赖库，了解如何在可重定位目录中安装依赖库。）根据客户端加载库的方式，部分或全部库对其相关库导出的符号的引用将被解析。你应该考虑使用dlsym(3) OS X开发人员工具手册页面函数来获得需要的符号的地址，而不是总是需要在加载时解析的引用。

库的依赖性越强，加载库所需的时间就越长。因此，您应该只将库与加载时所需的动态库链接。编译库之后，可以使用otool -L命令在shell编辑器中查看它的相关库。

您的库很少使用的任何动态库，或者只有在执行特定任务时才需要其功能的动态库，都应该作为运行时加载库使用；也就是说，使用dlopen(3) OS X Developer Tools Manual页面功能打开。例如,当一个模块在你的库需要执行一项任务,需要使用非依赖的库, 模块应该使用dlopen加载库,使用这个库来执行其任务,并在完成后使用dlclose (3) OS X开发工具手册页面关闭库。

您还应该将依赖库中对符号的外部引用数量保持在最低限度。这种做法进一步优化了库的加载时间。

你必须向你的库用户披露你的库所使用的所有库，以及它们是否是从属的库。当动态库的用户链接他们的image时，静态链接器必须能够找到所有与库相关的库，无论是通过链接行还是符号链接。另外，因为即使在运行时打开的一些或所有库在加载时不存在，动态库也能成功加载，所以库的用户必须知道库在运行时打开了哪些动态库，以及在哪些情况下打开了哪些动态库。库的用户可以在调查库的意外行为时使用这些信息。

### 模块初始化器和终结器

加载动态库时，它们可能需要在执行任何其他操作之前准备资源或执行特殊的初始化。相反，当库被卸载时，它们可能需要执行一些结束过程。这些任务由初始化器函数和终结器函数(也称为构造函数和析构函数)执行。

> 注意:应用程序也可以定义和使用初始化器和终结器。然而，本节主要关注它们在动态库中的使用。

初始化器可以安全地使用依赖库中的符号，因为动态加载器在调用image的静态初始化器之前会执行image依赖库的静态初始化器。

通过向函数定义中添加构造函数属性，可以指明函数是初始化器。析构函数属性标识终结器函数。不能导出初始化器和终结器。动态库的初始化式按编译器遇到它们的顺序执行。另一方面，它的终结器按照编译器遇到的相反顺序执行。

例如，清单5显示了一组初始化器和终结器，它们在名为Inifi的动态库中的两个文件File1.c和File2.c中相同地定义。

清单5 Inifi初始化器和终结器定义

```c++
/* Files: File1.c, File2.c */
#include <stdio.h>
__attribute__((constructor))
static void initializer1() {
    printf("[%s] [%s]\n", __FILE__, __FUNCTION__);
}
 
__attribute__((constructor))
static void initializer2() {
    printf("[%s] [%s]\n", __FILE__, __FUNCTION__);
}
 
__attribute__((constructor))
static void initializer3() {
    printf("[%s] [%s]\n", __FILE__, __FUNCTION__);
}
 
__attribute__((destructor))
static void finalizer1() {
    printf("[%s] [%s]\n", __FILE__, __FUNCTION__);
}
 
__attribute__((destructor))
static void finalizer2() {
    printf("[%s] [%s]\n", __FILE__, __FUNCTION__);
}
 
__attribute__((destructor))
static void finalizer3() {
    printf("[%s] [%s]\n", __FILE__, __FUNCTION__);
}
```

继续这个例子，Inifi动态库是Trial程序的唯一依赖库，它由Trial.c文件生成，如清单6所示。

清单6 Trial.c文件

```c++
/* Trial.c */
#include <stdio.h>
int main(int argc, char** argv) {
    printf("[%s] [%s] Finished loading. Now quitting.\n", __FILE__, __FUNCTION__);
    return 0;
}
```

清单7显示了Trial 程序生成的输出。

```c++
% clang -dynamiclib File1.c File2.c -fvisibility=hidden -o libInifi.dylib
% clang Trial.c libInifi.dylib -o trial
% ./trial
[File1.c] [initializer1]
[File1.c] [initializer2]
[File1.c] [initializer3]
[File2.c] [initializer1]
[File2.c] [initializer2]
[File2.c] [initializer3]
[Trial.c] [main] Finished loading. Now quitting.
[File2.c] [finalizer3]
[File2.c] [finalizer2]
[File2.c] [finalizer1]
[File1.c] [finalizer3]
[File1.c] [finalizer2]
[File1.c] [finalizer1]
```

尽管在一个\_中可以有任意多个静态初始化器和终结器，但应该根据需要将初始化和终结器代码合并到每个模块一个初始化器和一个终结器中。您还可以选择为每个库设置一个初始化器和一个终结器。

在OS X v10.4及更高版本中，静态初始化器可以访问给定给当前程序的实参。通过定义初始化器的形参，就像定义程序的主函数的形参一样，可以得到给定参数的数量、参数本身以及进程的环境变量。此外，为了防止初始化器或终结器被调用两次，应该在函数内部对初始化和终结代码进行条件化。清单8显示了一个静态初始化器的定义，该初始化器可以访问程序的参数并对其初始化代码进行条件化。

清单8静态初始化器的定义

```c++
__attribute__((constructor))
static void initializer(int argc, char** argv, char** envp) {
    static initialized = 0;
    if (!initialized) {
        // Initialization code.
        initialized = 1;
    }
}
```

> 注意:一些操作系统支持初始化器和终结器init和fini的命名约定。这个约定在OS X中不受支持。

### C++依赖库

使用c++来实现一个动态库会带来一些挑战，主要是导出符号名以及创建和销毁对象。下面几节详细介绍了如何从基于c++的动态库导出符号，以及如何为客户端提供创建和销毁类实例的函数。

#### 导出c++符号

#### 定义c++类接口

#### 创建和销毁c++对象

### 基于objective-c的库

在设计或更新基于Objective-C的动态库时，有几个问题需要考虑

- 发布一个Objective-C类或类别的公共接口与在C中导出符号的方式不同。在Objective-C中，每个类的每个方法在运行时都是可用的。
	- 客户端可以内省类以找出可用的方法。然而，为了使客户端开发人员不会收到关于缺少方法实现的一连串警告，库开发人员应该将类和类别的接口作为协议发布给客户端开发人员。
- 基于Objective-C的库比基于c的库可以访问更多的初始化工具
- Objective-C有一个类别名工具，它允许库开发人员在修订中重命名类，但允许客户端与该修订链接，以继续使用早期修订中使用的名称。

下面几节将详细探讨这些领域。

#### 定义类和接口类

因为客户端开发人员通常不能访问动态库中定义的Objective-C类和类别的实现，所以库开发人员必须在头文件中作为协议发布类和类别的公共接口。客户端开发人员使用这些头文件来编译他们的产品，并且能够通过向变量定义中添加必要的协议名来正确地实例化类。清单12显示了基于Objective-C的库中的Person类的头文件和实现文件。清单13显示了同一个库中Titling类别的头文件和实现文件，它向Person类添加了-setTitle方法。

清单12 Person类的头文件和实现文件

```objc
/* File: Person.h */
#import <Foundation/Foundation.h>
 
@protocol Person
- (void)setName:(NSString*)name;
- (NSString*)name;
@end
 
@interface Person : NSObject <Person> {
    @private
    NSString* _person_name;
}
@end
 
/* File: Person.m */
#import <Foundation/Foundation.h>
#import "Person.h"
 
@implementation Person
- (id)init {
    if (self = [super init]) {
        _person_name = @"";
    }
    return self;
}
 
- (void)setName:(NSString*)name {
    _person_name = name;
}
 
- (NSString*)name {
    return _person_name;
}
@end

```

清单13 Person类的标题类别的头文件和实现文件

```objc
/* File: Titling.h */
#import <Foundation/Foundation.h>
#import "Person.h"
 
@protocol Titling
- (void)setTitle:(NSString*)title;
@end
 
@interface Person (Titling) <Titling>
@end
 
/* File: Titling.m */
#import <Foundation/Foundation.h>
#import "Titling.h"
 
@implementation Person (Titling)
- (void)setTitle:(NSString*)title {
    [self setName:[[title stringByAppendingString:@" "]
        stringByAppendingString:[self name]]];
}
@end
```

清单14显示了客户端如何使用这个库。

```objc
/* File: Client.m */
#import <Foundation/Foundation.h>
#import <objc/runtime.h>
#import <dlfcn.h>
#import "Person.h"
#import "Titling.h"
 
int main() {
    @autoreleasepool {
        // Open the library.
        void* lib_handle = dlopen("./libPerson.dylib", RTLD_LOCAL);
        if (!lib_handle) {
            NSLog(@"[%s] main: Unable to open library: %s\n",
            __FILE__, dlerror());
            exit(EXIT_FAILURE);
        }
 
        // Get the Person class (required with runtime-loaded libraries).
        Class Person_class = objc_getClass("Person");
        if (!Person_class) {
            NSLog(@"[%s] main: Unable to get Person class", __FILE__);
            exit(EXIT_FAILURE);
        }
 
        // Create an instance of Person.
        NSLog(@"[%s] main: Instantiating Person_class", __FILE__);
        NSObject<Person,Titling>* person = [Person_class new];
 
        // Use person.
        [person setName:@"Perrine LeVan"];
        [person setTitle:@"Ms."];
        NSLog(@"[%s] main: [person name] = %@", __FILE__, [person name]);
 
        // Close the library.
        if (dlclose(lib_handle) != 0) {
            NSLog(@"[%s] Unable to close library: %s\n",
                __FILE__, dlerror());
            exit(EXIT_FAILURE);
        }
 
    }
    return(EXIT_SUCCESS);
}
```

下面的命令编译库和客户端程序:

```
clang -framework Foundation -dynamiclib Person.m Titling.m -o libPerson.dylib
clang -framework Foundation Client.m -o client

```

#### 初始化objective-c类

基于Objective-C的动态库为模块、类和类别提供了一些初始化工具。下面的列表按照执行的顺序描述了这些设施。

- +load方法:
 - 初始化类或类别所需的资源。Objective-C运行时向库实现的每个类发送load消息;然后，它向库实现的每个类别发送load消息。尚未确定发送load消息的兄弟类的顺序。实现+load方法来初始化类或类别所需的资源。注意，没有相应的"unload"方法。
 
- 模块初始化器:
 - 初始化模块。动态加载器调用每个库模块中的所有初始化器函数(用constructor属性定义)。有关模块初始化器的更多信息，请参阅模块初始化器和结束器。

- +initialize方法:
 - 在创建任何实例之前初始化类实例所需的资源。Objective-C运行时在创建一个类的实例之前将初始化消息发送给一个类。请注意，在卸载库或进程终止时，没有向类发送相应的finalize消息。

#### 为类创建别名

当您在动态库的修订中重命名类时，您可以通过在库的头文件中为新名称添加别名来减少客户端开发人员的采用负担。这种做法允许客户端开发人员发布能够快速利用新版本库的客户端。客户端开发人员可以稍后在空闲时更新对该类的引用。

### 设计指南清单

此列表提供了改进动态库特定方面的指导方针的摘要

- 易用
 - 减少库导出的符号数量。
 - 为公共接口提供唯一的名称。
 
- 易维护
 - 导出变量的访问函数。不要导出变量。
 - 将公共接口作为内部私有接口的包装器来实现。

- 性能
 - 尽量减少对相关库中符号的引用数量。使用dlsym(RTLD GLOBAL， <symbol name>)来获取依赖库导出的符号的地址。
 - 最小化依赖库的数量。如果绝对必要，可以考虑使用dlopen加载库。记住在完成时用dlclose关闭库。
 - 将公共接口作为内部私有接口的包装器实现。

- 兼容性
 - 将符号导出为弱链接符号。
 - 在文件名中将库的主要版本号编码。

## 动态库使用指南

动态加载器兼容函数提供了一种在运行时加载代码的可移植和有效的方法。但是，不正确地使用这些功能会降低应用程序的性能。本文将展示如何在应用程序中正确加载和使用动态库。

动态库有助于将应用程序的功能分配到不同的模块中，这些模块可以在需要时加载。动态库可以在应用启动或运行时加载。在启动时加载的库称为依赖库(dependent libraries)。在运行时加载的库称为动态加载库(dynamically loaded libraries.)。你可以指定你的应用程序依赖哪些动态库，并且链接他们。然而，使用动态加载库比使用依赖库更有效。也就是说，你应该在要使用库导出的符号时打开库，完成后关闭库。在某些情况下，当系统确定动态加载的库没有被使用时，就会卸载它们。
本文使用image这个词来指代应用程序文件或动态库。应用程序二进制文件包含应用程序代码和应用程序使用的静态库中的代码。应用程序在启动时或运行时加载的动态库是独立的image。

### 打开动态库

当image被打开时，动态加载器加载一个image的依赖库;也就是说，当一个应用程序被加载或者一个动态库被打开时。动态加载器将引用延迟绑定到依赖库导出的符号。惰性绑定意味着只有当image实际使用符号时才绑定符号引用。作为一种调试措施，您可以指定在动态加载器打开库时绑定对库导出符号的所有引用。在生成动态库时，可以使用编译器的-bind_at_load命令行选项。

要使用动态库，而不是你的image的依赖库，请使用dlopen(3) OS X开发人员工具手册页面函数。这个函数告诉动态加载器将特定的动态库加载到当前进程的地址空间中。这个函数还允许您指定动态加载器何时将库引用绑定到其依赖库中相应的导出符号，以及是否将库导出的符号放置在当前进程的全局作用域中还是局部作用域中。这个函数返回一个称为库句柄的句柄。这个句柄表示在调用dlsym(使用导出的符号)和dlclose(关闭库)时动态加载的库。库句柄为dlsym提供了一个有限的域，可以在其中搜索符号(详细信息请参阅使用符号)。客户端在使用动态加载的库完成时必须调用dlclose(例如，打开库的模块完成了它的任务)。

动态库本身可能有依赖库。使用otool -L <library>命令查找动态库所依赖的库。在使用该库之前，必须确保计算机中存在它的所有相关库。否则，在启动时或使用dlopen打开库时，动态加载器不会加载你的应用程序或库。

进程可以多次打开同一个动态库而不关闭它。dlopen函数返回它在第一次调用中返回的库句柄，但是它还增加与该句柄相关联的引用计数。调用dlclose递减库句柄的引用计数。因此，您必须在每次对dlopen的调用和一次对dlclose的调用之间进行平衡。当库句柄的引用计数达到0时，动态加载器可以从应用程序的地址空间中删除库。


#### 库搜索的过程

dlopen(3) OS X开发人员工具手册的第一个参数是要打开的动态库的名称。这可以是文件名，也可以是部分或完全限定的路径名​​。 例如，libCelsus.dylib，lib/libCelsus.dylib或/usr/local/libCelsus.dylib。

动态加载器在一组环境变量和进程当前工作目录指定的目录中搜索库。定义这些变量时，必须包含一个以冒号分隔的路径名列表(绝对的或相对的)，动态加载器在其中搜索库。表1列出了变量。

表1定义动态加载器搜索路径的环境变量

Environment variable    | Default value           |
--------------------|------------------|
LD_LIBRARY\_PATH |   No default value | 
DYLD\_LIBRARY\_PATH | No default value | 
DYLD\_FALLBACK\_LIBRARY\_PATH | $HOME/lib; /usr/local/lib; /usr/lib |

当库名是一个文件名时(也就是说，当它不包含目录名时)，动态加载器在几个位置搜索库，直到找到它，顺序如下

- $LD\_LIBRARY\_PATH
- $DYLD\_LIBRARY\_PATH
- 进程的工作目录
- $DYLD\_FALLBACK\_LIBRARY\_PATH

当库名包含至少一个目录名时，即当名称是路径名(相对的或完全限定的)时，动态加载器将按照以下顺序搜索库:

- $DYLD\_LIBRARY\_PATH 使用文件名
- 给定路径名
- $DYLD\_FALLBACK\_LIBRARY\_PATH 给定文件名

例如，假设您按照下表所示设置了前面介绍的环境变量。

Environment variable    | Default value           |
--------------------|------------------|
LD\_LIBRARY\_PATH |  ./lib | 
DYLD\_LIBRARY\_PATH | /usr/local/dylibs | 
DYLD\_FALLBACK\_LIBRARY\_PATH | /usr/local/lib |

假设你的应用程序以文件名libCelsus调用dlopen。动态加载器将尝试使用以下路径名依次打开库：

Pathname    | Description     |
--------------------|------------------|
./lib/libCelsus.dylib |  LD\_LIBRARY\_PATH  环境变量 | 
/usr/local/dylibs/libCelsus.dylib | DYLD\_LIBRARY\_PATH 环境变量 | 
libCelsus.dylib | 当前工作目录 |
/usr/local/lib/libCelsus.dylib | DYLD\_FALLBACK\_LIBRARY\_PATH 环境变量 | 


### 指定导出符号的范围和绑定行为
dlopen(3) OS X开发人员工具手册页面函数的第二个参数指定了两个属性:库导出的符号在当前进程中的作用域，以及何时绑定应用程序引用这些符号。

符号作用域直接影响应用程序的性能。因此，为应用程序在运行时打开的库设置适当的范围是很重要的。

动态加载的库导出的符号可以在当前进程的两个级别作用域中:**全局**和**本地**。作用域之间的主要区别是全局作用域中的符号对进程中的所有image都可用，包括其他动态加载的库。局部范围内的符号只能由打开该库的image使用。有关更多信息，请参见使用符号。

当动态加载器搜索符号时，它会对搜索范围内的每个符号执行字符串比较。减少动态加载器查找所需符号的符号数量可以提高应用程序的性能。将所有动态加载的库打开到局部作用域中而不是全局作用域中，可以最大化符号搜索性能。

用于指定符号作用域的参数还用于指定动态加载的库中未定义的外部符号何时被解析(或与它们在库自身相关库中的定义绑定)。动态加载库中未定义的外部符号可以立即解析，也可以延迟解析。

清单1使用立即绑定在调用dlopen期间解析的绑定

```c
dyld: lazy bind: client:0x107575050 = libdyld.dylib:_dlopen, *0x107575050 = 0x7FFF88740922
dyld: bind: libPerson.dylib:0x1075A9000 = libdyld.dylib:dyld_stub_binder, *0x1075A9000 = 0x7FFF887406A0
dyld: bind: libPerson.dylib:0x1075A9220 = libobjc.A.dylib:__objc_empty_cache, *0x1075A9220 = 0x7FFF7890EC10
dyld: bind: libPerson.dylib:0x1075A9248 = libobjc.A.dylib:__objc_empty_cache, *0x1075A9248 = 0x7FFF7890EC10
dyld: bind: libPerson.dylib:0x1075A9228 = libobjc.A.dylib:__objc_empty_vtable, *0x1075A9228 = 0x7FFF7890CF60
dyld: bind: libPerson.dylib:0x1075A9250 = libobjc.A.dylib:__objc_empty_vtable, *0x1075A9250 = 0x7FFF7890CF60
dyld: bind: libPerson.dylib:0x1075A9218 = CoreFoundation:_OBJC_CLASS_$_NSObject, *0x1075A9218 = 0x7FFF77C40BA8
dyld: bind: libPerson.dylib:0x1075A9238 = CoreFoundation:_OBJC_METACLASS_$_NSObject, *0x1075A9238 = 0x7FFF77C40B80
dyld: bind: libPerson.dylib:0x1075A9240 = CoreFoundation:_OBJC_METACLASS_$_NSObject, *0x1075A9240 = 0x7FFF77C40B80
dyld: bind: libPerson.dylib:0x1075A9260 = CoreFoundation:___CFConstantStringClassReference, *0x1075A9260 = 0x7FFF77C72760
dyld: bind: libPerson.dylib:0x1075A9280 = CoreFoundation:___CFConstantStringClassReference, *0x1075A9280 = 0x7FFF77C72760
```

第一个日志消息表明客户端应用程序的dlopen未定义符号被绑定。其余的消息是动态加载器在将控制权返回给调用例程之前作为加载过程的一部分在动态库上执行的绑定。当使用延迟绑定时，动态加载器只解析客户端对dlopen函数的引用，从而更快地将控制权返回给调用例程。有关动态加载器日志记录的更多信息，请参见记录动态加载器事件。

一旦用dlopen打开了一个库，为它定义的作用域就不能通过后续调用dlopen来加载相同的库而改变了。例如，如果进程打开了一个尚未加载到局部作用域的库，然后在全局作用域中打开了相同的库，则打开的库将保持其本地状态。也就是说，库导出的符号在后一个调用中不会在全局作用域中可用。即使库在同一进程中重新打开之前已经关闭，也是如此。

> 重要提示:所有运行时加载的动态库都应该在本地范围内打开。遵循此规则可以使在运行时尽可能快地查找符号。

立即绑定会减慢动态库的加载速度，特别是当这些库包含许多未定义的外部符号时。然而，立即绑定可以在动态库的开发和测试过程中提供帮助，因为当动态加载器不能解析动态加载库中所有未定义的外部符号时，应用程序将以一个错误终止。然而，在部署应用程序时，你应该使用惰性加载，因为未定义的外部符号只在必要时绑定。以这种方式加载动态库可以让你的应用感觉对用户的响应更灵敏。

依赖库中的外部未定义符号在第一次使用时被绑定，除非客户端image的编译行包含了`-bind_at_load` 选项。详细信息请参见ld手册页。


### 使用符号

在使用dlopen(3) OS X开发人员工具手册页面打开动态库后，image在使用之前使用dlsym(3) OS X开发人员工具手册页面函数来获取所需符号的地址。第一个参数指定了动态加载器在哪些库中查找该符号。第二个参数指定符号的名称。例如

```c
symbol_pointer = dlsym(library_handle, "my_symbol")
```
这个调用告诉动态加载器在由`library_handle`变量表示的动态加载库导出的符号中搜索名为my_symbol的符号。

动态加载器可以搜索符号的三个作用域:特定的动态库、当前image的依赖库和进程的全局作用域:

- 本地范围:  要搜索使用dlopen加载的特定动态库导出的符号，需要向dlsym提供该库的句柄。这是最有效的使用模型。
- 次要范围: 只有当模块插入了依赖库导出的符号时，此搜索范围才有用。在这种情况下，在函数的自定义定义中，通过使用RTLD_NEXT特殊句柄(而不是特定库的句柄)调用dlsym，可以获得所插入的函数的地址。这样的调用将返回函数的地址，如果您没有用自己的实现掩盖该实现，则该函数将被执行。因此，只搜索当前image的相关库;不搜索任何其他库，包括image调用dlsym所打开的库。同样，在扁平的命名空间中，当应用程序被链接时，搜索从当前库之后列出的第一个依赖库开始。
- 全局范围: 要搜索全局范围，可以使用RTLD_DEFAULT特殊句柄调用dlsym。动态加载器在依赖库(在启动时加载)和动态加载库(在运行时使用RTLD_GLOBAL加载)中搜索给dlsym的符号名的第一个匹配项。

> 注意:动态共享库之间的名称冲突不会在编译时、链接时或运行时被发现。dlsym函数使用字符串匹配来查找符号。如果两个库对一个函数使用相同的名称，动态加载器将返回第一个与dlsym给定的符号名称匹配的库。

为了说明本节中介绍的概念，请使用图1中描述的应用程序。
它显示该应用程序有两个依赖库，libArt.dylib 和libBus.dylib。
libBus.dylib库本身有两个依赖库libBus1.dylib libBus2.dylib。
libBus1.dylib库有一个依赖的库libBus1a.dylib。
此外，还有四个应用程序不依赖的动态库:libCar.dylib libCar1.dylib libDot.dylib, libDot1.dylib。
libCar1.dylib库是libCar的一个依赖库。libDot1.dylib是libDot.dylib的一个依赖库。
所有的库，除了libArt，都导出依赖项函数。
每个库都有一个…name函数的唯一实现。

图1应用程序依赖库层次结构

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp9yxx922gj30fl0dhwfi.jpg)

应用程序image直接可以访问libArt.dylib 和 libBus.dylib中导出的符号。如清单2所示。

```c
#include <stdio.h>
extern char* A_name();          // libArt.dylib
extern char* dependencies();    // libBus.dylib
 
int main(void) {
    printf("[%s] libArt.A_name() = %s\n", __FILE__, A_name());
    printf("[%s] libBus.dependencies() = %s\n", __FILE__, dependencies());
}

```

然而，应用程序image不能直接访问 libBus1.dylib, libBus1a.dylib, and libBus2.dylib 所导出的符号。因为这些库不是依赖于应用image的库。
要访问这些符号，应用程序image必须使用dlopen打开相应的库，如清单3所示。


清单3应用程序image使用了一个在运行时加载的动态库导出的符号

```c
#include <stdio.h>
#include <dlfcn.h>
 
int main(void) {
    void* Bus1a_handle = dlopen("libBus1a.dylib", RTLD_LOCAL);
    if (Bus1a_handle) {
        char* (*b1a_name)() = dlsym(Bus1a_handle, "B1a_name");
        if (b1a_name) {
            printf("[%s] libBus1a.B1a_name() = %s\n",
                __FILE__, b1a_name());
        }
    }
    else {
        printf("[%s] Unable to open libBus1a.dylib: %s\n",
            __FILE__, dlerror());
    }
    dlclose(Bus1a_handle);
}
```

到目前为止，您已经了解了如何通过引用导入的符号或通过使用相应库的句柄或RTLD_DEFAULT特殊句柄调用dlsym获取所需符号的地址来访问符号。 如前所述，插入符号提供了更改依赖库导出的符号定义的功能。

要访问插入符号的原始定义，可以使用`RTLD_NEXT`特殊句柄调用dlsym。清单4显示了Bus库中dependencies函数的实现(Bus1和Bus1a中的实现是相同的)。Bus中的函数返回库的名称(包含在k_lib_name变量中)，并连接分隔符字符串和下一个dependencies定义返回的文本，下一个dependencies定义在Bus1库中找到。Bus1中的定义将其名称与分隔符字符串和Bus1a中的定义返回的文本连接起来。如果没有客户端image定义它们自己的版本，那么Bus1a中的定义是最后一个可以找到的定义。因此，当Bus1a调用dlsym(RTLD_NEXT, "dependencies")时，找不到dependencies的其他定义。这就是dependencies函数的介入层次结构的结束。

清单4使用插入符号的库image

```c
#include <string.h>
static char* k_lib_name = "libBus";
char* dependencies(void) {
    char _dependencies[50] = "";
    strcpy(_dependencies, k_lib_name);
    char* (*next_dependencies)() =
        dlsym(RTLD_NEXT, "dependencies");// look for next definition
    if (next_dependencies) {
        strncat(_dependencies, ", ",
            sizeof(_dependencies) - strlen(_dependencies) - 1);
        strncat(_dependencies, next_dependencies(),
            sizeof(_dependencies) - strlen(_dependencies) - 1);
    }
    return strdup(_dependencies);
}
```

当image调用Bus库中的dependencies函数时，它获得Bus依赖的所有库的名称，如清单5所示。

清单5应用程序image调用一个插入函数

```c
#include <stdio.h>
extern char* dependencies();    // libBus.dylib
 
int main(void) {
    printf("[%s] libBus.dependencies() = %s\n",
        __FILE__, dependencies());
}
```

### 使用弱链接符号


为了促进与早期或后期版本的兼容性，动态库可以将其部分或全部公共符号导出为弱链接符号。弱链接符号(weakly linked symbol)是指当客户端与库链接时，编译器为其生成弱引用的符号。弱链接符号可能在库头文件的声明中有weak_import属性，或者库的开发人员可能会记录哪些库的公共符号是弱链接的。第三种识别弱链接符号的方法是执行命令:

```c
nm -m <client_file> | grep weak
```

此命令列出从依赖库导入的弱链接符号。

弱链接符号可以由依赖库定义，也可以不定义。也就是说，尽管该符号是在头文件中声明的，但相应的动态库文件可能不包含该符号的实现。清单6显示了如何在动态库的头文件中声明弱链接符号。使用此头文件作为其对应依赖库接口的客户端保证定义了name和set_name。当库没有实现弱链接符号时，动态加载器将任何对该符号的客户端引用设置为0。

清单6带有弱链接符号声明的头文件

```c
/* File: Person.h */
#define WEAK_IMPORT __attribute__((weak_import))
char* name(void);
void set_name(char* name);
WEAK_IMPORT
void clear_name(void);
```

库开发人员使用弱链接符号来最大化客户端与依赖库的早期或新版本的兼容性。例如，在库的特定修订中实现的符号可能在以后的修订中不可用。但是与第一个修订版相关联的客户也可以使用第二个修订版。然而，客户端开发人员在执行该符号之前必须确保该符号存在于正在运行的进程中。这种机制还用于为插件提供标准接口，插件可能实现也可能不实现整个接口。

清单7显示了确保在使用特定函数之前定义该函数的代码。当没有找到该函数时，客户端使用不同的函数来完成所需的任务。在这种情况下，回退函数不是弱链接符号，所以不需要测试。其他情况可能不提供替代接口。在这种情况下，客户端可能无法执行所需的任务。

清单7使用弱链接符号

```c
/ Clear the 'name' property.
if (clear_name) {
    clear_name();
}
else {
    set_name(" ");
}
```

### 使用C++类

### 使用Objective-C类

要使用在动态库中实现的Objective-C类或类别，客户端应该有一个到类或类别的接口。通过了解类的正确接口，客户端可以创建具有适当类型的类的实例。否则，编译器会对缺少声明的方法产生警告。

Objective-C类和类别的接口以协议的形式发布在库的头文件中。实例化在依赖库中实现的类与对局部定义的类进行同样的操作没有什么不同。
然而，当你使用dlopen(3) OS X开发人员工具手册在运行时加载一个动态库时，你必须通过调用 objc_getClass函数来获得相应的类。例如，清单12包含Person类的接口和该类的标题类别，这是由Person动态库实现的。

清单12 Person类及其Titling类别的接口

```objc
/* File: Person.h */
#import <Foundation/Foundation.h>
 
@protocol Person
- (void)setName:(NSString*)name;
- (NSString*)name;
@end
 
@interface Person : NSObject <Person> {
    @private
    NSString* _person_name;
}
@end
 
/* File: Titling.h */
#import <Foundation/Foundation.h>
#import "Person.h"
 
@protocol Titling
- (void)setTitle:(NSString*)title;
@end
 
@interface Person (Titling) <Titling>
@end
```
使用这些接口编译并链接到Person库的客户端可以创建以非常直接的方式实现接口的对象，如清单13所示。

清单13使用Person库作为依赖库的客户机示例

```objc
/* File: Client.m */
#import <Foundation/Foundation.h>
#import "Person.h"
#import "Titling.h"
 
int main() {
    @autoreleasepool {
        // Create an instance of Person.
        Person<Titling>* person = [[Person alloc] init];
 
        // Use person.
        [person setName:@"Perrine LeVan"];
        [person setTitle:@"Ms."];
        NSLog(@"[%s] main: [person name] = %@", __FILE__, [person name]);
    }
    return(EXIT_SUCCESS);
}
```

然而，当Person库是一个运行时加载的库时，客户端必须在加载库后使用objc_getClass从Objective-C运行时中获取Person类的引用。然后，它可以使用该引用来实例化Person对象。然而，保存实例的变量必须通过实现Person和Titling协议的NSObject类型来避免编译器的警告。完成后，客户端关闭库，如使用弱链接符号所示。

清单14使用Person库作为运行时加载库的客户机示例

```objc

/* File: Client.m */
#import <Foundation/Foundation.h>
#import <objc/runtime.h>
#import <dlfcn.h>
#import "Person.h"
#import "Titling.h"
 
int main() {
    @autoreleasepool {
        // Open the library.
        void* lib_handle = dlopen("./libPerson.dylib", RTLD_LOCAL);
        if (!lib_handle) {
            NSLog(@"[%s] main: Unable to open library: %s\n",
            __FILE__, dlerror());
            exit(EXIT_FAILURE);
        }
 
        // Get the Person class (required with runtime-loaded libraries).
        Class Person_class = objc_getClass("Person");
        if (!Person_class) {
            NSLog(@"[%s] main: Unable to get Person class", __FILE__);
            exit(EXIT_FAILURE);
        }
 
        // Create an instance of Person.
        NSLog(@"[%s] main: Instantiating Person_class", __FILE__);
        NSObject<Person,Titling>* person = [[Person_class alloc] init];
 
        // Use person.
        [person setName:@"Perrine LeVan"];
        [person setTitle:@"Ms."];
        NSLog(@"[%s] main: [person name] = %@", __FILE__, [person name]);
 
        // Close the library.
        if (dlclose(lib_handle) != 0) {
            NSLog(@"[%s] Unable to close library: %s\n",
                __FILE__, dlerror());
            exit(EXIT_FAILURE);
        }
    }
    return(EXIT_SUCCESS);
}

```

### 获取关于特定地址上的符号的信息

动态加载器兼容性(DLC)函数之一，daddr (3) OS X开发人员工具手册页，提供image和最近的符号对应的地址的信息。您可以使用此函数来获取有关导出特定符号的库的信息。

dladdr提供的信息通过类型为Dl_info的输出参数返回。这些是结构字段的名称及其描述:
- dli_fname: image的路径名
- dli_fbase: 在进程中image的基础地址
- dli_sname: 符号的名称，其地址等于或低于提供给dladdr的地址
- dli_saddr: dli_sname指示的符号地址

清单15显示了image如何获取有关符号的信息


清单15获取关于符号的信息

```objc
#include <stdio.h>
#include <dlfcn.h>
 
extern char* dependencies();
 
int main(void) {
    // Get information on dependencies().
    Dl_info info;
    if (dladdr(dependencies, &info)) {
        printf("[%s] Info on dependencies():\n", __FILE__);
        printf("[%s]    Pathname: %s\n",         __FILE__, info.dli_fname);
        printf("[%s]    Base address: %p\n",     __FILE__, info.dli_fbase);
        printf("[%s]    Nearest symbol: %s\n",   __FILE__, info.dli_sname);
        printf("[%s]    Symbol address: %p\n",   __FILE__, info.dli_saddr);
    }
    else {
        printf("[%s] Unable to find image containing the address %x\n",
    __FILE__, &dependencies);
    }
}
```

## 创建动态库

## 使用动态库

## run path 依赖的库

## 记录动态加载程序事件


## 参考文章

[Dynamic Library Programming Topics](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html#//apple_ref/doc/uid/TP40001908-SW1)

[Framework Programming Guide](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html#//apple_ref/doc/uid/10000183i)

[Code Loading Programming Topics](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/LoadingCode/LoadingCode.html#//apple_ref/doc/uid/10000052i)

[Mach-O Programming Topics](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html#//apple_ref/doc/uid/TP40001519)
