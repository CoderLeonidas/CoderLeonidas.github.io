# 窗口编程指南

应用程序在屏幕上显示必须管理和协调的窗口。一个窗口对象最多对应一个屏幕上的窗口。窗口的两个主要功能是提供放置视图的区域，以及接受和分发用户通过鼠标和键盘操作发送的事件。术语窗口有时指应用程序工具包对象，有时指窗口服务器的窗口设备;什么意思在上下文中是明确的。面板是一种特殊类型的窗口，通常在应用程序中充当辅助功能，例如实用程序窗口。

本文档面向需要在应用程序中使用窗口和面板的Cocoa开发人员。


##  文档结构

本编程主题描述如何使用窗口和面板。

这些文章为您提供了关于不同类型窗口及其工作方式的基本信息：

- 窗口如何工作

- 窗口如何显示

- 模态窗口如何工作

- 面板Panel如何工作

- 窗口控制器如何工作
 
- 窗口分层与窗口类型
 
- 窗口图层与级别
 
- 设置窗口集合行为
 
 这些文章介绍如何使用窗口：
 
- 打开和关闭窗口

- 调整窗口大小与放置窗口

- 保存窗口位置数据到User’s Defaults

- 最小化窗口

- 使用窗口菜单

 这些文章描述如何改变窗口外观
 
- 设置窗口外观

- 设置窗口的标题和代表的文件( Represented File)

- 设置窗口图像的属性

这些文章描述如何处理窗口事件
 
- 在窗口中处理事件

- 在窗口中使用键盘界面控件

- 使用窗口的字段编辑器

这些文章描述了一些窗口的高级特性：

- 使用窗口的通知和代理方法

- 窗口图片的拖放

- 在窗口中更新鼠标图片

- 缓存窗口图片

----
##  窗口如何工作

NSWindow类定义了管理和协调应用程序在屏幕上显示的窗口的对象。一个单独的NSWindow对象最多对应一个屏幕窗口。NSWindow对象的两个主要功能是提供放置NSView对象的区域，并接受用户通过鼠标和键盘的操作向适当的视图分发事件。注意，术语窗口有时指应用程序工具包对象，有时指窗口服务器的显示设备;什么意思在上下文中是明确的。AppKit还定义了NSWindow的一个抽象子类- NSPanel，它为辅助窗口添加了更合适的行为。


一个NSWindow对象是由一个框架矩形定义的，它包围了整个窗口，包括它的标题栏、边框和其他外围元素(如调整大小控件)，而一个内容矩形只包围了它的内容区域。这两个矩形都在屏幕坐标系统中指定，并且仅限于整数值。框架矩形建立了窗口的基本坐标系统。

通常，您使用Interface Builder创建窗口，这允许您定位它们、设置它们的许多属性并布局它们的视图。你对窗口所做的程序性工作通常包括打开和关闭屏幕;改变窗口标题等动态属性;运行模式窗口来限制用户输入;以及分配一个可以监视窗口的某些操作(如关闭、缩放和调整大小)的委托。

您还可以通过指定窗口内容矩形的大小和位置等属性，使用其中的初始化器以编程方式创建窗口。框架（frame）矩形是由内容矩形的尺寸派生出来的。

创建时，窗口将自动创建两个视图:
- 填充框架矩形并绘制边框的不透明框架视图、标题栏、其他外围元素和背景
- 填充内容矩形的透明内容视图。

框架视图及其外围元素是应用程序无法直接访问的私有对象。内容视图是窗口中可访问的最高视图;您可以使用`setContentView`:方法将默认内容视图替换为您自己创建的视图。窗口决定内容视图的位置;你不能使用以`setFrame`开头的NSView方法来定位它;您必须使用NSWindow类的放置方法，如打开和关闭窗口中所述。

您可以通过NSView 的`addSubview`:方法将其他视图作为内容视图的子视图或任何内容视图的子视图，等等，添加到窗口。这个视图树称为窗口的视图层次结构。当一个窗口被告知显示它自己时，它通过发送`display`…发送到其视图层次结构中的顶级视图的消息。因为显示是按照一定的顺序进行的，所以content视图(首先绘制的视图)可能会被它的子视图完全或部分地隐藏，而这些子视图可能会被它们的子视图(等等)所隐藏。


##  窗口如何显示

显示一个NSWindow对象从它的视图对象执行的绘图开始，这些对象积累在窗口的显示缓冲区中或立即显示在屏幕上。与NSView对象一样，窗口可以被无条件地显示，也可以仅仅标记为需要显示，分别使用`display`和`setViewsNeedDisplay`:方法。`displayIfNeeded`消息只在标记为需要显示时才显示窗口的视图。通常，每当一个视图被标记为需要显示时，窗口都会注意到这个事实，并在不久后自动显示自己。这种自动显示通常在每次通过**事件循环**时执行，但是可以使用`setAutodisplay`:方法关闭它。如果您关闭了一个窗口的自动显示，那么您将负责在任何需要的时候显示它。

窗口的视图可以同时绘制。您可以使用`allowsConcurrentViewDrawing`和`setAllowsConcurrentViewDrawing`方法来分别确定和设置一个窗口是否并发地绘制它的视图。默认情况下，窗口的视图是并发绘制的。

在每次通过事件循环时，应用程序对象(application object)调用其`updateWindows`方法，该方法向每个窗口发送更新消息。NSWindow的子类可以覆盖此方法来检查应用程序的状态，并相应地更改它们自己的状态或外观- 例如根据选择的对象来启用或禁用菜单、按钮和其他控件。

除了在屏幕上显示自身之外，窗口还可以打印自身的全部内容，就像视图一样。`print`:方法会运行应用程序的打印面板，并使窗口的框架视图打印自身。`dataWithEPSInsideRect`方法有类似的行为。有关更多信息，请参阅[Printing Programming Guide for Mac.]()。


## 模态窗口如何工作

## 面板Panel如何工作

## 窗口控制器如何工作

## 窗口分层与窗口类型

每个窗口由特定的应用程序放置在屏幕上，每个应用程序通常拥有各种窗口。窗户有许多特点。它们可以位于屏幕上，也可以位于屏幕外。在屏幕上，窗口以窗口服务器管理的级别放置在屏幕上。

屏幕上的窗口是从前到后排列的。就像一张张松散地叠在一起的纸，前面的窗户可以重叠，甚至完全盖住后面的窗户。每个窗口在顺序中都有一个独特的位置。当两个窗口并排放置时，从技术上讲，一个窗口仍然在另一个窗口的前面。

如果任何一个窗口都在其他窗口的前面，那么像菜单和工具面板这样的小而重要的窗口可能会丢失在更大的窗口后面。需要用户操作的窗口，比如注意力面板(attention panel)和弹出列表，可能会消失在另一个窗口后面，不被注意。为了防止这种情况发生，屏幕上的所有窗口都被组织成不同的层次。

当两个窗口属于同一层时，任何一个都可以在前面。然而，当两个窗口属于不同的级别时，位于较高级别的窗口总是位于其他窗口之上。

屏幕上的窗口还可以显示状态:**main**状态或**key**状态。屏幕外的窗口隐藏或最小化在Dock上，并且不携带任何状态。屏幕上既不是main窗口也不是key窗口的窗口是不活动的。

### 窗口分层

每个应用程序和文档窗口都存在于自己的层中，因此可以交错显示来自不同应用程序的文档。点击一个窗口将它移到前面不会打乱其他窗口的分层顺序。

窗口在层中的深度是由窗口最后一次被访问的时间决定的。当用户单击不活动的文档或从窗口菜单中选择它时，只有该文档和任何打开的实用程序窗口应该放在前面。用户可以通过单击Dock中的图标或在应用程序窗口菜单中选择`**bring all to Front**`来将应用程序的所有窗口向前移动。这些操作应该使应用程序的所有窗口都处于打开状态，保持它们在屏幕上的位置、大小和应用程序内的分层顺序。有关更多信息，请参见UI元素指南:[OS X Human Interface Guidelines]()中的菜单。

实用程序窗口总是在同一层:顶层。它们只有在应用程序处于活动状态时才可见。

### Key 和 Main 窗口

简单说，窗口状态由以下几种：

- 非活动状态
- 活动状态
	- Key状态
	- Main状态

窗口有不同的外观，这取决于用户如何与它们交互。用户最关注的文档或应用程序窗口称为Main窗口。每个应用程序在给定的时间内也只有一个Main窗口。每个应用程序在给定的时间内也只有一个Main窗口。这个Main窗口通常也具有key状态。Main窗口是应用程序用户操作的主要焦点。通常，用户在模态Key窗口(通常是一个面板，如字体窗口或信息窗口)中的操作对Main窗口有直接影响。


Main窗口和Key窗口都是活动窗口。活动窗口与非活动窗口在视觉上是不同的，因为它们的控件有颜色，而非活动窗口中的控件没有颜色。非活动窗口是用户打开但不在前台的窗口。Main窗口和Key窗口总是在前台，它们的控件总是有颜色。如果Main窗口和Key窗口是不同的窗口，则通过标题栏的外观将它们彼此区分开来。请注意图1中Main窗口、Key窗口和非活动窗口之间的视觉区别：

Figure 1  Main, key, and inactive windows

![](https://i.loli.net/2020/05/06/uoqx6pbnSBfYLRe.png)

键和Main窗口的区别的一个很好的例子，在大多数表现良好的Mac应用程序中都可以看到。例如，在文本文档中，选择另存为…，会显示一个面板，其中有一个字段用于输入文档名称，还有一个下拉菜单用于保存文档。面板表示Key窗口。它将接受您的键盘输入(文件名)，但将直接影响它下面的Main窗口(通过将其保存到您指定的位置)。保存文档后，保存面板消失，Main窗口再次变为键，再次接受键盘输入。

### Key窗口

Key窗口响应用户输入，无论是来自键盘、鼠标还是应用程序的其他输入设备，并且是菜单和面板消息的主要接收方。通常，当用户单击一个窗口时，它就成为键。每个应用程序在给定时间只能有一个Key窗口。

用户希望看到他们在键盘和鼠标上的操作不仅在特定的应用程序中生效，而且在该应用程序的特定窗口中也生效。每个用户操作都通过窗口服务器和AppKit与一个窗口相关联。在执行之前，用户需要知道哪个窗口将受到影响;不应该有任何意外。


由于鼠标控制指针，所以用户很容易确定鼠标操作与哪个窗口相关联。指针指向的是哪个窗口。但是键盘没有指针，所以没有一种自然的方法来确定输入的字符将出现在哪里。

为了标记用户的Key窗口，AppKit突出显示它的标题栏。你可以把高亮显示想象成一种键盘指针。它会随着关Key窗口的变化而从一个窗口切换到另一个窗口。随着活动应用程序的更改，Key窗口状态也从一个应用程序移动到另一个应用程序。屏幕上一次只有一个窗口被标记，并且它位于活动应用程序中。桌面上只有一个Key窗口。即使一个系统有两个屏幕，但只有一个键盘，最多也只有一个Key窗口。

>  注意： 窗口不必成为接收和操作键盘快捷键的Key窗口。但是，它必须是活动应用程序中的一个窗口。

由于Key窗口属于活动应用程序，它突出显示的标题栏有一个次要的作用，即帮助显示当前处于活动状态的应用程序。key窗口是活动应用程序中最显著的标记窗口，这使得它具有第二种意义:它是用户在屏幕上的主要注意力焦点。

### Main窗口

Main窗口是用户当前工作的标准窗口。Main窗口并不总是Key窗口。有时，除Main窗口外的其他窗口成为输入设备的焦点，而Main窗口仍然是用户注意的焦点，以及在面板和菜单中执行的用户操作的焦点。例如，当一个人使用检查器、查找对话框或字体或颜色窗口时，文档是Main窗口，其他窗口是Key窗口。

当一个标准窗口成为Key窗口时，它也会成为Main窗口。当Key窗口状态从标准窗口转移到面板时，Main窗口状态仍然保留在标准窗口中。

因此，当Main窗口不是Key窗口时，用户可以选择它， Application Kit会高亮显示它的标题栏并给窗口按钮上色。如果Main窗口也是Key窗口，那么它只突出显示Key窗口。菜单命令可能影响Key窗口或Main窗口，具体取决于该命令。例如，可以使用Paste命令在查找面板中输入文本。但是Save命令保存Main窗口中显示的文档，而Bold命令将Main窗口中的当前选择变为粗体。因此，面板或菜单中的用户操作同时与Key窗口和Main窗口相关联：

- 操作首先与密钥窗口相关联。
- 如果Key窗口是一个面板，并且它不能处理操作，那么该操作将与Main窗口相关联

请注意，这种优先顺序反映在突出显示窗口的方式上:Key窗口总是被标记，但是只有Main窗口不是Key窗口时才被标记。Main窗口始终与Key窗口(活动应用程序)位于同一应用程序中。


### 改变窗口状态

方式自动更改它们作为键或Main窗口的状态。您还可以通过向相关窗口发送`makeKeyWindow`或`makeMainWindow`消息以编程方式设置key和Main窗口。以编程方式设置键和Main窗口在创建新窗口时特别有用。由于创建窗口键通常与将窗口排序到屏幕前面相结合，所以NSWindow类定义了一个方便的方法`makeKeyAndOrderFront`:，它执行这两种操作。


并非所有窗口都适合作为Key窗口或Main窗口。例如，仅显示信息且不包含需要响应事件或操作消息的对象的窗口可以完全放弃成为Key窗口。类似地，仅通过鼠标操作拖出的项目的浮动调色板窗口不需要是Key窗口。这样一个窗口可以被定义为NSWindow的一个子类，它覆盖了方法`canBecomeKeyWindow`和`canBecomeMainWindow`来返回**NO**而不是默认的YES。以这种方式定义一个窗口可以防止它成为Key窗口或Main窗口。虽然NSWindow类定义了这些方法，但是只有NSPanel的子类通常拒绝接受键或Main窗口状态。


## 窗口层(layer)与级别(level)

窗口可以放置在屏幕上的三维空间。除了水平和垂直的位置，窗户在不同的层次上是前后分层的。每个应用程序和文档窗口都存在于自己的层（layer）中，因此可以交错显示来自不同应用程序的文档。点击一个窗口将它移到前面不会打乱其他窗口的分层顺序。窗口在层中的深度是由窗口最后一次被访问的时间决定的。当用户单击不活动的文档或从窗口菜单中选择它时，只有该文档和任何打开的实用程序窗口应该放在前面。

### 窗口级别

窗口在几个不同的级别内排序。窗口级别对类似类型和用途的窗口进行分组，以便更重要的窗口(例如警报面板)出现在那些不太重要的窗口前面。一个窗口的级别作为一个高阶位来确定它相对于其他窗口的位置。可以在给定的级别内对窗口之间的关系进行重新排序;然而，一个给定的窗口不能在更高的级别上被分层放置在其他窗口之上。

有许多预定义的窗口级别，由NSWindow类定义的常量指定。您通常使用的级别是:NSNormalWindowLevel，它指定默认级别;NSFloatingWindowLevel，它指定了浮动调色板的级别;以及NSScreenSaverWindowLevel，它指定屏幕保护程序窗口的级别。你也可以用NSStatusWindowLevel来表示状态窗口，或者用NSModalPanelWindowLevel来表示模式面板。如果你需要实现你自己的弹出菜单，你可以使用NSPopUpMenuWindowLevel。剩下的两层，NSTornOffMenuWindowLevel和NSMainMenuWindowLevel，保留给系统使用。



### 以编程方式设置顺序和级别

您可以使用 `orderWindow:relativeTo`:方法在另一个窗口的前面或后面对其级别内的窗口进行排序。您通常使用方便的方法来指定排序，比如`makeKeyAndOrderFront`:(它也影响状态)、`orderFront`:和`orderBack`:，以及`orderOut`:，它从屏幕上删除一个窗口。您可以使用`isVisible`方法来确定一个窗口是在屏幕上还是在屏幕外。您还可以使用`setHidesOnDeactivate`:设置一个在应用程序不活动时自动从屏幕上删除的窗口。

 通常，您不需要以编程方式设置窗口的级别，因为Cocoa会根据窗口的特征自动确定适当的级别。例如，一个实用程序面板被自动分配到`NSFloatingWindowLevel`。然而，你可以使用`setLevel`:方法设置窗口的级别;例如，你可以将一个标准窗口的级别设置为`NSFloatingWindowLevel`，如果你想要一个看起来像标准窗口的工具窗口(例如作为一个检查器)。然而，这有两个缺点:首先，它可能违反了人机界面指南;其次，如果您将一个窗口分配给一个浮动级别，您必须确保您还将它设置为在应用程序停用时隐藏，或者在应用程序隐藏时重置其级别。如果您使用默认的窗口配置，Cocoa会自动为您处理后一个方面。
 
 目前没有指定允许您将窗口置于屏幕保护程序窗口之上的级别。如果需要这样做(例如，在屏幕保护程序运行时显示警报)，可以将窗口的级别设置为大于屏幕保护程序的级别，如下面的示例所示。
 
 ```objc
 [aWindow setLevel:NSScreenSaverWindowLevel + 1];
 ```
 
 除了这种特殊情况外，不建议在自定义级别设置窗口，因为这可能会导致意外的行为。
 
## 设置窗口集合行为

## 打开和关闭窗口

## 调整窗口大小与放置窗口

## 保存窗口位置数据到User’s Defaults

## 最小化窗口

## 使用窗口菜单

 
## 设置窗口外观

## 设置窗口的标题和代表的文件( Represented File)

## 设置窗口图像的属性

## 在窗口中处理事件

## 在窗口中使用键盘界面控件

## 使用窗口的字段编辑器



## 使用窗口的通知和代理方法

## 窗口图片的拖放

## 在窗口中更新鼠标图片

## 缓存窗口图片

## 还可以看看



## 参考文章

[Window Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/WinPanel/Introduction.html#//apple_ref/doc/uid/10000031-SW1)


