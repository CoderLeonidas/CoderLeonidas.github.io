---
layout:     post
title:      "C++ 笔记 - 高级篇"
//subtitle:   "持续更新中..."
date:       2019-10-21 23:59:59
author:     "CoderLeonidas"
catalog: true
tags:
- C++

---

# <center>C++ 笔记 - 高级篇</center>

## 文件和流


目前为止，我们已经使用了 **iostream** 标准库，它提供了 **cin** 和 **cout** 方法分别用于从标准输入读取流和向标准输出写入流。

本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 **fstream**，它定义了三个新的数据类型：

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g86axan9wrj30n8051gmb.jpg)

要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 `<iostream>` 和 `<fstream>`。

#### 打开文件
在从文件读取信息或者向文件写入信息之前，必须先打开文件。**ofstream** 和 **fstream** 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 **ifstream** 对象。

下面是 `open()` 函数的标准语法，`open()` 函数是 `fstream`、`ifstream` 和 `ofstream` 对象的一个成员。

```c++
void open(const char *filename, ios::openmode mode);
```

在这里，`open()` 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。

模式标志	| 描述
----------|--------   
ios::app|	追加模式。所有写入都追加到文件末尾。
ios::ate|	文件打开后定位到文件末尾。
ios::in|	打开文件用于读取。
ios::out|	打开文件用于写入。
ios::trunc|	如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。

您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：

```c++
ofstream outfile;
outfile.open("file.dat", ios::out | ios::trunc );
```

#### 关闭文件

当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。

下面是 `close()` 函数的标准语法，`close()` 函数是 fstream、ifstream 和 ofstream 对象的一个成员。

```c++
void close();
```

#### 写入文件

在 C++ 编程中，我们使用`流插入运算符（ << ）`向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 `ofstream` 或 `fstream`对象，而不是 `cout` 对象。

#### 读取文件

在 C++ 编程中，我们使用`流提取运算符（ >> ）`从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 `ifstream` 或 `fstream` 对象，而不是 `cin` 对象。

#### 读取 & 写入实例

下面的 C++ 程序以读写模式打开一个文件。在向文件 `afile.dat` 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上：

```c++
#include <fstream>
#include <iostream>
using namespace std;
 
int main ()
{
    
   char data[100];
 
   // 以写模式打开文件
   ofstream outfile;
   outfile.open("afile.dat");
 
   cout << "Writing to the file" << endl;
   cout << "Enter your name: "; 
   cin.getline(data, 100);
 
   // 向文件写入用户输入的数据
   outfile << data << endl;
 
   cout << "Enter your age: "; 
   cin >> data;
   cin.ignore();
   
   // 再次向文件写入用户输入的数据
   outfile << data << endl;
 
   // 关闭打开的文件
   outfile.close();
 
   // 以读模式打开文件
   ifstream infile; 
   infile.open("afile.dat"); 
 
   cout << "Reading from the file" << endl; 
   infile >> data; 
 
   // 在屏幕上写入数据
   cout << data << endl;
   
   // 再次从文件读取数据，并显示它
   infile >> data; 
   cout << data << endl; 
 
   // 关闭打开的文件
   infile.close();
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列输入和输出：

```c++
$./a.out
Writing to the file
Enter your name: Zara
Enter your age: 9
Reading from the file
Zara
9
```


上面的实例中使用了 `cin` 对象的附加函数，比如 `getline()`函数从外部读取一行，`ignore()` 函数会忽略掉之前读语句留下的多余字符。


#### 文件位置指针

istream 和 ostream 都提供了用于**重新定位文件位置指针**的成员函数。这些成员函数包括关于 **istream** 的 `seekg`（"seek get"）和关于 **ostream** 的 `seekp`（"seek put"）。

`seekg` 和 `seekp` 的参数通常是一个长整型。第二个参数可以用于指定查找方向。

查找方向可以是 :

- `ios::beg`（默认的，从流的开头开始定位）

- `ios::cur`（从流的当前位置开始定位）

- `ios::end`（从流的末尾开始定位）

文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 "get" 文件位置指针的实例：

```c++
// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）
fileObject.seekg( n );
 
// 把文件的读指针从 fileObject 当前位置向后移 n 个字节
fileObject.seekg( n, ios::cur );
 
// 把文件的读指针从 fileObject 末尾往回移 n 个字节
fileObject.seekg( n, ios::end );
 
// 定位到 fileObject 的末尾
fileObject.seekg( 0, ios::end );
```

#### cin.ignore()

关于 `cin.ignore()` ，完整版本是 `cin.ignore(int n, char a)`, 从输入流 (cin) 中提取字符，提取的字符被忽略 (ignore)，不被使用。每抛弃一个字符，它都要计数和比较字符：如果计数值达到 n 或者被抛弃的字符是 a，则 `cin.ignore()`函数执行终止；否则，它继续等待。它的一个常用功能就是用来清除以回车结束的输入缓冲区的内容，消除上一次输入对下一次输入的影响。比如可以这么用：`cin.ignore(1024,'\n')`，通常把第一个参数设置得足够大，这样实际上总是只有第二个参数 \n 起作用，所以这一句就是把回车(包括回车)之前的所以字符从输入缓冲(流)中清除出去。

```c++
#include <iostream>
using namespace std;
void main()
{
    int a,b,c;
    cout<<"input a:";
    cin>>a;
    cin.ignore(1024, '\n');
    cout<<"input b:";
    cin>>b;
    cin.ignore(1024, '\n');
    cout<< "input c:";
    cin>> c;
    cout<< a << "\t" << b << "\t" << c << endl;
}
```

如果`cin.ignore()`不给参数，则默认参数为`cin.ignore(1,EOF)` 其中 `EOF`是**end of file**的缩写，表示"文字流"(stream)的结尾。

```c++
#include<iostream>  
using   namespace   std;  
int main()  
{  
    char   str1[30],str2[30],str3[30];  
    cout   <<   "请输入你的姓名：";  
    cin>>str1;  
    cout<<"请输入你的住址：";  
    cin.ignore();  
    cin.getline(str2,30,'a');  
    cout   <<   "请输入你的籍贯：";  
    cin.ignore();  
    cin.getline(str3,30);  
    cout<<str3;  
}
```

如果在地址那里输入 `bcdabcd` 那么此时流里面剩的是 `bcd\n`,此时 `cin.ignore()`; 吃掉的就是`b`了，这是流里还剩下 `cd\n` 直接交给 `cin.getline(str3,30)`; 应为有个 `\n` 所以这里 `getline` 就直接返回。

## 异常处理

异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。

异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：**try**、**catch**、**throw**。

- `throw`: 当问题出现时，程序会抛出一个异常。这是通过使用 `throw` 关键字来完成的。

- `catch`: 在您想要处理问题的地方，通过异常处理程序捕获异常。`catch` 关键字用于捕获异常。
- `try`: `try` 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 `catch` 块。

如果有一个块抛出一个异常，捕获异常的方法会使用 `try` 和 `catch` 关键字。`try` 块中放置可能抛出异常的代码，`try` 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：

```c++
try
{
   // 保护代码
}catch( ExceptionName e1 )
{
   // catch 块
}catch( ExceptionName e2 )
{
   // catch 块
}catch( ExceptionName eN )
{
   // catch 块
}
```

如果 **try** 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 **catch** 语句，用于捕获不同类型的异常。


#### 抛出异常

您可以使用 `throw` 语句在代码块中的任何地方抛出异常。`throw` 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。

以下是尝试除以零时抛出异常的实例：

```c++
double division(int a, int b)
{
   if( b == 0 )
   {
      throw "Division by zero condition!";
   }
   return (a/b);
}
```

#### 捕获异常

**catch** 块跟在 **try** 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 **catch** 关键字后的括号内的异常声明决定的。

```c++
try
{
   // 保护代码
}catch( ExceptionName e )
{
  // 处理 ExceptionName 异常的代码
}
```

上面的代码会捕获一个类型为 **ExceptionName** 的异常。如果您想让 **catch** 块能够处理 **try** 块抛出的**任何类型的异常**，则必须在异常声明的括号内使用省略号 `...`，如下所示：

```c++
try
{
   // 保护代码
}catch(...)
{
  // 能处理任何异常的代码
}
```

下面是一个实例，抛出一个除以零的异常，并在 **catch** 块中捕获该异常。

```c++
#include <iostream>
using namespace std;
 
double division(int a, int b)
{
   if( b == 0 )
   {
      throw "Division by zero condition!";
   }
   return (a/b);
}
 
int main ()
{
   int x = 50;
   int y = 0;
   double z = 0;
 
   try {
     z = division(x, y);
     cout << z << endl;
   }catch (const char* msg) {
     cerr << msg << endl;
   }
 
   return 0;
}
```

由于我们抛出了一个类型为 `const char*` 的异常，因此，当捕获该异常时，我们必须在 **catch** 块中使用 `const char*`。当上面的代码被编译和执行时，它会产生下列结果：

```c++
Division by zero condition!
```

#### C++ 标准的异常

C++ 提供了一系列标准的异常，定义在 <exception> 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g86bfychxfj30g00dcmx6.jpg)

下表是对上面层次结构中出现的每个异常的说明：

异常|	描述
----|------
std::exception|	该异常是所有标准 C++ 异常的父类。
std::bad_alloc|	该异常可以通过 new 抛出。
std::bad_cast|	该异常可以通过 dynamic_cast 抛出。
std::bad_exception|	这在处理 C++ 程序中无法预期的异常时非常有用。
std::bad_typeid|	该异常可以通过 typeid 抛出。
std::logic_error|	理论上可以通过读取代码来检测到的异常。
std::domain_error|	当使用了一个无效的数学域时，会抛出该异常。
std::invalid_argument|	当使用了无效的参数时，会抛出该异常。
std::length_error|	当创建了太长的 std::string 时，会抛出该异常。
std::out_of_range|	该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator[]()。
std::runtime_error|	理论上不可以通过读取代码来检测到的异常。
std::overflow_error|	当发生数学上溢时，会抛出该异常。
std::range_error	| 当尝试存储超出范围的值时，会抛出该异常。
std::underflow_error|	当发生数学下溢时，会抛出该异常。


#### 定义新的异常

您可以通过继承和重载 `exception` 类来定义新的异常。下面的实例演示了如何使用 `std::exception` 类来实现自己的异常：

```c++
#include <iostream>
#include <exception>
using namespace std;
 
struct MyException : public exception
{
  const char * what () const throw ()
  {
    return "C++ Exception";
  }
};
 
int main()
{
  try
  {
    throw MyException();
  }
  catch(MyException& e)
  {
    std::cout << "MyException caught" << std::endl;
    std::cout << e.what() << std::endl;
  }
  catch(std::exception& e)
  {
    //其他的错误
  }
}
```


这将产生以下结果：
```c++
MyException caught
C++ Exception
```

在这里，`what()` 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。

#### C++ Primer 中关于 what（）的解释：
在之前的例子里，我们使用了一个 **throw** 表达式以避免把两个代表不同书籍的 **Sales_item** 相加。我们假设执行 Sales_item 对象加法的代码是与用户交互的代码分离开的。其中与用户交互的代码负责处理发生的异常，它的形式可能如下所示：

```c++
while (cin >> item1 >> item2){
  try{
    //执行添加两个Sales_item对象的代码
    //如果添加失败，代码抛出一个runtime_error异常
  } catch (runtime_error err){
      //提醒用户两个ISBN必须一致，询问是否重新输入
      cout << err.what()
           << "\nTry Again? Enter y or n" << endl;
      char c;
      cin >> c;
      İf (!cin || c == 'n')
          break;//跳出while循环
    }
}
```

程序本来要执行的任务出现在 **try** 语句块中，是因为这段代码可能会抛出一个 `runtime_error` 类型的异常。

**try** 语句块对应一个 **catch** 子句。该子句负责处理类行为 `runtime_error` 的异常。如果 try 语句块的代码抛出了`runtime_error` 异常，接下来执行 **catch** 块内的语句。在我们书写的 **catch** 子句中，数出一段提示信息要求用户指定程序是否继续。如果用户输入 **n**，执行 `break` 语句并退出 `while` 循环；否则，直接执行 `while` 循环的右侧花括号，意味着程序控制权条回到 `while` 条件部分准备下一次迭代。

给用户的提示信息中输出了 `err.what()` 的返回值。我们知道 **err** 的类型是 `runtime_error`，因此能推断 `what` 是 `runtime_error` 类的一个成员函数。每个标准库异常类都定义了名为 `what` 的成员函数。这些函数没有参数，返回值是 C 风格字符串（即` const char *`）其中，`runtime_error` 的 `what` 成员函数返回的是初始化一个具体对象所用的 string 对象的副本。如果上一节编写的代码抛出异常，则本节的 **catch** 子句输出:

```c++
Data must refer to same ISBN
Try Again? Enter y or n
```

#### noexcept

在 C++11 中，声明一个函数不可以抛出任何异常使用关键字 `noexcept`。

```c++
void mightThrow(); // could throw any exceptions.
void doesNotThrow() noexcept; // does not throw any exceptions.
```

下面两个函数声明的异常规格在语义上是相同的，都表示函数不抛出任何异常。

```c++
void old_stytle() throw();
void new_style() noexcept;
```


## 动态内存 

了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：

- 栈：在函数内部声明的所有变量都将占用栈内存。

- 堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。

很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。

在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 `new` 运算符。

如果您不再需要动态分配的内存空间，可以使用 `delete` 运算符，删除之前由 `new` 运算符分配的内存。

#### new 和 delete 运算符

下面是使用 `new 运算符来为任意的数据类型动态分配内存的通用语法：

```c++
new data-type;
```

在这里，`data-type` 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 **double** 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 new 运算符来完成这点：

```c++
double* pvalue  = NULL; // 初始化为 null 的指针
pvalue  = new double;   // 为变量请求内存
```

如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 `new` 运算符是否返回 `NULL` 指针，并采取以下适当的操作：

```c++
double* pvalue  = NULL;
if( !(pvalue  = new double ))
{
   cout << "Error: out of memory." <<endl;
   exit(1);
 
}
```

`malloc()` 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 `malloc()` 函数。`new` 与 `malloc()` 函数相比，其主要的优点是，`new` 不只是**分配了内存**，它还**创建了对象**。

在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 `delete` 操作符释放它所占用的内存，如下所示：

```c++
delete pvalue;        // 释放 pvalue 所指向的内存
```

下面的实例中使用了上面的概念，演示了如何使用 `new` 和 `delete` 运算符

```c++
#include <iostream>
using namespace std;
 
int main ()
{
   double* pvalue  = NULL; // 初始化为 null 的指针
   pvalue  = new double;   // 为变量请求内存
 
   *pvalue = 29494.99;     // 在分配的地址存储值
   cout << "Value of pvalue : " << *pvalue << endl;
 
   delete pvalue;         // 释放内存
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c++
Value of pvalue : 29495
```

#### 数组的动态内存分配

假设我们要为一个字符数组（一个有 20 个字符的字符串）分配内存，我们可以使用上面实例中的语法来为数组动态地分配内存，如下所示：

```c++
char* pvalue  = NULL;   // 初始化为 null 的指针
pvalue  = new char[20]; // 为变量请求内存
```

要删除我们刚才创建的数组，语句如下：

```c++
delete [] pvalue;        // 删除 pvalue 所指向的数组
```

下面是 `new` 操作符的通用语法，可以为多维数组分配内存，如下所示：

```c++
// 一维数组
// 动态分配,数组长度为 m
int *array=new int [m]；
 
//释放内存
delete [] array;
```

```c++
二维数组
int **array
// 假定数组第一维长度为 m， 第二维长度为 n
// 动态分配空间
array = new int *[m];
for( int i=0; i<m; i++ )
{
    array[i] = new int [n]  ;
}
//释放
for( int i=0; i<m; i++ )
{
    delete [] arrary[i];
}
delete [] array;
```

二维数组实例测试：

```c++
#include <iostream>
using namespace std;
 
int main()
{
    int **p;   
    int i,j;   //p[4][8] 
    //开始分配4行8列的二维数据   
    p = new int *[4];
    for(i=0;i<4;i++){
        p[i]=new int [8];
    }
 
    for(i=0; i<4; i++){
        for(j=0; j<8; j++){
            p[i][j] = j*i;
        }
    }   
    //打印数据   
    for(i=0; i<4; i++){
        for(j=0; j<8; j++)     
        {   
            if(j==0) cout<<endl;   
            cout<<p[i][j]<<"\t";   
        }
    }   
    //开始释放申请的堆   
    for(i=0; i<4; i++){
        delete [] p[i];   
    }
    delete [] p;   
    return 0;
}
```

三维数组测试实例：

```c++

#include <iostream>
using namespace std;
 
int main()
{   
    int i,j,k;   // p[2][3][4]
    
    int ***p;
    p = new int **[2]; 
    for(i=0; i<2; i++) 
    { 
        p[i]=new int *[3]; 
        for(j=0; j<3; j++) 
            p[i][j]=new int[4]; 
    }
    
    //输出 p[i][j][k] 三维数据
    for(i=0; i<2; i++)   
    {
        for(j=0; j<3; j++)   
        { 
            for(k=0;k<4;k++)
            { 
                p[i][j][k]=i+j+k;
                cout<<p[i][j][k]<<" ";
            }
            cout<<endl;
        }
        cout<<endl;
    }
    
    // 释放内存
    for(i=0; i<2; i++) 
    {
        for(j=0; j<3; j++) 
        {   
            delete [] p[i][j];   
        }   
    }       
    for(i=0; i<2; i++)   
    {       
        delete [] p[i];   
    }   
    delete [] p;  
    return 0;
}
```

#### 对象的动态内存分配

对象与简单的数据类型没有什么不同。例如，请看下面的代码，我们将使用一个对象数组来理清这一概念：

```c++
#include <iostream>
using namespace std;
 
class Box
{
   public:
      Box() { 
         cout << "调用构造函数！" <<endl; 
      }
      ~Box() { 
         cout << "调用析构函数！" <<endl; 
      }
};
 
int main( )
{
   Box* myBoxArray = new Box[4];
 
   delete [] myBoxArray; // 删除数组
   return 0;
}
```

如果要为一个包含四个 **Box** 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。

当上面的代码被编译和执行时，它会产生下列结果：

```
调用构造函数！
调用构造函数！
调用构造函数！
调用构造函数！
调用析构函数！
调用析构函数！
调用析构函数！
调用析构函数！
```

#### delete 与 delete[] 区别：

1、针对简单类型 使用 new 分配后的不管是数组还是非数组形式内存空间用两种方式均可 如

```c++
int *a = new int[10];   
delete a;   
delete [] a; 
```

此种情况中的释放效果相同，原因在于：分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数， 它直接通过指针可以获取实际分配的内存空间，哪怕是一个数组内存空间(在分配过程中 系统会记录分配内存的大小等信息，此信息保存在结构体`_CrtMemBlockHeader`中， 具体情况可参看VC安装目录下**CRT\SRC\DBGDEL.cpp**)

2、针对类Class，两种方式体现出具体差异

当你通过下列方式分配一个类对象数组：

```c++
class A
{
    private:
        char *m_cBuffer;
        int m_nLen;
    public:
        A(){ m_cBuffer = new char[m_nLen]; }
        ~A() { delete [] m_cBuffer; }
};
A *a = new A[10];

// 仅释放了a指针指向的全部内存空间 但是只调用了a[0]对象的析构函数 剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放 从而造成内存泄漏
delete a;

// 调用使用类对象的析构函数释放用户自己分配内存空间并且   释放了a指针指向的全部内存空间
delete [] a;
```


所以总结下就是，如果**ptr**代表一个用`new`申请的内存返回的内存空间地址，即所谓的指针，那么：

 - `delete ptr` -- 代表用来释放内存，且只用来释放ptr指向的内存。
 
 - `delete[] rg` -- 用来释放rg指向的内存，！！还逐一调用数组中每个对象的 `destructor`！！
 
对于像 `int/char/long/int*/struct` 等等简单数据类型，由于对象没有 `destructor`，所以用 `delete` 和 `delete []` 是一样的！但是如果是C++ 对象数组就不同了！

#### new 和 malloc 内部的实现方式有什么区别？

> `new` 的功能是在堆区新建一个对象，并返回该对象的指针。

所谓的【新建对象】的意思就是，将调用该类的构造函数，因为如果不构造的话，就不能称之为一个对象。

> 而`malloc` 只是机械的分配一块内存，如果用 `malloc`  在堆区创建一个对象的话，是不会调用构造函数的。

严格说来用 `malloc`  不能算是新建了一个对象，只能说是分配了一块与该类对象匹配的内存而已，然后强行把它解释为【这是一个对象】，按这个逻辑来，也不存在构造函数什么事。

> 同样的，用 `delete` 去释放一个堆区的对象，会调用该对象的析构函数。

> 用 `free` 去释放一个堆区的对象，不会调用该对象的析构函数。

做个简单的实验即可明了:

```c++
#include <iostream>
#include <malloc.h>

class TEST
{
private:
    int num1;
    int num2;
public:
    TEST()
    {
        num1 = 10;
        num2 = 20;
    }
    void Print()
    {
        std::cout << num1 << " " << num2 << std::endl;
    }
};

int main(void)
{
    // 用malloc()函数在堆区分配一块内存空间，然后用强制类型转换将该块内存空间
    // 解释为是一个TEST类对象，这不会调用TEST的默认构造函数
    TEST * pObj1 = (TEST *)malloc(sizeof(TEST));
    pObj1->Print();

    // 用new在堆区创建一个TEST类的对象，这会调用TEST类的默认构造函数
    TEST * pObj2 = new TEST;
    pObj2->Print();

    return 0;
}
/*
运行结果：

-----------------------------
-842150451 -842150451       |
10 20                       |
请按任意键继续. . .         |
-----------------------------

我们可以看到pObj1所指的对象中，字段num1与num2都是垃圾值
而pObj2所指的对象中，字段num1与num2显然是经过了构造后的值
*/
```


## 命名空间

#### 定义命名空间

命名空间的定义使用关键字 `namespace`，后跟命名空间的名称，如下所示：

```c++
namespace namespace_name {
   // 代码声明
}
```

为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：

```c++
name::code;  // code 可以是变量或函数
```
让我们来看看命名空间如何为变量或函数等实体定义范围：

```c++
#include <iostream>
using namespace std;
 
// 第一个命名空间
namespace first_space{
   void func(){
      cout << "Inside first_space" << endl;
   }
}
// 第二个命名空间
namespace second_space{
   void func(){
      cout << "Inside second_space" << endl;
   }
}
int main ()
{
 
   // 调用第一个命名空间中的函数
   first_space::func();
   
   // 调用第二个命名空间中的函数
   second_space::func(); 
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c++
Inside first_space
Inside second_space
```

#### using 指令

您可以使用 `using namespace` 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。

```c++
#include <iostream>
using namespace std;
 
// 第一个命名空间
namespace first_space{
   void func(){
      cout << "Inside first_space" << endl;
   }
}
// 第二个命名空间
namespace second_space{
   void func(){
      cout << "Inside second_space" << endl;
   }
}
using namespace first_space;
int main ()
{
 
   // 调用第一个命名空间中的函数
   func();
   
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c++
Inside first_space
```

`using` 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 `std` 命名空间中的 `cout` 部分，您可以使用如下的语句：

```c++
using std::cout;
```

随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 `std` 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示：

```c++
#include <iostream>
using std::cout;
 
int main ()
{
 
   cout << "std::endl is used with std!" << std::endl;
   
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c++
std::endl is used with std!
```

`using` 指令引入的名称遵循正常的范围规则。名称从使用 `using`  指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。

#### 不连续的命名空间

命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。

所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素：

```c++
namespace namespace_name {
   // 代码声明
}
```

#### 嵌套的命名空间

命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示：

```c++
namespace namespace_name1 {
   // 代码声明
   namespace namespace_name2 {
      // 代码声明
   }
}
```

您可以通过使用 `::` 运算符来访问嵌套的命名空间中的成员：

```c++
// 访问 namespace_name2 中的成员
using namespace namespace_name1::namespace_name2;
 
// 访问 namespace:name1 中的成员
using namespace namespace_name1;
```

在上面的语句中，如果使用的是 **namespace_name1**，那么在该范围内 **namespace_name2** 中的元素也是可用的，如下所示：

```c++

#include <iostream>
using namespace std;
 
// 第一个命名空间
namespace first_space{
   void func(){
      cout << "Inside first_space" << endl;
   }
   // 第二个命名空间
   namespace second_space{
      void func(){
         cout << "Inside second_space" << endl;
      }
   }
}
using namespace first_space::second_space;
int main ()
{
 
   // 调用第二个命名空间中的函数
   func();
   
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c++
Inside second_space
```

## 模板

模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。

模板是创建**泛型类**或**函数**的蓝图或公式。**库容器**，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。

每个容器都有一个单一的定义，比如 **向量**，我们可以定义许多不同类型的向量，比如 `vector <int>` 或 `vector <string>`。

您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。

#### 函数模板

模板函数定义的一般形式如下所示：

```c++
template <class type> ret-type func-name(parameter list)
{
   // 函数的主体
}
```


在这里，**type** 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。

下面是函数模板的实例，返回两个数中的最大值：

```c++
#include <iostream>
#include <string>
 
using namespace std;
 
template <typename T> // 或者 template <class T> 也行

inline T const& Max (T const& a, T const& b) 
{ 
    return a < b ? b:a; 
} 
int main ()
{
 
    int i = 39;
    int j = 20;
    cout << "Max(i, j): " << Max(i, j) << endl; 
 
    double f1 = 13.5; 
    double f2 = 20.7; 
    cout << "Max(f1, f2): " << Max(f1, f2) << endl; 
 
    string s1 = "Hello"; 
    string s2 = "World"; 
    cout << "Max(s1, s2): " << Max(s1, s2) << endl; 
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c++
Max(i, j): 39
Max(f1, f2): 20.7
Max(s1, s2): World
```

#### 类模板

正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：

```c++
template <class type> class class-name {
.
.
.
}
```

在这里，**type** 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。

下面的实例定义了类 `Stack<>`，并实现了泛型方法来对元素进行入栈出栈操作：

```c++
#include <iostream>
#include <vector>
#include <cstdlib>
#include <string>
#include <stdexcept>
 
using namespace std;
 
template <class T>
class Stack { 
  private: 
    vector<T> elems;     // 元素 
 
  public: 
    void push(T const&);  // 入栈
    void pop();               // 出栈
    T top() const;            // 返回栈顶元素
    bool empty() const{       // 如果为空则返回真。
        return elems.empty(); 
    } 
}; 
 
template <class T>
void Stack<T>::push (T const& elem) 
{ 
    // 追加传入元素的副本
    elems.push_back(elem);    
} 
 
template <class T>
void Stack<T>::pop () 
{ 
    if (elems.empty()) { 
        throw out_of_range("Stack<>::pop(): empty stack"); 
    }
    // 删除最后一个元素
    elems.pop_back();         
} 
 
template <class T>
T Stack<T>::top () const 
{ 
    if (elems.empty()) { 
        throw out_of_range("Stack<>::top(): empty stack"); 
    }
    // 返回最后一个元素的副本 
    return elems.back();      
} 
 
int main() 
{ 
    try { 
        Stack<int>         intStack;  // int 类型的栈 
        Stack<string> stringStack;    // string 类型的栈 
 
        // 操作 int 类型的栈 
        intStack.push(7); 
        cout << intStack.top() <<endl; 
 
        // 操作 string 类型的栈 
        stringStack.push("hello"); 
        cout << stringStack.top() << std::endl; 
        stringStack.pop(); 
        stringStack.pop(); 
    } 
    catch (exception const& ex) { 
        cerr << "Exception: " << ex.what() <<endl; 
        return -1;
    } 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c++
7
hello
Exception: Stack<>::pop(): empty stack

```

#### typename 和 class 的区别

在 C++ Template 中很多地方都用到了 `typename` 与 `class` 这两个关键字，而且好像可以替换，是不是这两个关键字完全一样呢?

相信学习 C++ 的人对 `class` 这个关键字都非常明白，`class` 用于定义类，在模板引入 c++ 后，最初定义模板的方法为：


```c++
template<class T>......
```

这里 `class` 关键字表明T是一个类型，后来为了避免 `class` 在这两个地方的使用可能给人带来混淆，所以引入了 `typename` 这个关键字，它的作用同 `class` 一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了：

```c++
template<typename T>......
```

在模板定义语法中关键字 `class` 与 `typename` 的作用完全一样。

`typename` 难道仅仅在模板定义中起作用吗？其实不是这样，`typename` 另外一个作用为：使用**嵌套依赖类型**(nested depended name)，如下所示：

```c++
class MyArray 
{ 
    public：
    typedef int LengthType;
.....
}

template<class T>
void MyMethod( T myarr ) 
{ 
    typedef typename T::LengthType LengthType; 
    LengthType length = myarr.GetLength; 
}
```


这个时候 `typename` 的作用就是告诉 c++ 编译器，`typename` 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候如果前面没有 `typename`，编译器没有任何办法知道 `T::LengthType` 是一个类型还是一个成员名称(静态数据成员或者静态函数)，所以编译不能够通过。


#### 函数模板的重载

函数模板可以重载，只要它们的**形参表**不同即可。例如，下面两个模板可以同时存在：

```c++
template<class T1, class T2>
void print(T1 arg1, T2 arg2)
{
  cout<<arg1<<" "<<arg2<<endl; 
}
template<class T>
void print(T arg1, T arg2)
{
  cout<< arg1<< " "<< arg2<< endl;
}

```


## 预定义宏

C++ 提供了下表所示的一些预定义宏：

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g86e32km8ij30n6058dgi.jpg)

78让我们看看上述这些宏的实例：

```c++
#include <iostream>
using namespace std;
 
int main ()
{
    cout << "Value of __LINE__ : " << __LINE__ << endl;
    cout << "Value of __FILE__ : " << __FILE__ << endl;
    cout << "Value of __DATE__ : " << __DATE__ << endl;
    cout << "Value of __TIME__ : " << __TIME__ << endl;
 
    return 0;
}
```



当上面的代码被编译和执行时，它会产生下列结果：

```c++
Value of __LINE__ : 6
Value of __FILE__ : test.cpp
Value of __DATE__ : Feb 28 2011
Value of __TIME__ : 18:52:48
```


## 信号处理

信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 `Ctrl+C` 产生中断。

有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 `<csignal>` 中。

信号|	描述
----|-----
SIGABRT|	程序的异常终止，如调用 abort。
SIGFPE|	错误的算术运算，比如除以零或导致溢出的操作。
SIGILL|	检测非法指令。
SIGINT|	接收到交互注意信号。
SIGSEGV|	非法访问内存。
SIGTERM|	发送到程序的终止请求。

#### signal() 函数

C++ 信号处理库提供了 `signal` 函数，用来捕获突发事件。以下是 `signal()` 函数的语法：

```c++
void (*signal (int sig, void (*func)(int)))(int); 
```

这个函数接收两个参数：

- 第一个参数是一个整数，代表了信号的编号；

- 第二个参数是一个指向信号处理函数的指针。



让我们编写一个简单的 C++ 程序，使用 `signal()` 函数捕获 `SIGINT` 信号。不管您想在程序中捕获什么信号，您都必须使用 `signal `函数来注册信号，并将其与信号处理程序相关联。看看下面的实例：

```c++

#include <iostream>
#include <csignal>
#include <unistd.h>
 
using namespace std;
 
void signalHandler( int signum )
{
    cout << "Interrupt signal (" << signum << ") received.\n";
 
    // 清理并关闭
    // 终止程序  
 
   exit(signum);  
 
}
 
int main ()
{
    // 注册信号 SIGINT 和信号处理程序
    signal(SIGINT, signalHandler);  
 
    while(1){
       cout << "Going to sleep...." << endl;
       sleep(1);
    }
 
    return 0;
}
```


当上面的代码被编译和执行时，它会产生下列结果：

```c++
Going to sleep....
Going to sleep....
Going to sleep....
```


现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出：

```c++
Going to sleep....
Going to sleep....
Going to sleep....
Interrupt signal (2) received.
```

#### raise() 函数

您可以使用函数 `raise()` 生成信号，该函数带有一个整数信号编号作为参数，语法如下：

```c++
int raise (signal sig);
```

在这里，`sig` 是要发送的信号的编号，这些信号包括：**SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP**。以下是我们使用 `raise()` 函数内部生成信号的实例：

```c++
#include <iostream>
#include <csignal>
#include <unistd.h>
 
using namespace std;
 
void signalHandler( int signum )
{
    cout << "Interrupt signal (" << signum << ") received.\n";
 
    // 清理并关闭
    // 终止程序 
 
   exit(signum);  
 
}
 
int main ()
{
    int i = 0;
    // 注册信号 SIGINT 和信号处理程序
    signal(SIGINT, signalHandler);  
 
    while(++i){
       cout << "Going to sleep...." << endl;
       if( i == 3 ){
          raise( SIGINT);
       }
       sleep(1);
    }
 
    return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果，并会自动退出：

```c++
Going to sleep....
Going to sleep....
Going to sleep....
Interrupt signal (2) received.
```

#### Sleep 函数

- 功能：执行挂起一段时间，也就是等待一段时间在继续执行

- 用法：Sleep(时间)

> 注意：

> （1）Sleep是区分大小写的，有的编译器是大写，有的是小写。**Linux** 用 `#include <unistd.h>` 和 `sleep()`，**Windows** 用 `#include <windows.h>` 和 `Sleep()`。

> （2）Sleep括号里的时间，在windows下是已毫秒为单位，而LInux是已秒为单位

```c++
#include <iostream>
#include <windows.h>

using namespace std;

int main()
{
    int a = 1;
    while (a)
    {
        cout << "欢迎来到菜鸟教程！" << endl;
        Sleep(100);
    }
    system("pause");
    return 0;
}
```

## 多线程

多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：基于进程和基于线程。

- 基于进程的多任务处理是程序的并发执行。

- 基于线程的多任务处理是同一程序的片段的并发执行。

多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。

**POSIX Threads **或 **Pthreads** 提供的 API 可在多种类 **Unix POSIX** 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。

#### 创建线程

下面的程序，我们可以用它来创建一个 POSIX 线程：

```c++
#include <pthread.h>
pthread_create (thread, attr, start_routine, arg) 
```

在这里，`pthread_create` 创建一个新的线程，并让它可执行。下面是关于参数的说明：

参数|	描述
----|----
thread|	指向线程标识符指针。
attr|	一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。
start_routine|	线程运行函数起始地址，一旦线程被创建就会执行。
arg|	运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。


创建线程**成功**时，函数返回 **0**，若返回值**不为 0** 则说明**创建线程失败**。

#### 终止线程

使用下面的程序，我们可以用它来终止一个 POSIX 线程：

```c++
#include <pthread.h>
pthread_exit (status) 
```

在这里，`pthread_exit` 用于显式地退出一个线程。通常情况下，`pthread_exit()` 函数是在线程完成工作后无需继续存在时被调用。

如果 `main()` 是在它所创建的线程之前结束，并通过 `pthread_exit()` 退出，那么其他线程将继续执行。否则，它们将在 `main()` 结束时自动被终止。

以下简单的实例代码使用 `pthread_create()` 函数创建了 5 个线程，每个线程输出"**Hello Runoob！**":

```c++
#include <iostream>
// 必须的头文件
#include <pthread.h>
 
using namespace std;
 
#define NUM_THREADS 5
 
// 线程的运行函数
void* say_hello(void* args)
{
    cout << "Hello Runoob！" << endl;
    return 0;
}
 
int main()
{
    // 定义线程的 id 变量，多个变量使用数组
    pthread_t tids[NUM_THREADS];
    for(int i = 0; i < NUM_THREADS; ++i)
    {
        //参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数
        int ret = pthread_create(&tids[i], NULL, say_hello, NULL);
        if (ret != 0)
        {
           cout << "pthread_create error: error_code=" << ret << endl;
        }
    }
    //等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；
    pthread_exit(NULL);
}
```

使用 `-lpthread` 库编译下面的程序：

```c++
$ g++ test.cpp -lpthread -o test.o
```

现在，执行程序，将产生下列结果：

```c++
$ ./test.o
Hello Runoob！
Hello Runoob！
Hello Runoob！
Hello Runoob！
Hello Runoob！
```

以下简单的实例代码使用 `pthread_create()` 函数创建了 5 个线程，并接收传入的参数。每个线程打印一个 "**Hello Runoob!**" 消息，并输出接收的参数，然后调用 `pthread_exit()` 终止线程。

```c++
//文件名：test.cpp
 
#include <iostream>
#include <cstdlib>
#include <pthread.h>
 
using namespace std;
 
#define NUM_THREADS     5
 
void *PrintHello(void *threadid)
{  
   // 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取
   int tid = *((int*)threadid);
   cout << "Hello Runoob! 线程 ID, " << tid << endl;
   pthread_exit(NULL);
}
 
int main ()
{
   pthread_t threads[NUM_THREADS];
   int indexes[NUM_THREADS];// 用数组来保存i的值
   int rc;
   int i;
   for( i=0; i < NUM_THREADS; i++ ){      
      cout << "main() : 创建线程, " << i << endl;
      indexes[i] = i; //先保存i的值
      // 传入的时候必须强制转换为void* 类型，即无类型指针        
      rc = pthread_create(&threads[i], NULL, 
                          PrintHello, (void *)&(indexes[i]));
      if (rc){
         cout << "Error:无法创建线程," << rc << endl;
         exit(-1);
      }
   }
   pthread_exit(NULL);
}
```

现在编译并执行程序，将产生下列结果：

```c++
$ g++ test.cpp -lpthread -o test.o
$ ./test.o
main() : 创建线程, 0
main() : 创建线程, 1
Hello Runoob! 线程 ID, 0
main() : 创建线程, Hello Runoob! 线程 ID, 21

main() : 创建线程, 3
Hello Runoob! 线程 ID, 2
main() : 创建线程, 4
Hello Runoob! 线程 ID, 3
Hello Runoob! 线程 ID, 4
```

#### 向线程传递参数

这个实例演示了如何通过**结构**传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 `void`，如下面的实例所示：

```c++
#include <iostream>
#include <cstdlib>
#include <pthread.h>
 
using namespace std;
 
#define NUM_THREADS     5
 
struct thread_data{
   int  thread_id;
   char *message;
};
 
void *PrintHello(void *threadarg)
{
   struct thread_data *my_data;
 
   my_data = (struct thread_data *) threadarg;
 
   cout << "Thread ID : " << my_data->thread_id ;
   cout << " Message : " << my_data->message << endl;
 
   pthread_exit(NULL);
}
 
int main ()
{
   pthread_t threads[NUM_THREADS];
   struct thread_data td[NUM_THREADS];
   int rc;
   int i;
 
   for( i=0; i < NUM_THREADS; i++ ){
      cout <<"main() : creating thread, " << i << endl;
      td[i].thread_id = i;
      td[i].message = (char*)"This is message";
      rc = pthread_create(&threads[i], NULL,
                          PrintHello, (void *)&td[i]);
      if (rc){
         cout << "Error:unable to create thread," << rc << endl;
         exit(-1);
      }
   }
   pthread_exit(NULL);
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c++
$ g++ -Wno-write-strings test.cpp -lpthread -o test.o
$ ./test.o
main() : creating thread, 0
main() : creating thread, 1
Thread ID : 0 Message : This is message
main() : creating thread, Thread ID : 21
 Message : This is message
main() : creating thread, 3
Thread ID : 2 Message : This is message
main() : creating thread, 4
Thread ID : 3 Message : This is message
Thread ID : 4 Message : This is message
```

#### 连接和分离线程	

我们可以使用以下两个函数来连接或分离线程：

```c++
pthread_join (threadid, status) 
pthread_detach (threadid) 
```


`pthread_join()` 子程序阻碍调用程序，直到指定的 **threadid** 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是**可连接的（joinable）**或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。

这个实例演示了如何使用 `pthread_join()` 函数来等待线程的完成。

```c++
#include <iostream>
#include <cstdlib>
#include <pthread.h>
#include <unistd.h>
 
using namespace std;
 
#define NUM_THREADS     5
 
void *wait(void *t)
{
   int i;
   long tid;
 
   tid = (long)t;
 
   sleep(1);
   cout << "Sleeping in thread " << endl;
   cout << "Thread with id : " << tid << "  ...exiting " << endl;
   pthread_exit(NULL);
}
 
int main ()
{
   int rc;
   int i;
   pthread_t threads[NUM_THREADS];
   pthread_attr_t attr;
   void *status;
 
   // 初始化并设置线程为可连接的（joinable）
   pthread_attr_init(&attr);
   pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
 
   for( i=0; i < NUM_THREADS; i++ ){
      cout << "main() : creating thread, " << i << endl;
      rc = pthread_create(&threads[i], NULL, wait, (void *)&i );
      if (rc){
         cout << "Error:unable to create thread," << rc << endl;
         exit(-1);
      }
   }
 
   // 删除属性，并等待其他线程
   pthread_attr_destroy(&attr);
   for( i=0; i < NUM_THREADS; i++ ){
      rc = pthread_join(threads[i], &status);
      if (rc){
         cout << "Error:unable to join," << rc << endl;
         exit(-1);
      }
      cout << "Main: completed thread id :" << i ;
      cout << "  exiting with status :" << status << endl;
   }
 
   cout << "Main: program exiting." << endl;
   pthread_exit(NULL);
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c++
main() : creating thread, 0
main() : creating thread, 1
main() : creating thread, 2
main() : creating thread, 3
main() : creating thread, 4
Sleeping in thread 
Thread with id : 4  ...exiting 
Sleeping in thread 
Thread with id : 3  ...exiting 
Sleeping in thread 
Thread with id : 2  ...exiting 
Sleeping in thread 
Thread with id : 1  ...exiting 
Sleeping in thread 
Thread with id : 0  ...exiting 
Main: completed thread id :0  exiting with status :0
Main: completed thread id :1  exiting with status :0
Main: completed thread id :2  exiting with status :0
Main: completed thread id :3  exiting with status :0
Main: completed thread id :4  exiting with status :0
Main: program exiting.
```

> 要注意内存泄露问题。

> 如果设置为 `PTHREAD_CREATE_JOINABLE`，就继续用 `pthread_join()` 来等待和释放资源，否则会内存泄露。

#### c++ 11 之后标准的线程库：

```c++
#include <iostream>

#include <thread>

std::thread::id main_thread_id = std::this_thread::get_id();

void hello()  
{
    std::cout << "Hello Concurrent World\n";
    if (main_thread_id == std::this_thread::get_id())
        std::cout << "This is the main thread.\n";
    else
        std::cout << "This is not the main thread.\n";
}

void pause_thread(int n) {
    std::this_thread::sleep_for(std::chrono::seconds(n));
    std::cout << "pause of " << n << " seconds ended\n";
}

int main() {
    std::thread t(hello);
    std::cout << t.hardware_concurrency() << std::endl;//可以并发执行多少个(不准确)
    std::cout << "native_handle " << t.native_handle() << std::endl;//可以并发执行多少个(不准确)
    t.join();
    std::thread a(hello);
    a.detach();
    std::thread threads[5];                         // 默认构造线程

    std::cout << "Spawning 5 threads...\n";
    for (int i = 0; i < 5; ++i)
        threads[i] = std::thread(pause_thread, i + 1);   // move-assign threads
    std::cout << "Done spawning threads. Now waiting for them to join:\n";
    for (auto &thread : threads)
        thread.join();
    std::cout << "All threads joined!\n";
}
```

之前一些编译器使用 C++11 的编译参数是 `-std=c++11`:

```c++
g++ -std=c++11 test.cpp -lpthread
```


## Web 编程

#### 什么是 CGI？

- **公共网关接口**（CGI），是一套标准，定义了信息是如何在 **Web 服务器**和**客户端脚本**之间进行交换的。

- CGI 规范目前是由 **NCSA** 维护的，NCSA 定义 CGI 如下：

	- 公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。
	
	
- 目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。

#### Web 浏览

为了更好地了解 **CGI** 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。

- 您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。
- Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。
- Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。

然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。

公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 **Python、PERL、Shell、C 或 C++** 等进行编写。

#### CGI 架构图

下图演示了 CGI 的架构：

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g86ffnew1zg30bf0d5q2z.gif)

#### Web 服务器配置 

在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 `/var/www/cgi-bin`。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 `.cgi`。

默认情况下，Apache Web 服务器会配置在 `/var/www/cgi-bin` 中运行 CGI 程序。如果您想指定其他目录来运行 CGI 脚本，您可以在 `httpd.conf` 文件中修改以下部分：

```html
<Directory "/var/www/cgi-bin">
   AllowOverride None
   Options ExecCGI
   Order allow,deny
   Allow from all
</Directory>
 
<Directory "/var/www/cgi-bin">
Options All
</Directory>
```

在这里，我们假设已经配置好 Web 服务器并能成功运行，你可以运行任意的 CGI 程序，比如 Perl 或 Shell 等。


#### 第一个 CGI 程序

请看下面的 C++ 程序：

```c++
#include <iostream>
using namespace std;
 
int main ()
{
    
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>Hello World - 第一个 CGI 程序</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<h2>Hello World! 这是我的第一个 CGI 程序</h2>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
}
```

编译上面的代码，把可执行文件命名为 c`plusplus.cgi`，并把这个文件保存在` /var/www/cgi-bin` 目录中。在运行 CGI 程序之前，请使用 `chmod 755 cplusplus.cgi` UNIX 命令来修改文件模式，确保文件可执行。访问可执行文件，您会看到下面的输出：

```c++
Hello World! 这是我的第一个 CGI 程序
```

上面的 C++ 程序是一个简单的程序，把它的输出写在 `STDOUT` 文件上，即显示在屏幕上。在这里，值得注意一点，第一行输出 `Content-type:text/html\r\n\r\n`。这一行发送回浏览器，并指定要显示在浏览器窗口上的内容类型。您必须理解 CGI 的基本概念，这样才能进一步使用 Python 编写更多复杂的 CGI 程序。C++ CGI 程序可以与任何其他外部的系统（如 RDBMS）进行交互。

#### HTTP 头信息

行 `Content-type:text/html\r\n\r\n` 是 HTTP 头信息的组成部分，它被发送到浏览器，以便更好地理解页面内容。HTTP 头信息的形式如下：

```html
HTTP 字段名称: 字段内容
 
例如
Content-type: text/html\r\n\r\n
```

还有一些其他的重要的 HTTP 头信息，这些在您的 CGI 编程中都会经常被用到。



<div style= "width: 150px">头信息</div>  | 描述
---------------|------
Content-type: |		MIME 字符串，定义返回的文件格式。例如 Content-type:text/html。
Expires:Date	|	信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。
Location:URL	|	这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。
Last-modified:Date |		资源的最后修改日期。
Content-length:N |		要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。
Set-Cookie: String |		通过 string 设置 cookie。

#### CGI 环境变量

所有的 CGI 程序都可以访问下列的环境变量。这些变量在编写 CGI 程序时扮演了非常重要的角色。

变量名 | 描述
------|------
CONTENT_TYPE|	内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。
CONTENT_LENGTH|	查询的信息长度。只对 POST 请求可用。
HTTP_COOKIE|	以键 & 值对的形式返回设置的 cookies。
HTTP\_USER\_AGENT|	用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。
PATH_INFO|	CGI 脚本的路径。
QUERY_STRING|	通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。
REMOTE_ADDR|	发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。
REMOTE_HOST|	发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。
REQUEST_METHOD|	用于发出请求的方法。最常见的方法是 GET 和 POST。
SCRIPT_FILENAME|	CGI 脚本的完整路径。
SCRIPT_NAME|	CGI 脚本的名称。
SERVER_NAME|	服务器的主机名或 IP 地址。
SERVER_SOFTWARE|	服务器上运行的软件的名称和版本。


下面的 CGI 程序列出了所有的 CGI 变量。

```c++
#include <iostream>
#include <stdlib.h>
#include <string>
using namespace std;
 
const string ENV[ 24 ] = {                 
        "COMSPEC", "DOCUMENT_ROOT", "GATEWAY_INTERFACE",   
        "HTTP_ACCEPT", "HTTP_ACCEPT_ENCODING",             
        "HTTP_ACCEPT_LANGUAGE", "HTTP_CONNECTION",         
        "HTTP_HOST", "HTTP_USER_AGENT", "PATH",            
        "QUERY_STRING", "REMOTE_ADDR", "REMOTE_PORT",      
        "REQUEST_METHOD", "REQUEST_URI", "SCRIPT_FILENAME",
        "SCRIPT_NAME", "SERVER_ADDR", "SERVER_ADMIN",      
        "SERVER_NAME","SERVER_PORT","SERVER_PROTOCOL",     
        "SERVER_SIGNATURE","SERVER_SOFTWARE" };   
 
int main ()
{
    
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>CGI 环境变量</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<table border = \"0\" cellspacing = \"2\">";
 
   for ( int i = 0; i < 24; i++ )
   {
       cout << "<tr><td>" << ENV[ i ] << "</td><td>";
       // 尝试检索环境变量的值
       char *value = getenv( ENV[ i ].c_str() );  
       if ( value != 0 ){
         cout << value;                                 
       }else{
         cout << "环境变量不存在。";
       }
       cout << "</td></tr>\n";
   }
   cout << "</table><\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
}
```


#### C++ CGI 库

在真实的实例中，您需要通过 CGI 程序执行许多操作。这里有一个专为 C++ 程序而编写的 CGI 库，我们可以从 `ftp://ftp.gnu.org/gnu/cgicc/` 上下载这个 CGI 库，并按照下面的步骤安装库

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g86g0ljmcuj30eg069dhg.jpg)

```c++
$ tar xzf cgicc-X.X.X.tar.gz 
$ cd cgicc-X.X.X/ 
$ ./configure --prefix=/usr 
$ make
$ make install
```

> 注意：`libcgicc.so` 和 `libcgicc.a` 库会被安装到`/usr/lib`目录下，需执行拷贝命令：
> 
> ```
> $ sudo cp /usr/lib/libcgicc.* /usr/lib64/
> ```
> 
> 才能使 CGI 程序自动找到 `libcgicc.so` 动态链接库。


#### GET 和 POST 方法

您可能有遇到过这样的情况，当您需要从浏览器传递一些信息到 Web 服务器，最后再传到 CGI 程序。通常浏览器会使用两种方法把这个信息传到 Web 服务器，分别是 `GET` 和 `POST` 方法。

#### 使用 GET 方法传递信息

GET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过 `?` 字符分隔开，如下所示：

```c++
http://www.test.com/cgi-bin/cpp.cgi?key1=value1&key2=value2
```

GET 方法是默认的从浏览器向 Web 服务器传信息的方法，它会在浏览器的地址栏中生成一串很长的字符串。当您向服务器传密码或其他一些敏感信息时，不要使用 GET 方法。GET 方法有大小限制，在一个请求字符串中最多可以传 **1024** 个字符。

当使用 GET 方法时，是使用 `QUERY_STRING` http 头来传递信息，在 CGI 程序中可使用 `QUERY_STRING` 环境变量来访问。

您可以通过在 URL 后跟上简单连接的键值对，也可以通过使用 HTML `<FORM>` 标签的 GET 方法来传信息。

#### 简单的 URL 实例：Get 方法

下面是一个简单的 URL，使用 GET 方法传递两个值给 **hello_get.py** 程序。

`/cgi-bin/cpp_get.cgi?first_name=ZARA&last_name=ALI`

下面的实例生成 **cpp_get.cgi** CGI 程序，用于处理 Web 浏览器给出的输入。通过使用 C++ CGI 库，可以很容易地访问传递的信息：

```c++
#include <iostream>
#include <vector>  
#include <string>  
#include <stdio.h>  
#include <stdlib.h> 
 
#include <cgicc/CgiDefs.h> 
#include <cgicc/Cgicc.h> 
#include <cgicc/HTTPHTMLHeader.h> 
#include <cgicc/HTMLClasses.h>  
 
using namespace std;
using namespace cgicc;
 
int main ()
{
   Cgicc formData;
   
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>使用 GET 和 POST 方法</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
 
   form_iterator fi = formData.getElement("first_name");  
   if( !fi->isEmpty() && fi != (*formData).end()) {  
      cout << "名：" << **fi << endl;  
   }else{
      cout << "No text entered for first name" << endl;  
   }
   cout << "<br/>\n";
   fi = formData.getElement("last_name");  
   if( !fi->isEmpty() &&fi != (*formData).end()) {  
      cout << "姓：" << **fi << endl;  
   }else{
      cout << "No text entered for last name" << endl;  
   }
   cout << "<br/>\n";
 
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
}
```
现在，编译上面的程序，如下所示：

```c++
$g++ -o cpp_get.cgi cpp_get.cpp -lcgicc
```

生成 **cpp_get.cgi**，并把它放在 CGI 目录中，并尝试使用下面的链接进行访问：

`/cgi-bin/cpp_get.cgi?first_name=ZARA&last_name=ALI`

这会产生以下结果：

```
名：ZARA 
姓：ALI 
```


#### 简单的表单实例：GET 方法 

下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 CGI 脚本 **cpp_get.cgi** 来处理输入。

```html
<form action="/cgi-bin/cpp_get.cgi" method="get">
名：<input type="text" name="first_name">  <br />
 
姓：<input type="text" name="last_name" />
<input type="submit" value="提交" />
</form>
```



下面是上述表单的实际输出，请输入名和姓，然后点击提交按钮查看结果。

<form action="/cgi-bin/cpp_get.cgi" method="get">
名：<input type="text" name="first_name">  <br />
 
姓：<input type="text" name="last_name" />
<input type="submit" value="提交" />
</form>

#### 使用 POST 方法传递信息

一个更可靠的向 CGI 程序传递信息的方法是 `POST` 方法。这种方法打包信息的方式与 `GET` 方法相同，不同的是，它不是把信息以文本字符串形式放在 URL 中的 `?` 之后进行传递，而是把它以单独的消息形式进行传递。该消息是以标准输入的形式传给 CGI 脚本的。

我们同样使用 cpp_get.cgi 程序来处理 POST 方法。让我们以同样的例子，通过使用 HTML 表单和提交按钮来传递两个值，只不过这次我们使用的不是 GET 方法，而是 POST 方法，如下所示：

```html
<form action="/cgi-bin/cpp_get.cgi" method="post">
名：<input type="text" name="first_name"><br />
姓：<input type="text" name="last_name" />
 
<input type="submit" value="提交" />
</form>
```

#### 向 CGI 程序传递复选框数据
当需要选择多个选项时，我们使用**复选框。**

下面的 HTML 代码实例是一个带有两个复选框的表单：

```html
<form action="/cgi-bin/cpp_checkbox.cgi" 
         method="POST" 
         target="_blank">
<input type="checkbox" name="maths" value="on" /> 数学
<input type="checkbox" name="physics" value="on" /> 物理
<input type="submit" value="选择学科" />
</form>
```


下面的 C++ 程序会生成 **cpp_checkbox.cgi** 脚本，用于处理 Web 浏览器通过复选框给出的输入。

```c++
#include <iostream>
#include <vector>  
#include <string>  
#include <stdio.h>  
#include <stdlib.h> 
 
#include <cgicc/CgiDefs.h> 
#include <cgicc/Cgicc.h> 
#include <cgicc/HTTPHTMLHeader.h> 
#include <cgicc/HTMLClasses.h> 
 
using namespace std;
using namespace cgicc;
 
int main ()
{
   Cgicc formData;
   bool maths_flag, physics_flag;
 
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>向 CGI 程序传递复选框数据</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
 
   maths_flag = formData.queryCheckbox("maths");
   if( maths_flag ) {  
      cout << "Maths Flag: ON " << endl;  
   }else{
      cout << "Maths Flag: OFF " << endl;  
   }
   cout << "<br/>\n";
 
   physics_flag = formData.queryCheckbox("physics");
   if( physics_flag ) {  
      cout << "Physics Flag: ON " << endl;  
   }else{
      cout << "Physics Flag: OFF " << endl;  
   }
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
}
```

#### 向 CGI 程序传递单选按钮数据

当只需要选择一个选项时，我们使用单选按钮。

下面的 HTML 代码实例是一个带有两个单选按钮的表单：

```xml
<form action="/cgi-bin/cpp_radiobutton.cgi" 
         method="post" 
         target="_blank">
<input type="radio" name="subject" value="maths" 
                                    checked="checked"/> 数学 
<input type="radio" name="subject" value="physics" /> 物理
<input type="submit" value="选择学科" />
</form>
```




下面的 C++ 程序会生成 cpp_radiobutton.cgi 脚本，用于处理 Web 浏览器通过单选按钮给出的输入。

```c++
#include <iostream>
#include <vector>  
#include <string>  
#include <stdio.h>  
#include <stdlib.h> 
 
#include <cgicc/CgiDefs.h> 
#include <cgicc/Cgicc.h> 
#include <cgicc/HTTPHTMLHeader.h> 
#include <cgicc/HTMLClasses.h> 
 
using namespace std;
using namespace cgicc;
 
int main ()
{
   Cgicc formData;
  
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>向 CGI 程序传递单选按钮数据</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
 
   form_iterator fi = formData.getElement("subject");  
   if( !fi->isEmpty() && fi != (*formData).end()) {  
      cout << "Radio box selected: " << **fi << endl;  
   }
  
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
}
```

#### 向 CGI 程序传递文本区域数据

当需要向 CGI 程序传递多行文本时，我们使用 `TEXTAREA` 元素。

下面的 HTML 代码实例是一个带有 `TEXTAREA` 框的表单：

```
<!--<form action="/cgi-bin/cpp_textarea.cgi" 
         method="post" 
         target="_blank">
<textarea name="textcontent" cols="40" rows="4">
请在这里输入文本...
</textarea>
<input type="submit" value="提交" />
</form>-->
```


下面的 C++ 程序会生成 cpp_textarea.cgi 脚本，用于处理 Web 浏览器通过文本区域给出的输入。

```c++
#include <iostream>
#include <vector>  
#include <string>  
#include <stdio.h>  
#include <stdlib.h> 
 
#include <cgicc/CgiDefs.h> 
#include <cgicc/Cgicc.h> 
#include <cgicc/HTTPHTMLHeader.h> 
#include <cgicc/HTMLClasses.h> 
 
using namespace std;
using namespace cgicc;
 
int main ()
{
   Cgicc formData;
  
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>向 CGI 程序传递文本区域数据</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
 
   form_iterator fi = formData.getElement("textcontent");  
   if( !fi->isEmpty() && fi != (*formData).end()) {  
      cout << "Text Content: " << **fi << endl;  
   }else{
      cout << "No text entered" << endl;  
   }
  
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
   
```



#### 向 CGI 程序传递下拉框数据 

当有多个选项可用，但只能选择一个或两个选项时，我们使用下拉框。

下面的 HTML 代码实例是一个带有下拉框的表单：

```xml
<form action="/cgi-bin/cpp_dropdown.cgi" 
                       method="post" target="_blank">
<select name="dropdown">
<option value="Maths" selected>数学</option>
<option value="Physics">物理</option>
</select>
<input type="submit" value="提交"/>
</form>

```

下面的 C++ 程序会生成 cpp_dropdown.cgi 脚本，用于处理 Web 浏览器通过下拉框给出的输入。

```c++
#include <iostream>
#include <vector>  
#include <string>  
#include <stdio.h>  
#include <stdlib.h> 
 
#include <cgicc/CgiDefs.h> 
#include <cgicc/Cgicc.h> 
#include <cgicc/HTTPHTMLHeader.h> 
#include <cgicc/HTMLClasses.h> 
 
using namespace std;
using namespace cgicc;
 
int main ()
{
   Cgicc formData;
  
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>向 CGI 程序传递下拉框数据</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
 
   form_iterator fi = formData.getElement("dropdown");  
   if( !fi->isEmpty() && fi != (*formData).end()) {  
      cout << "Value Selected: " << **fi << endl;  
   }
  
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
}
```



#### 在 CGI 中使用 Cookies

HTTP 协议是一种无状态的协议。但对于一个商业网站，它需要在不同页面间保持会话信息。例如，一个用户在完成多个页面的步骤之后结束注册。但是，如何在所有网页中保持用户的会话信息。

在许多情况下，使用 **cookies** 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。

##### 它是如何工作的
服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的**硬盘**上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。

cookie 是一种纯文本的数据记录，带有 5 个可变长度的字段：

- Expires : cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。

- Domain : 网站的域名。

- Path : 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。

- Secure : 如果此字段包含单词 "secure"，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。

- Name=Value : cookie 以键值对的形式被设置和获取。

##### 设置 Cookies

向浏览器发送 cookies 是非常简单的。这些 cookies 会在 `Content-type` 字段之前，与 HTTP 头一起被发送。假设您想设置 UserID 和 Password 为 cookies，设置 cookies 的步骤如下所示：

```c++
#include <iostream>
using namespace std;
 
int main ()
{
 
   cout << "Set-Cookie:UserID=XYZ;\r\n";
   cout << "Set-Cookie:Password=XYZ123;\r\n";
   cout << "Set-Cookie:Domain=www.w3cschool.cc;\r\n";
   cout << "Set-Cookie:Path=/perl;\n";
   cout << "Content-type:text/html\r\n\r\n";
 
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>CGI 中的 Cookies</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
 
   cout << "设置 cookies" << endl;  
  
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
}
```


从这个实例中，我们了解了如何设置 cookies。我们使用 `Set-Cookie` HTTP 头来设置 cookies。

在这里，有一些设置 cookies 的属性是可选的，比如 `Expires`、`Domain` 和 `Pat`h。值得注意的是，cookies 是在发送行 `Content-type:text/html\r\n\r\n` 之前被设置的。

编译上面的程序，生成 **setcookies.cgi**，并尝试使用下面的链接设置 cookies。它会在您的计算机上设置四个 cookies：

`/cgi-bin/setcookies.cgi`

##### 获取 Cookies

检索所有设置的 cookies 是非常简单的。cookies 被存储在 CGI 环境变量 `HTTP_COOKIE` 中，且它们的形式如下：

```
key1=value1;key2=value2;key3=value3....
```

面的实例演示了如何获取 cookies。

```c++
#include <iostream>
#include <vector>  
#include <string>  
#include <stdio.h>  
#include <stdlib.h> 
 
#include <cgicc/CgiDefs.h> 
#include <cgicc/Cgicc.h> 
#include <cgicc/HTTPHTMLHeader.h> 
#include <cgicc/HTMLClasses.h>
 
using namespace std;
using namespace cgicc;
 
int main ()
{
   Cgicc cgi;
   const_cookie_iterator cci;
 
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>CGI 中的 Cookies</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<table border = \"0\" cellspacing = \"2\">";
   
   // 获取环境变量
   const CgiEnvironment& env = cgi.getEnvironment();
 
   for( cci = env.getCookieList().begin();
        cci != env.getCookieList().end(); 
        ++cci )
   {
      cout << "<tr><td>" << cci->getName() << "</td><td>";
      cout << cci->getValue();                                 
      cout << "</td></tr>\n";
   }
   cout << "</table><\n";
  
   cout << "<br/>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
}
```

现在，编译上面的程序，生成 **getcookies.cgi**，并尝试使用下面的链接获取您的计算机上所有可用的 cookies：

`/cgi-bin/getcookies.cgi`

这会产生一个列表，显示了上一节中设置的四个 cookies 以及您的计算机上所有其他的 cookies：

```
UserID XYZ 
Password XYZ123 
Domain www.w3cschool.cc 
Path /perl 
```


#### 文件上传实例
为了上传一个文件，HTML 表单必须把 enctype 属性设置为 `multipart/form-data`。带有文件类型的 input 标签会创建一个 "Browse" 按钮。




这段代码的结果是下面的表单：

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g86h0fnq3wj305x01la9y.jpg)

注意：上面的实例已经故意禁用了保存上传的文件在我们的服务器上。您可以在自己的服务器上尝试上面的代码。

下面是用于处理文件上传的脚本 **cpp_uploadfile.cpp**：

```c++
#include <iostream>
#include <vector>  
#include <string>  
#include <stdio.h>  
#include <stdlib.h> 
 
#include <cgicc/CgiDefs.h> 
#include <cgicc/Cgicc.h> 
#include <cgicc/HTTPHTMLHeader.h> 
#include <cgicc/HTMLClasses.h>
 
using namespace std;
using namespace cgicc;
 
int main ()
{
   Cgicc cgi;
 
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>CGI 中的文件上传</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
 
   // 获取要被上传的文件列表
   const_file_iterator file = cgi.getFile("userfile");
   if(file != cgi.getFiles().end()) {
      // 在 cout 中发送数据类型
      cout << HTTPContentHeader(file->getDataType());
      // 在 cout 中写入内容
      file->writeToStream(cout);
   }
   cout << "<文件上传成功>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
}
```

上面的实例是在 cout 流中写入内容，但您可以打开文件流，并把上传的文件内容保存在目标位置的某个文件中。


## STL 教程

在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。

C++ 标准模板库的核心包括以下三个组件：

组件    |	描述
-------|----
容器（Containers）|	容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。
算法（Algorithms）|	算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。
迭代器（iterators）|	迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。


这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。

下面的程序演示了**向量容器**（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求：

```c++
#include <iostream>
#include <vector>
using namespace std;
 
int main()
{
   // 创建一个向量存储 int
   vector<int> vec; 
   int i;
 
   // 显示 vec 的原始大小
   cout << "vector size = " << vec.size() << endl;
 
   // 推入 5 个值到向量中
   for(i = 0; i < 5; i++){
      vec.push_back(i);
   }
 
   // 显示 vec 扩展后的大小
   cout << "extended vector size = " << vec.size() << endl;
 
   // 访问向量中的 5 个值
   for(i = 0; i < 5; i++){
      cout << "value of vec [" << i << "] = " << vec[i] << endl;
   }
 
   // 使用迭代器 iterator 访问值
   vector<int>::iterator v = vec.begin();
   while( v != vec.end()) {
      cout << "value of v = " << *v << endl;
      v++;
   }
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c++
vector size = 0
extended vector size = 5
value of vec [0] = 0
value of vec [1] = 1
value of vec [2] = 2
value of vec [3] = 3
value of vec [4] = 4
value of v = 0
value of v = 1
value of v = 2
value of v = 3
value of v = 4
```

关于上面实例中所使用的各种函数，有几点要注意：

- `push_back( )` 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。

- `size( )` 函数显示向量的大小。

- `begin( )` 函数返回一个指向向量开头的迭代器。

- `end( )` 函数返回一个指向向量末尾的迭代器。

#### vector 的 capacity 和 size 属性区别

- `size` 是当前 vector 容器真实占用的大小，也就是容器当前拥有多少个容器。

- `capacity` 是指在发生 realloc 前能允许的最大元素数，即预分配的内存空间。

当然，这两个属性分别对应两个方法：`resize()` 和 `reserve()`。

- 使用 `resize()` 容器内的对象内存空间是真正存在的。

- 使用 `reserve()` 仅仅只是修改了 capacity 的值，容器内的对象并没有真实的内存空间(空间是"野"的)。

此时切记使用 [] 操作符访问容器内的对象，很可能出现数组越界的问题。

下面用例子进行说明：

```c++
#include <iostream>
#include <vector>

using std::vector;
int main(void)
{
    vector<int> v;
    std::cout<<"v.size() == " << v.size() << " v.capacity() = " << v.capacity() << std::endl;
    v.reserve(10);
    std::cout<<"v.size() == " << v.size() << " v.capacity() = " << v.capacity() << std::endl;
    v.resize(10);
    v.push_back(0);
    std::cout<<"v.size() == " << v.size() << " v.capacity() = " << v.capacity() << std::endl;

    return 0;
}
```

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g86hh78bmpj30hu0683yg.jpg)

注： 对于 `reserve(10)` 后接着直接使用 `[]` 访问越界报错(内存是野的)，大家可以加一行代码试一下，我这里没有贴出来。

这里直接用`[]`访问，vector 退化为数组，不会进行越界的判断。此时推荐使用 `at()`，会先进行越界检查。

相关引申：

针对 capacity 这个属性，STL 中的其他容器，如 **list map set deque**，由于这些容器的内存是散列分布的，因此不会发生类似 `realloc()` 的调用情况，因此我们可以认为 `capacity` 属性针对这些容器是没有意义的，因此设计时这些容器没有该属性。

在 STL 中，拥有 `capacity` 属性的容器只有 `vector`和 `string`。



## 标准库

C++ 标准库可以分为两部分：

- 标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。

- 面向对象类库： 这个库是类及其相关函数的集合。

C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改

#### 标准函数库

标准函数库分为以下几类：

- 输入/输出 I/O
- 字符串和字符处理
- 数学
- 时间、日期和本地化
- 动态分配
- 其他
- 宽字符函数

#### 面向对象类库
标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容：

- 标准的 C++ I/O 类
- String 类
- 数值类
- STL 容器类
- STL 算法
- STL 函数对象
- STL 迭代器
- STL 分配器
- 本地化库
- 异常处理类
- 杂项支持库













