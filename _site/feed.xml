<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Luo's Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 26 Sep 2019 11:39:17 +0000</pubDate>
    <lastBuildDate>Thu, 26 Sep 2019 11:39:17 +0000</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>NSStackView翻译</title>
        <description>&lt;h1 id=&quot;nsstackview翻译&quot;&gt;NSStackView翻译&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;stackView可以水平或垂直方向来管理一组视图，自动更新它们放置的位置并且在窗口大小变化时变化大小。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;stackview使用自动布局（系统的自动布局特性）来根据你的要求管理和对齐一组视图。要想高效使用stackview，你需要理解自动布局约束的基础，这在《Auto Layout Guide》中有描述。&lt;/p&gt;

&lt;h3 id=&quot;stackview的基本特性&quot;&gt;stackview的基本特性&lt;/h3&gt;
&lt;p&gt;stackview支持水平和垂直方向的布局，并且在窗口大小变化和Cocoa动画时自动发生作用。你可以在运行时简单配置stackview的内容。也就是说，当你在IB中创建和配置stackview后你可以动态的添加或者删除视图，而不用显式地使用布局约束。比如说，如果你给一个stackview设置了3个checkbox，并且动态地增加第四个，stackview会根据自身属性的设置，自动根据需要添加约束。新的checkbox会从stackview那获得动态的布局设置(约束)。&lt;/p&gt;

&lt;p&gt;stackview是可以嵌套的，一个stackview在另一个stackview的一组视图中也是一个有效的元素。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h6 id=&quot;要点&quot;&gt;要点&lt;/h6&gt;
  &lt;blockquote&gt;
    &lt;p&gt;不要对stackview的私有视图添加自视图或者约束。stackview的私有视图可能会在未来macOS版本中改变，并且不确保会支持NSCoder编码解码(encoded or decoded).&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;布局方向和重力区域&quot;&gt;布局方向和重力区域&lt;/h3&gt;
&lt;p&gt;一个stackview有3个所谓的重力区域，每个区域分别标识堆栈视图布局的一部分。一个水平方向的stackview(默认类型)
，有一个前向的，一个中间的(不一定是左、中、右)，一个后向的重力区域。这些区域的顺序取决于stackview的userInterfaceLayoutDirection属性(继承自NSView)。在左至右的语言中，水平stackview的前向重力区域位于左侧。为了独立于语言强制从左到右布局，需要在你的stackview实例中显式的调用userInterfaceLayoutDirection方法。&lt;/p&gt;

&lt;p&gt;对于垂直布局，就是用orientation属性为NSUserInterfaceLayoutOrientationVertical(来自枚举NSUserInterfaceLayoutOrientation)。在一个垂直的stackview中，重力区域的分是上、中、下。&lt;/p&gt;

&lt;h3 id=&quot;视图分离和隐藏&quot;&gt;视图分离和隐藏&lt;/h3&gt;

&lt;p&gt;stackview会自动分离或者重新固定它的视图以响应布局的变化，比如由用户发起的窗口大小重变化，或者在相同的视图层次结构中调整或重新定位另一个视图。处于分离状态的视图不会出现在stackview的视图层级中，但是它仍然消耗占用内存。&lt;/p&gt;

&lt;p&gt;为了允许视图分离，需要设置stackview所谓的clipping resistance(剪切阻力)的值低于默认值NSLayoutPriorityRequired。详情见setClippingResistancePriority:forOrientation:方法。&lt;/p&gt;

&lt;p&gt;你可以影响哪个视图首先分离(并且最后重新连接)。通过设置所谓的visibility属性给每个你想要指定分离顺序的视图。一个visibility属性值较低的视图会比一个值较高的视图先 分离，并且重连接也在其之后。详情见NSStackViewVisibilityPriority枚举和setVisibilityPriority:forView: 方法。&lt;/p&gt;

&lt;p&gt;要显示的将一个视图从stackview中分离，可以调用setVisibilityPriority:forView: 方法并给一个NSStackViewVisibilityPriorityNotVisible值。要显式重连接一个视图到stackview，还是调用这个方法，并给一个NSStackViewVisibilityPriorityMustHold值。如果你隐藏一个属于stackview的视图(通过调用视图的hidden方法，并给YES值)，视图并不会从stackview分离。他不再可见，也不再接受输入时间，但是它任然是视图层级的一部分，并会继续参与自动布局。&lt;/p&gt;

&lt;p&gt;当一个视图将要被分离或者被重连接时，系统会调用stackview的代理方法，来给你时机在那瞬间运行代码。详情见NSStackViewDelegate。&lt;/p&gt;

&lt;h2 id=&quot;主题&quot;&gt;主题&lt;/h2&gt;

&lt;h3 id=&quot;初始化一个stackview&quot;&gt;初始化一个stackview&lt;/h3&gt;
&lt;h4 id=&quot;-stackviewwithviews&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ stackViewWithViews:&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;用一个特定的视图数组来创建并返回一个stackview&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;响应stack相关的变化&quot;&gt;响应stack相关的变化&lt;/h3&gt;

&lt;h4 id=&quot;delegate&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;stackview 的代理对象&lt;/p&gt;
&lt;h4 id=&quot;nsstackviewdelegate&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSStackViewDelegate&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;要想设置一个自定义类来响应视图的分离或重连解到stackview，设置这个自定义类遵循NSStackViewDelegate协议。然后设置stackview的delegata为你的自定义类对象。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;创建和设置一个stackview&quot;&gt;创建和设置一个stackview&lt;/h3&gt;
&lt;h4 id=&quot;--setviewsingravity&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- setViews:inGravity:&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;给一个stackview的特定重力区域设置一组视图，替换之前这个重力区域之前的所有视图。&lt;/p&gt;

&lt;h4 id=&quot;alignment&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;alignment&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;stackview内部的视图对齐方式&lt;/p&gt;

&lt;h4 id=&quot;orientation&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;orientation&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;stackview的水平或者垂直布局方向&lt;/p&gt;

&lt;h4 id=&quot;spacing&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spacing&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;stackview中相邻视图的最小间距，以像素点为单位&lt;/p&gt;

&lt;h4 id=&quot;edgeinsets&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;edgeInsets&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;stackview内部的填充间距，环绕它的所有view，以像素点为单位&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;设置stackview的动态行为&quot;&gt;设置stackview的动态行为&lt;/h3&gt;
&lt;h4 id=&quot;--setclippingresistancepriorityfororientation&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- setClippingResistancePriority:forOrientation:&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;当自动布局试图减少stackview的大小时，设置自动布局优先级，以便在stackview中防止子视图的裁剪。&lt;/p&gt;

&lt;h4 id=&quot;--sethuggingpriorityfororientation&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- setHuggingPriority:forOrientation:&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;设置堆栈视图的自动布局优先级，以最小化它的大小，为指定的用户界面坐标轴。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;添加或移除子视图&quot;&gt;添加或移除子视图&lt;/h3&gt;
&lt;h4 id=&quot;--addviewingravity&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- addView:inGravity:&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;在当前stackview重力区域后面，添加一个视图到重力区域&lt;/p&gt;

&lt;h4 id=&quot;--insertviewatindexingravity&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- insertView:atIndex:inGravity:&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;在指定下标位置天机一个视图到stackview重力区域&lt;/p&gt;

&lt;h4 id=&quot;--removeview&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- removeView:&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;从stackview中移除一个特定的视图&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;在stackview中设置视图&quot;&gt;在stackview中设置视图&lt;/h3&gt;
&lt;h4 id=&quot;--customspacingafterview&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- customSpacingAfterView:&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;返回特定视图和它后一个视图的间距，以像素点为单位&lt;/p&gt;

&lt;h4 id=&quot;--setcustomspacingafterview&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- setCustomSpacing:afterView:&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;指定特定视图和它后一个视图的间距，以像素点为单位&lt;/p&gt;

&lt;h4 id=&quot;--visibilitypriorityforview&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- visibilityPriorityForView:&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;返回特定视图的可见优先级( visibility priority )&lt;/p&gt;

&lt;h4 id=&quot;--setvisibilitypriorityforview&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- setVisibilityPriority:forView:&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;设置一个视图的自动布局优先级以在自动布局减少stackview大小时保持和stackview的连接&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;检查stackview&quot;&gt;检查stackview&lt;/h3&gt;
&lt;h4 id=&quot;views&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;views&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;stackview拥有的一组视图&lt;/p&gt;

&lt;h4 id=&quot;--viewsingravity&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- viewsInGravity:&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;返回stackview中特定重力区域的视图数组&lt;/p&gt;

&lt;h4 id=&quot;detachedviews&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;detachedViews&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;返回已经从stackview所有重力区域分离的视图数组&lt;/p&gt;

&lt;h4 id=&quot;--clippingresistancepriorityfororientation&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- clippingResistancePriorityForOrientation:&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;返回当自动布局试图减少stackview的大小时，为在stackview中拒绝裁剪视图的自动布局优先级&lt;/p&gt;

&lt;h4 id=&quot;--huggingpriorityfororientation&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- huggingPriorityForOrientation:&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;返回stackview为一个用户界面坐标轴最小化大小来尽可能适应所有包含的视图时的自动布局优先级&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;常量&quot;&gt;常量&lt;/h3&gt;
&lt;h4 id=&quot;nsuserinterfacelayoutorientation&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSUserInterfaceLayoutOrientation&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;两个stackview布局方向，对于剪切阻力和hugging优先级，是两个用户界面坐标轴&lt;/p&gt;
&lt;h4 id=&quot;nsstackviewgravity&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSStackViewGravity&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;在stackview中可用的各种重力区域&lt;/p&gt;

&lt;h4 id=&quot;nsstackviewvisibilitypriority&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSStackViewVisibilityPriority&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;为视图在stackview中保持连接的各种自动布局优先级。&lt;/p&gt;

&lt;h4 id=&quot;nsstackviewspacingusedefault&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSStackViewSpacingUseDefault&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;在stackview中的每个视图后面指定默认间距的标志&lt;/p&gt;

&lt;p&gt;原文链接&lt;/p&gt;

&lt;p&gt;https://developer.apple.com/library/mac/documentation/AppKit/Reference/NSStackView_Class/Chapters/Reference.html&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Sep 2019 22:38:02 +0000</pubDate>
        <link>http://localhost:4000/2019/09/19/NSStackView%E7%BF%BB%E8%AF%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/19/NSStackView%E7%BF%BB%E8%AF%91/</guid>
        
        <category>翻译</category>
        
        <category>Cocoa</category>
        
        
      </item>
    
      <item>
        <title>NSGridView翻译</title>
        <description>&lt;h1 id=&quot;nsgridview-翻译&quot;&gt;NSGridView 翻译&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;网格视图，一个能在一个灵活的行列网格中对齐视图的容器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@interface NSGridView : NSView

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;

&lt;p&gt;网格视图可帮助您以类似于电子表格的行列排列方式布置内容，例如照片或缩略图。 在网格视图中，占用单个行 - 列交集的项由NSGridCell对象表示。&lt;/p&gt;

&lt;h3 id=&quot;话题&quot;&gt;话题&lt;/h3&gt;

&lt;h2 id=&quot;创建一个gridview&quot;&gt;创建一个GridView&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ gridViewWithNumberOfColumns:rows:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;创建具有指定列数和行数的新分配的网格视图对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ gridViewWithViews:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;使用指定的视图数组数组创建新分配的网格视图对象。
此方法创建一个自动释放的网格视图，其大小足以容纳传递的行数组。 数组中的每个元素本身都是该行的视图数组。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- initWithFrame:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;使用指定的框架矩形创建新分配的网格视图对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- initWithCoder:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;从编码器创建新分配的网格视图对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;获取网格信息&quot;&gt;获取网格信息&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;numberOfRows&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;行数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;numberOfColumns&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;列数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- indexOfColumn:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;返回指定列的索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- rowAtIndex:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;返回指定索引所在的行对象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- columnAtIndex:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;返回指定索引所在的列对象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- indexOfRow:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;返回指定行的索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;添加删除移动行&quot;&gt;添加、删除、移动行&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- addRowWithViews:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;添加一组视图到一个新的行。
你可以在girdview里动态的插入或者移除行和列。网格会根据需要放大以保留指定的视图。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- insertRowAtIndex:withViews:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;将视图对象数组插入索引处的网格视图中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- removeRowAtIndex:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;从索引处的网格视图中删除行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- moveRowAtIndex:toIndex:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;将指定的行移动到新的行位置。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;添加删除移动列&quot;&gt;添加、删除、移动列&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- addColumnWithViews:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;添加包含视图数组的新列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- insertColumnAtIndex:withViews:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;在指定的索引处插入视图对象数组。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- removeColumnAtIndex:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;从指定索引处的网格视图中删除列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- moveColumnAtIndex:toIndex:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;将指定列移动到新列位置。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;管理网格间距和对齐&quot;&gt;管理网格间距和对齐&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSGridViewSizeForContent &lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;行和列大小的默认值。
此常量表示行或列应自动适合内容视图。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;columnSpacing&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;网格视图的列间距。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rowSpacing&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;网格视图的行间距。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rowAlignment&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;网格视图的行对齐方式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xPlacement&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;单元格在网格列中的位置。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yPlacement&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;单元格在网格行中的位置。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;创建合并单元格&quot;&gt;创建、合并单元格&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- cellAtColumnIndex:rowIndex:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;返回指定列和行索引处的网格单元对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- cellForView:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;返回包含给定视图或其祖先之一的网格单元对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- mergeCellsInHorizontalRange:verticalRange:&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;在单元格左上角进行水平和垂直范围内进行扩展以包含整个区域&lt;/p&gt;

  &lt;p&gt;此函数使范围中的其他单元格无效，并且它们不再维护其布局，约束或内容视图。 单元格合并对网格视图的基本单元坐标系没有影响，合并区域内的单元格引用指的是单个合并单元格。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在安装视图之前，使用此方法配置网格几何体。 如果要合并的单元格包含内容视图，则仅保留最顶层的视图。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 19 Sep 2019 22:38:02 +0000</pubDate>
        <link>http://localhost:4000/2019/09/19/NSGridView-%E7%BF%BB%E8%AF%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/19/NSGridView-%E7%BF%BB%E8%AF%91/</guid>
        
        <category>翻译</category>
        
        <category>Cocoa</category>
        
        
      </item>
    
      <item>
        <title>一种让NSImageView能响应点击的方法</title>
        <description>&lt;p&gt;NSImageView是无法响应点击事件的，即使你连了IBAction也无法响应。&lt;/p&gt;

&lt;p&gt;但是有时我们需要它支持响应点击事件，比如在做聊天消息的Cell时，用ImageView来放一个头像，我们需要点击头像来弹出一个好友的信息框。当然这个例子举的不好，这个头像完全可以用一个NSButton的image来显示，同时又能响应点击。。&lt;/p&gt;

&lt;p&gt;在这儿咱们就事论事，谈论怎么给NSImageView加上点击事件。&lt;/p&gt;

&lt;p&gt;我们可以子类化NSImageView然后覆盖他的mouseDown：方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;#import &quot;LYImageView.h&quot;

@implementation LYImageView


//让imageview能够相应点击方法
- (void)mouseDown:(NSEvent *)event {
    [super mouseDown:event];
    [NSApp sendAction:@selector(clicked:) to:self from:self];
}

- (void)clicked:(id)sender {
  NSLog(@&quot;Clicked!!!!&quot;);

//此处可以实现一些默认的点击事件处理，但是对于外部无法自定义点击事件的处理方式
//可以考虑在外部使用方法交换来实现
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然如注释所说，这样做也是有局限性的，外部无法自定义点击事件。&lt;/p&gt;

&lt;p&gt;如果有更好的方案，欢迎回复评论，请不吝赐教~&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Sep 2019 00:38:02 +0000</pubDate>
        <link>http://localhost:4000/2019/09/18/%E4%B8%80%E7%A7%8D%E8%AE%A9NSImageView%E8%83%BD%E5%93%8D%E5%BA%94%E7%82%B9%E5%87%BB%E7%9A%84%E6%96%B9%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/18/%E4%B8%80%E7%A7%8D%E8%AE%A9NSImageView%E8%83%BD%E5%93%8D%E5%BA%94%E7%82%B9%E5%87%BB%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
        
        <category>macOS</category>
        
        <category>Cocoa</category>
        
        
      </item>
    
      <item>
        <title>macOS图形性能调试工具Quartz Debug</title>
        <description>&lt;p&gt;在macOS上有个专门来调试图形性能的工具，叫做，Quartz Debug 。它存在于一个叫做Additional_Tools_for_Xcode的扩展工具包中，每个xcode版本都有对应的扩展工具包dmg，如xcode10.1，需要下载Additional_Tools_for_Xcode_10.1，可以在&lt;a href=&quot;https://developer.apple.com/download/more/&quot;&gt;这里&lt;/a&gt;下载到。本文主要内容参考《&lt;a href=&quot;http://www.broadview.com.cn/book/4920&quot;&gt;iOS和macOS性能优化：Cocoa、Cocoa Touch、Objective-C和Swift&lt;/a&gt;》，Quartz Debug提供了许多工具来帮助您调试应用程序中与图形相关的问题。下面讨论Quartz调试的特性。&lt;/p&gt;

&lt;h2 id=&quot;quartz-debug-settings&quot;&gt;Quartz Debug Settings&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72pgm6aouj30ce0pp760.jpg&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用此面板切换常用加速和调试选项。提供以下选择:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Enable Quartz Debug&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;启用/禁用所有选项。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Disable 2D Acceleration&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;禁用所有2D加速。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
所谓2D加速是指2D图形硬件加速，即开启GPU。强制进行GPU渲染，指的是在CPU性能不足或者想要节省CPU资源的情况下，强制系统使用GPU对系统和软件的UI进行渲染，由于在图形方面GPU相比CPU具有天然优势，所以此情况下使用GPU渲染会得到更加流畅的界面体验；
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Autoflush drawing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每次绘图操作后刷新内容。
会关闭合并内存的访问模式，所以每个绘制操作都会直接展示在屏幕上(如果开启Flash identical screen updates和Flash screen updates2个选项，可能会造成闪烁)，这会产生更多的干扰信息，但是这样会将绘制过程划分的更细，展示的矩形越多，就越能让开发者了解系统是如何绘制的以及绘制过程发生了哪些变化。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Flash screen updates&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在屏幕区域更新之前用黄色高亮显示(正常)。DisableUpdate下的区域被涂成橙色。
该选项能让你区分出那些刷新次数过于频繁的地方。打开该选项可能会产生一些干扰数据。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Flash identical screen updates&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用红色高亮显示冗余屏幕更新。冗余更新是指重新绘制未更改像素的情况。&lt;/p&gt;

&lt;p&gt;开启该选项后，Quartz会用红色矩形块标注屏幕中重复刷新相同内容的区域，这表示红色区块的绘制操作是多余的，应该被删除。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;No delay after flash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;移除闪烁屏幕更新后的延迟。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Show tracking rectangles&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;跟踪矩形用绿色表示。活动跟踪矩形的轮廓是红色的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Vertical Sync&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;切换垂直波束同步开关的窗口服务器屏幕更新。&lt;/p&gt;

&lt;h2 id=&quot;ui-resolution&quot;&gt;UI Resolution&lt;/h2&gt;

&lt;p&gt;UI解析窗口允许控制用于用户界面的当前缩放因子。设置完成后，将立即向Dock应用新的分辨率，但是应用程序需要重新启动才能获取新的设置。&lt;/p&gt;

&lt;h2 id=&quot;framemeter&quot;&gt;Framemeter&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72phwve73j30fl0ddwex.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;帧表显示每秒屏幕更新的次数。还显示了CPU使用情况。帧表输出也可以在Quartz Debug Dock图标中获得。&lt;/p&gt;

&lt;h2 id=&quot;dock-icon&quot;&gt;Dock Icon&lt;/h2&gt;

&lt;p&gt;可以将dock图标配置为显示帧表和石英状态。右键单击dock图标或选择Tools -&amp;gt; dock来配置这些选项&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Show Framemeter History&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;帧速率绘制在每秒更新10次的图形上，并显示在dock中应用程序图标的位置。该图由当前FPS读取值着色，红线表示更新速率为0……一条黄线31……一条绿线61……90 fps。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;应该注意，随着Quartz Debug的运行，应用程序与平常的运行状态有一点区别，绘制这些额外的矩形会造成不小的开销，你甚至可以感觉到屏幕在刷新的过程中有一些延迟。开启一个Flash选项，然后尝试拖拽窗口，这时不仅能看到有很多闪烁效果，拖拽的过程也变的很迟钝。关闭延迟能让性能恢复正常，但闪烁会导致肉眼难以识别屏幕上的情况。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;参考资料：
《&lt;a href=&quot;http://www.broadview.com.cn/book/4920&quot;&gt;iOS和macOS性能优化：Cocoa、Cocoa Touch、Objective-C和Swift&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;《Quartz Debug 4.0 Help(位于Quartz Debug 的help中)》&lt;/p&gt;
</description>
        <pubDate>Tue, 17 Sep 2019 18:50:02 +0000</pubDate>
        <link>http://localhost:4000/2019/09/17/macOS%E5%9B%BE%E5%BD%A2%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7Quartz-Debug/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/17/macOS%E5%9B%BE%E5%BD%A2%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7Quartz-Debug/</guid>
        
        <category>macOS</category>
        
        <category>Cocoa</category>
        
        <category>图形</category>
        
        
      </item>
    
      <item>
        <title>《kindle drm removal》 kindle电子书去除DRM的另一个工具</title>
        <description>&lt;p&gt;介绍如何去除DRM的方法，网上不胜枚举，我就不详细介绍了。主要是昨天尝试了网上的方法，使用《&lt;a href=&quot;[https://github.com/apprenticeharper/DeDRM_tools/releases/tag/v6.5.5](https://github.com/apprenticeharper/DeDRM_tools/releases/tag/v6.5.5)&quot;&gt;DeDRM&lt;/a&gt;》这个软件来去除DRM，每次都执行成功，但是真正用《&lt;a href=&quot;[http://calibre-ebook.com/download](http://calibre-ebook.com/download)&quot;&gt;calibre&lt;/a&gt;》来转换格式的时候却又报错&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72pbnyehzj30nm0d0q5i.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看着像是并没有成功解锁DRM。试了好几次都是如此。于是尝试寻求其他去除DRM限制的工具。最后发现了《&lt;a href=&quot;https://mac-kindle-drm-removal.en.softonic.com/mac&quot;&gt;kindle-drm-removal-for-mac&lt;/a&gt;》，使用很简单，提示导入电子书后，点击转换，最后提示解锁DRM成功。然后将去掉DRM的&lt;strong&gt;axw3&lt;/strong&gt;电子书使用calibre转换成pdf，最后转换成功。转换成功后的书名，有的会加上&lt;strong&gt;nodrm&lt;/strong&gt;后缀，如《iOS和macOS性能优化：Cocoa、Cocoa Touch、Objective-C和Swift_nodrm.pdf》&lt;/p&gt;

&lt;p&gt;参考链接：
《&lt;a href=&quot;https://www.jianshu.com/p/7e2bfacaba37&quot;&gt;Calibre和DeDrm插件破解亚马逊azw格式电子书&lt;/a&gt;》&lt;/p&gt;
</description>
        <pubDate>Tue, 17 Sep 2019 18:39:02 +0000</pubDate>
        <link>http://localhost:4000/2019/09/17/kindle-drm-removal-kindle%E7%94%B5%E5%AD%90%E4%B9%A6%E5%8E%BB%E9%99%A4DRM%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%85%B7/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/17/kindle-drm-removal-kindle%E7%94%B5%E5%AD%90%E4%B9%A6%E5%8E%BB%E9%99%A4DRM%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%85%B7/</guid>
        
        <category>Kindle</category>
        
        <category>电子产品</category>
        
        
      </item>
    
      <item>
        <title>NSThread翻译</title>
        <description>&lt;h1 id=&quot;nsthread&quot;&gt;NSThread&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个执行的线程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;当你想让一个OC方法在它自己的执行线程中运行的时候，可以用这个类。当你想执行一个冗长任务，但不希望阻塞程序其余部分的执行的时候，线程显得特别有用。特别是你可以用线程来避免阻塞主线程(处理用户界面和事件相关动作)。线程还可以用来将一个大的工作划分为几个较小的工作，这将导致多核计算机的性能增加。&lt;/p&gt;

&lt;p&gt;NSThread 类支持和NSOperation类似的用来监控一个线程运行时条件的语义。你可以用这些语义来取消一个线程的执行或者决定线程是否继续执行还是完成当前任务。取消一个线程需要你的线程代码支持。详情见cancel方法的描述。&lt;/p&gt;

&lt;h1 id=&quot;子类化的注意点&quot;&gt;子类化的注意点&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;你可以子类化NSThread并重载&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;方法来实现你的线程的主要入口点。如果你重载&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;方法，就不需要调用&lt;code class=&quot;highlighter-rouge&quot;&gt;super&lt;/code&gt;来调用继承而来的行为。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;话题&quot;&gt;话题&lt;/h1&gt;
&lt;h3 id=&quot;初始化一个nsthread对象&quot;&gt;初始化一个NSThread对象&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- init&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;返回一个初始化的 NSThread 对象&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- initWithTarget:selector:object:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;返回一个用给定参数初始化的 NSThread 对象&lt;/p&gt;

&lt;h3 id=&quot;启动一个线程&quot;&gt;启动一个线程&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ detachNewThreadSelector:toTarget:withObject:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;派发一个新线程并使用给定的selector作为线程的入口点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- start&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开启接收方(线程对象)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- main&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程的主要入口点&lt;/p&gt;

&lt;h3 id=&quot;停止一个线程&quot;&gt;#停止一个线程&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ sleepUntilDate:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;阻塞当前线程知道指定的时间到了&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ sleepForTimeInterval:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使线程在给定的时间内睡眠&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ exit&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;终止当前线程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- cancel&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更改接收者(线程)的取消状态，以指示它应该退出(exit)&lt;/p&gt;

&lt;h3 id=&quot;确定线程的执行状态&quot;&gt;确定线程的执行状态&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;executing&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个布尔值，指示接受者(线程)是否正在执行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;finished&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个布尔值，指示接受者(线程)是否已完成执行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cancelled&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个布尔值，指示接受者(线程)是否已被取消&lt;/p&gt;

&lt;h3 id=&quot;与主线程工作&quot;&gt;与主线程工作&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;isMainThread&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个布尔值，指示是否当前线程是主线程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mainThread&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;返回代表主线程的 NSThread 对象&lt;/p&gt;

&lt;h3 id=&quot;查询当前线程环境&quot;&gt;查询当前线程环境&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ isMultiThreaded&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;返回是否程序是多线程的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;currentThread&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;返回代表当前执行线程的 NSThread 对象&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callStackReturnAddresses&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;返回包含调用堆栈返回地址的数组&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callStackSymbols&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;返回包含调用堆栈符号的数组&lt;/p&gt;

&lt;h3 id=&quot;与线程属性工作&quot;&gt;与线程属性工作&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;threadDictionary&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程对象的字典&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSAssertionHandlerKey&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接受者(线程)的名字&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stackSize&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接受者(线程)的堆栈大小，以字节为单位&lt;/p&gt;

&lt;h3 id=&quot;线程工作的优先级&quot;&gt;线程工作的优先级&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;qualityOfService&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSQualityOfService&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用于指示系统工作的性质和重要性。在资源争用的情况下，高质量的服务类的工作比低质量的服务类工作接受的资源要多。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ threadPriority&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;返回当前线程的优先级&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;threadPriority&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接受者(线程)的优先级&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ setThreadPriority:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;设置当前线程的优先级&lt;/p&gt;

&lt;h3 id=&quot;通知&quot;&gt;通知&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSDidBecomeSingleThreadedNotification&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;已变成单线程？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSThreadWillExitNotification&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当线程接收到exit消息，并在线程退出之前，NSThread对象会发出这个通知。在线程退出之前，被调用以接受这个消息的观察者方法会在将要退出的线程中执行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSWillBecomeMultiThreadedNotification&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当有第一个线程从当前线程中分离的时候抛出这个通知。NSThread类最多会发出一次这个通知，也就是在一个线程第一次使用&lt;code class=&quot;highlighter-rouge&quot;&gt;detachNewThreadSelector:toTarget:withObject: &lt;/code&gt;方法或者&lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt;方法被分离的时候。而随后这些方法的调用就不会发出这个通知了。这个通知的观察者在主线程中调用他们的线程处理方法， 而非在新线程中。观察者的通知处理方法总是会在新线程开始执行前执行。&lt;/p&gt;

&lt;h3 id=&quot;初始化器&quot;&gt;初始化器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- initWithBlock:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;类型方法&quot;&gt;类型方法&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ detachNewThreadWithBlock:&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 17 Sep 2019 18:38:02 +0000</pubDate>
        <link>http://localhost:4000/2019/09/17/NSThread%E7%BF%BB%E8%AF%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/17/NSThread%E7%BF%BB%E8%AF%91/</guid>
        
        <category>翻译</category>
        
        <category>Cocoa</category>
        
        <category>多线程</category>
        
        
      </item>
    
      <item>
        <title>MacOS工程替换MainMenu.xib</title>
        <description>&lt;p&gt;创建了一个新工程，勾选了storyboard。但是工程创建好后就后悔了，不想要storyboard，直接删除了，然后新建了一个MainMenu.xib，在这个xib下添加一个拖一个NSWindow，然后就想把这个window关联到AppDelegate.m里自己定义的一个window属性&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@proporty (weak) IBOutlet NSWindow *window;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后死活没法通过拖线关联上。查了一波资料，总算解决了，方法如下：&lt;/p&gt;

&lt;p&gt;Xcode默认创建的MainMenu.xib在Interface Builder中的Objects一栏中是有App Delegate这一项，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72pnwa085j309l06f3yu.jpg&quot; alt=&quot;屏幕快照 2017-03-06 下午7.31.01.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同时AppDelegate中也已经默认连接好了MainMenu.xib中的NSWindow：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@interface AppDelegate ()

@property (weak) IBOutlet NSWindow *window;

@end
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然而如果自己创建MainMenu.xib的话，这些都是没有的。在Interface Builder中的Objects一栏是这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72ptcyattj305e05o0st.jpg&quot; alt=&quot;屏幕快照 2017-03-06 下午7.31.23.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以我们要增加一个AppDelegate对象上去，并做好和window属性的关联。接下来是具体操作步骤：&lt;/p&gt;

&lt;p&gt;1、在Objects Library中找到Object：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2014369-52c63dcc7a92b3b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2017-03-06 下午7.31.33.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、手动将此Object拖到Interface Builder左侧的Objects一栏内。&lt;/p&gt;

&lt;p&gt;3、在右上的Identity Inspector中设置Class为AppDelegate,这样Object名字就变成了AppDelegate，也就是我们需要的AppDelegate对象：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72pov52cbj307g03oaa3.jpg&quot; alt=&quot;屏幕快照 2017-03-06 下午7.31.51.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4、拖线，把AppDelegate设置成File’s Owner的delegate&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72pp7znk2j30ar0ac3z9.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5、由于之前创建的是勾选StoryBoard的工程，所以target的General的Deployment Info中Main Interface记录的是StoryBoard.xib，此时需要将其改成MainMenu.xib。否则的话Run会崩溃。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72pphf4ccj30e802wq2x.jpg&quot; alt=&quot;屏幕快照 2017-03-06 下午7.32.08.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(当然也可以设置Info.plist中的Main nib file base name属性)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72ppwdwghj30m808djsi.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 17 Sep 2019 18:00:02 +0000</pubDate>
        <link>http://localhost:4000/2019/09/17/MacOS%E5%B7%A5%E7%A8%8B%E6%9B%BF%E6%8D%A2MainMenu.xib/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/17/MacOS%E5%B7%A5%E7%A8%8B%E6%9B%BF%E6%8D%A2MainMenu.xib/</guid>
        
        <category>Cocoa</category>
        
        <category>macOS</category>
        
        <category>XCode</category>
        
        
      </item>
    
      <item>
        <title>AnyDock</title>
        <description>&lt;h1 id=&quot;下载链接&quot;&gt;下载链接&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/CoderLeonidas/ProducedByLeonidas/&quot;&gt;AnyDock&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 17 Sep 2019 00:00:02 +0000</pubDate>
        <link>http://localhost:4000/2019/09/17/AnyDock/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/17/AnyDock/</guid>
        
        <category>个人作品</category>
        
        <category>macOS</category>
        
        <category>工具</category>
        
        
      </item>
    
      <item>
        <title>Masonry翻译</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Masonry以更漂亮的语法封装了AutoLayout，是一个轻量级的布局框架。
Masonry有自己的布局DSL(domain-specific language)，提供了一种链式写法来描述NSLayoutConstraints，这使得布局代码变得更加简洁和可读。
Masonry 支持 iOS 和 macOS。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;nslayoutconstraints怎么了&quot;&gt;NSLayoutConstraints怎么了？&lt;/h1&gt;
&lt;p&gt;在底层AutoLayout是一种很强大灵活的用于管理和布局视图的方式。但用代码创建约束(Constraints)显得非常冗长且不易描述。设想这样的简单场景：在父视图中填放一个子视图，且每一边留下10像素的边距。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;UIView *superview = self.view;

UIView *view1 = [[UIView alloc] init];
view1.translatesAutoresizingMaskIntoConstraints = NO;
view1.backgroundColor = [UIColor greenColor];
[superview addSubview:view1];

UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);
[superview addConstraints:@[
//view1 constraints
[NSLayoutConstraint constraintWithItem:view1
attribute:NSLayoutAttributeTop
relatedBy:NSLayoutRelationEqual
toItem:superview
attribute:NSLayoutAttributeTop
multiplier:1.0
constant:padding.top],

[NSLayoutConstraint constraintWithItem:view1
attribute:NSLayoutAttributeLeft
relatedBy:NSLayoutRelationEqual
toItem:superview
attribute:NSLayoutAttributeLeft
multiplier:1.0
constant:padding.left],

[NSLayoutConstraint constraintWithItem:view1
attribute:NSLayoutAttributeBottom
relatedBy:NSLayoutRelationEqual
toItem:superview
attribute:NSLayoutAttributeBottom
multiplier:1.0
constant:-padding.bottom],

[NSLayoutConstraint constraintWithItem:view1
attribute:NSLayoutAttributeRight
relatedBy:NSLayoutRelationEqual
toItem:superview
attribute:NSLayoutAttributeRight
multiplier:1
constant:-padding.right],

]];
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;即使这样简单的一个例子，代码就变得这么冗长，如果再多两三个视图，就立刻变得可读性很差。
另外一个选择是使用VFL，稍微不那么长和绕。但是ASKII类型的语法有它自己的隐患，并且动画很麻烦因为&lt;em&gt;NSLayoutConstraint constraintsWithVisualFormat:&lt;/em&gt;返回的是一个数组。&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;准备好见你的maker&quot;&gt;准备好见你的Maker！&lt;/h1&gt;

&lt;p&gt;以下是用&lt;strong&gt;MASConstraintMaker&lt;/strong&gt;创建的简单约束：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);

[view1 mas_makeConstraints:^(MASConstraintMaker *make) {
make.top.equalTo(superview.mas_top).with.offset(padding.top);
//with is an optional semantic filler
make.left.equalTo(superview.mas_left).with.offset(padding.left);
make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);
make.right.equalTo(superview.mas_right).with.offset(-padding.right);
}];
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还可以更短：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;[view1 mas_makeConstraints:^(MASConstraintMaker *make) {
make.edges.equalTo(superview).with.insets(padding);
}];
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不过需要注意在第一个例子中我们需要把约束添加到superview中，尽管Masonry会自动添加约束到合适的view中。
Masonry也会自动调用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;view1.translatesAutoresizidngMaskIntoConstraints = NO;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;不是所有的事情都是平等的&quot;&gt;不是所有的事情都是平等的&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;.equalTo 等价于 NSLayoutRelationEqual
.lessThanOrEqualTo 等价于 NSLayoutRelationLessThanOrEqual
.greaterThanOrEqualTo 等价于 NSLayoutRelationGreaterThanOrEqual
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这3个等价关系接受一个参数，可以是下面的任何一种：&lt;/p&gt;
&lt;h2 id=&quot;1masviewattribute&quot;&gt;1、MASViewAttribute&lt;/h2&gt;

&lt;p&gt;make.centerX.lessThanOrEqualTo(view2.mas_left);
以下是MASViewAttribute和NSLayoutAttribute 的对应关系：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;MASViewAttribute&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;NSLayoutAttribute&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_left&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeLeft&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_right&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeRight&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_top&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeTop&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_bottom&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeBottom&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_leading&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeLeading&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_trailing&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeTrailing&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_width&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeWidth&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_height&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeHeight&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_centerX&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeCenterX&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_centerY&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeCenterY&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_baseline&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeBaseline&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;2-uiviewnsview&quot;&gt;2. UIView/NSView&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;if you want view.left to be greater than or equal to label.left :
//这2中约束是等价的
make.left.greaterThanOrEqualTo(label);
make.left.greaterThanOrEqualTo(label.mas_left);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-nsnumber&quot;&gt;3. NSNumber&lt;/h2&gt;
&lt;p&gt;Auto Layout允许宽和高设置为常量。如果想设置view的最小和最大宽度，可以传一个number值:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;//width &amp;gt;= 200 &amp;amp;&amp;amp; width &amp;lt;= 400
make.width.greaterThanOrEqualTo(@200);
make.width.lessThanOrEqualTo(@400);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然而Auto Layout 不允许left, right, centerY等的对齐属性设置成常量值。所以，给这些属性传NSNumber，Masonry会转换到view的superview中去，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;//creates view.left = view.superview.left + 10
make.left.lessThanOrEqualTo(@10)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;除了NSNumber，也可以用原始值或结构体来建立约束，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;make.top.mas_equalTo(42);
make.height.mas_equalTo(20);
make.size.mas_equalTo(CGSizeMake(50, 100));
make.edges.mas_equalTo(UIEdgeInsetsMake(10, 0, 10, 0));
make.left.mas_equalTo(view).mas_offset(UIEdgeInsetsMake(10, 0, 10, 0));
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一般支持&lt;em&gt;自动装箱(autoboxing)&lt;/em&gt;的宏会有mas_前缀。没前缀的版本在导入Masronry前，通过定义&lt;strong&gt;MAS_SHORTHAND_GLOBALS&lt;/strong&gt;，也是可以用的。&lt;/p&gt;

&lt;h2 id=&quot;4-nsarray&quot;&gt;4. NSArray&lt;/h2&gt;
&lt;p&gt;包含前面任何类型元素的数组也是可以的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;make.height.equalTo(@[view1.mas_height, view2.mas_height]);
make.height.equalTo(@[view1, view2]);
make.left.equalTo(@[view1, @100, view3.right]);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;考虑优先级prioritize&quot;&gt;考虑优先级（prioritize）&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;.priority 允许你指定一个确定的优先级
.priorityHigh 等价于 UILayoutPriorityDefaultHigh
.priorityMedium 介于高优先级和低优先级之间
.priorityLow 等价于UILayoutPriorityDefaultLow
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;优先级可以添加在约束链后面，像这样:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;make.left.greaterThanOrEqualTo(label.mas_left).with.priorityLow();
make.top.equalTo(label.mas_top).with.priority(600);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;结构结构结构&quot;&gt;结构，结构，结构&lt;/h1&gt;
&lt;p&gt;Masonry也提供了一些简便方法来同时创建多种约束。这些被称为&lt;strong&gt;MASCompositeConstraints&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;edges&quot;&gt;edges&lt;/h3&gt;
&lt;p&gt;// make top, left, bottom, right equal view2&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make.edges.equalTo(view2);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;// make top = superview.top + 5, left = superview.left + 10,
// bottom = superview.bottom - 15, right = superview.right - 20&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make.edges.equalTo(superview).insets(UIEdgeInsetsMake(5, 10, 15, 20))&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;size&quot;&gt;size&lt;/h3&gt;
&lt;p&gt;// make width and height greater than or equal to titleLabel&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make.size.greaterThanOrEqualTo(titleLabel)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;// make width = superview.width + 100, height = superview.height - 50&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make.size.equalTo(superview).sizeOffset(CGSizeMake(100, -50))&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;center&quot;&gt;center&lt;/h3&gt;
&lt;p&gt;// make centerX and centerY = button1&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make.center.equalTo(button1)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;// make centerX = superview.centerX - 5, centerY = superview.centerY + 10&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make.center.equalTo(superview).centerOffset(CGPointMake(-5, 10))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为了可读性高也可以把属性连起来像这样:&lt;/p&gt;

&lt;p&gt;// All edges but the top should equal those of the superview&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;make.left.right.and.bottom.equalTo(superview);
make.top.equalTo(otherView);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;让美好持续发生&quot;&gt;让美好持续发生&lt;/h1&gt;

&lt;p&gt;有时你需要修改已存在的约束来支持动画或者移除、替换约束。在Masonry中有一些不同的方式来更新约束。&lt;/p&gt;

&lt;h2 id=&quot;1引用&quot;&gt;1、引用&lt;/h2&gt;
&lt;p&gt;可以通过创建变量或者属性来引用一个特定的约束。也可以通过数组保存的方式来引用多个约束。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// in public/private interface

@property (nonatomic, strong) MASConstraint *topConstraint;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;// when making constraints&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;[view1 mas_makeConstraints:^(MASConstraintMaker *make) {
self.topConstraint = make.top.equalTo(superview.mas_top).with.offset(padding.top);
make.left.equalTo(superview.mas_left).with.offset(padding.left);
}];

...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;// 然后你可以调用&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[self.topConstraint uninstall];&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-mas_updateconstraints&quot;&gt;2. mas_updateConstraints&lt;/h2&gt;
&lt;p&gt;如果只是更新约束中的常量值，你可以用这个&lt;strong&gt;mas_updateConstraints&lt;/strong&gt;方法来代替&lt;strong&gt;mas_makeConstraints&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// 这是苹果推荐的用来添加或更新约束的地方
// 这个方法会在响应setNeedsUpdateConstraints时被多次调用
// 会被UIKit内部或者在你的代码中当你需要触发约束的更新时调用
- (void)updateConstraints {
[self.growingButton mas_updateConstraints:^(MASConstraintMaker *make) {
make.center.equalTo(self);
make.width.equalTo(@(self.buttonSize.width)).priorityLow();
make.height.equalTo(@(self.buttonSize.height)).priorityLow();
make.width.lessThanOrEqualTo(self);
make.height.lessThanOrEqualTo(self);
}];

//according to apple super should be called at end of method
[super updateConstraints];
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3mas_remakeconstraints&quot;&gt;3、mas_remakeConstraints&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;mas_updateConstraints&lt;/em&gt;在更新一组约束时很有用，但是做一些更新约束值之外的事就显得力不从心了。这就是为何要引入&lt;strong&gt;mas_remakeConstraints&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mas_remakeConstraints&lt;/strong&gt;类似mas_updateConstraints，但是不同于更新常量值，它会在重新安装约束前移除所有的约束。这就让你能提供不同的约束，而不用时刻记住你要移除哪个约束了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;- (void)changeButtonPosition {
[self.button mas_remakeConstraints:^(MASConstraintMaker *make) {
make.size.equalTo(self.buttonSize);

if (topLeft) {
make.top.and.left.offset(10);
} else {
make.bottom.and.right.offset(-10);
}
}];
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;出现麻烦咋整&quot;&gt;出现麻烦咋整！&lt;/h1&gt;
&lt;p&gt;布局并不能像你意料的那样，所以当事情真的搞砸了的时候，你肯定不希望在控制台看到这样的输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Unable to simultaneously satisfy constraints.....blah blah blah....
(
&quot;&amp;lt;NSLayoutConstraint:0x7189ac0 V:[UILabel:0x7186980(&amp;gt;=5000)]&amp;gt;&quot;,
&quot;&amp;lt;NSAutoresizingMaskLayoutConstraint:0x839ea20 h=--&amp;amp; v=--&amp;amp; V:[MASExampleDebuggingView:0x7186560(416)]&amp;gt;&quot;,
&quot;&amp;lt;NSLayoutConstraint:0x7189c70 UILabel:0x7186980.bottom == MASExampleDebuggingView:0x7186560.bottom - 10&amp;gt;&quot;,
&quot;&amp;lt;NSLayoutConstraint:0x7189560 V:|-(1)-[UILabel:0x7186980]   (Names: '|':MASExampleDebuggingView:0x7186560 )&amp;gt;&quot;
)

Will attempt to recover by breaking constraint
&amp;lt;NSLayoutConstraint:0x7189ac0 V:[UILabel:0x7186980(&amp;gt;=5000)]&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Masonry在NSLayoutConstraint增加了一个分类，覆盖了&lt;em&gt;- (NSString *)description&lt;/em&gt;的默认实现。这样在给约束和view起名字后，能够很轻松的从中找出哪些是Masonry创建的约束。&lt;/p&gt;

&lt;p&gt;这意味着你的控制台输出看起来是这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Unable to simultaneously satisfy constraints......blah blah blah....
(
&quot;&amp;lt;NSAutoresizingMaskLayoutConstraint:0x8887740 MASExampleDebuggingView:superview.height == 416&amp;gt;&quot;,
&quot;&amp;lt;MASLayoutConstraint:ConstantConstraint UILabel:messageLabel.height &amp;gt;= 5000&amp;gt;&quot;,
&quot;&amp;lt;MASLayoutConstraint:BottomConstraint UILabel:messageLabel.bottom == MASExampleDebuggingView:superview.bottom - 10&amp;gt;&quot;,
&quot;&amp;lt;MASLayoutConstraint:ConflictingConstraint[0] UILabel:messageLabel.top == MASExampleDebuggingView:superview.top + 1&amp;gt;&quot;
)

Will attempt to recover by breaking constraint
&amp;lt;MASLayoutConstraint:ConstantConstraint UILabel:messageLabel.height &amp;gt;= 5000&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;应该在哪创建约束&quot;&gt;应该在哪创建约束？&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@implementation DIYCustomView

- (id)init {
self = [super init];
if (!self) return nil;

// --- Create your views here ---
self.button = [[UIButton alloc] init];

return self;
}

// 告诉UIKit你在使用AutoLayout
+ (BOOL)requiresConstraintBasedLayout {
return YES;
}

// 这是苹果推荐用来添加或更新约束的地方
- (void)updateConstraints {

// 在这里更新或者添加约束
[self.button remakeConstraints:^(MASConstraintMaker *make) {
make.width.equalTo(@(self.buttonSize.width));
make.height.equalTo(@(self.buttonSize.height));
}];

//根据苹果介绍super方法应该在方法的最后调用一下
[super updateConstraints];
}

- (void)didTapButton:(UIButton *)button {
// --- Do your changes ie change variables that affect your layout etc ---
self.buttonSize = CGSize(200, 200);

// 通知约束他们应该被更新了
[self setNeedsUpdateConstraints];
}

@end
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;安装&quot;&gt;安装：&lt;/h1&gt;
&lt;p&gt;使用CocoaPods.
在Podfile文件中写：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pod ‘Masonry'&lt;/code&gt;&lt;br /&gt;
即可。&lt;/p&gt;

&lt;p&gt;如果你在用Masonry时不想见到讨厌的mas_前缀，就添加&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#define MAS_SHORTHAND&lt;/code&gt;
到prefix.pch，并导入到Masonry中。&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;便捷代码块&quot;&gt;便捷代码块&lt;/h1&gt;
&lt;p&gt;将以下代码块拷贝到&lt;code class=&quot;highlighter-rouge&quot;&gt;~/Library/Developer/Xcode/UserData/CodeSnippets&lt;/code&gt;，写Masonry代码爽到飞起：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;mas_make -&amp;gt; [&amp;lt;view&amp;gt; mas_makeConstraints:^(MASConstraintMaker *make){&amp;lt;code&amp;gt;}];
mas_update -&amp;gt; [&amp;lt;view&amp;gt; mas_updateConstraints:^(MASConstraintMaker *make){&amp;lt;code&amp;gt;}];
mas_remake -&amp;gt; [&amp;lt;view&amp;gt; mas_remakeConstraints:^(MASConstraintMaker *make){&amp;lt;code&amp;gt;}];
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;特性&quot;&gt;特性：&lt;/h1&gt;

&lt;p&gt;1、不只是Auto Layout的子集，任何NSLayoutConstraint能做的，Masonry都能做
2、很棒的debug支持，只要你给约束和view取好有意义的名字
3、约束读起来像自然语句，通俗易懂
4、没有令人抓狂的宏魔法。Masonry有了宏不会污染全局的名字空间。
5、不基于字符串和字典，所以编译的时候就能检查出问题。&lt;/p&gt;

&lt;h1 id=&quot;原文链接&quot;&gt;原文链接&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/SnapKit/Masonry&quot;&gt;Masonry&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 16 Sep 2019 12:00:02 +0000</pubDate>
        <link>http://localhost:4000/2019/09/16/Masonry%E7%BF%BB%E8%AF%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/16/Masonry%E7%BF%BB%E8%AF%91/</guid>
        
        <category>三方库</category>
        
        <category>翻译</category>
        
        
      </item>
    
      <item>
        <title>KSCrash翻译</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;KSCrash：一个终极的iOS crash reporter&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;为何使用kscrash&quot;&gt;为何使用KSCrash？&lt;/h1&gt;

&lt;p&gt;因为在现有的一些crash reporter报告崩溃时，KSCrash还能比它们还能做得更多。以下是KSCrash的一些关键属性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;1. 支持离线重新符号化的设备上符号化(在iOS版本中，许多功能已经被修改)。
2. 生成完全的苹果报告，每个字段都不落下
3. 支持32或64位 
4. 能处理只能在mach级别捕获的错误，比如堆栈溢出。
5. 跟踪由于未捕获的c++异常导致的REAL。
6. 在crash自己的回调里处理crash(或者在用户的crash回调里)
7. 检测僵尸(释放)对象访问尝试
8. 在僵尸或内存损坏的情况下恢复丢失的NSException消息
9. 在寄存器和堆栈上自省对象(C字符串和Objective-C对象，包括ivars)。
10. 提取关于异常引用的对象的信息(例如&quot;unrecognized selector sent to instance 0xa26d9a0&quot;)
11. 它的可插入服务报告体系结构使其易于适应任何API服务。
12. 转储堆栈内容。
13. 诊断crash原因(Crash医生)
14. 以JSON格式记录苹果崩溃报告所不能记录的大量信息。
15. 支持包括程序员提供的额外数据(崩溃前和崩溃期间)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;kscrash支持处理以下类型的crash&quot;&gt;KSCrash支持处理以下类型的crash:&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;mach 内核异常
致命信号(Fatal signals)
C++ 异常
OC异常
主线程死锁
自定义crash(比如来自脚本语言的自定义crash)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;kscrash可以向以下服务器报导&quot;&gt;KSCrash可以向以下服务器报导：&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Hockey
QuincyKit
Victory
Email
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;新特性&quot;&gt;新特性：&lt;/h1&gt;

&lt;p&gt;C++异常处理：
是的，通常你的app由于未捕获的C++异常而终止，你会看到这样的堆栈：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   libsystem_kernel.dylib          0x9750ea6a 0x974fa000 + 84586 (__pthread_kill + 10)
1   libsystem_sim_c.dylib           0x04d56578 0x4d0f000 + 292216 (abort + 137)
2   libc++abi.dylib                 0x04ed6f78 0x4ed4000 + 12152 (abort_message + 102)
3   libc++abi.dylib                 0x04ed4a20 0x4ed4000 + 2592 (_ZL17default_terminatev + 29)
4   libobjc.A.dylib                 0x013110d0 0x130b000 + 24784 (_ZL15_objc_terminatev + 109)
5   libc++abi.dylib                 0x04ed4a60 0x4ed4000 + 2656 (_ZL19safe_handler_callerPFvvE + 8)
6   libc++abi.dylib                 0x04ed4ac8 0x4ed4000 + 2760 (_ZSt9terminatev + 18)
7   libc++abi.dylib                 0x04ed5c48 0x4ed4000 + 7240 (__cxa_rethrow + 77)
8   libobjc.A.dylib                 0x01310fb8 0x130b000 + 24504 (objc_exception_rethrow + 42)
9   CoreFoundation                  0x01f2af98 0x1ef9000 + 204696 (CFRunLoopRunSpecific + 360)
...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;根本没法跟踪这个异常是啥和在哪抛出的！
现在有了KSCrash，你可以从下面信息获得未捕获的异常类型、描述、和它抛出的地方：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Application Specific Information:
*** Terminating app due to uncaught exception 'MyException', reason: 'Something bad happened...'

Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   Crash-Tester                    0x0000ad80 0x1000 + 40320 (-[Crasher throwUncaughtCPPException] + 0)
1   Crash-Tester                    0x0000842e 0x1000 + 29742 (__32-[AppDelegate(UI) crashCommands]_block_invoke343 + 78)
2   Crash-Tester                    0x00009523 0x1000 + 34083 (-[CommandEntry executeWithViewController:] + 67)
3   Crash-Tester                    0x00009c0a 0x1000 + 35850 (-[CommandTVC tableView:didSelectRowAtIndexPath:] + 154)
4   UIKit                           0x0016f285 0xb4000 + 766597 (-[UITableView _selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:] + 1194)
5   UIKit                           0x0016f4ed 0xb4000 + 767213 (-[UITableView _userSelectRowAtPendingSelectionIndexPath:] + 201)
6   Foundation                      0x00b795b3 0xb6e000 + 46515 (__NSFireDelayedPerform + 380)
7   CoreFoundation                  0x01f45376 0x1efa000 + 308086 (__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ + 22)
8   CoreFoundation                  0x01f44e06 0x1efa000 + 306694 (__CFRunLoopDoTimer + 534)
9   CoreFoundation                  0x01f2ca82 0x1efa000 + 207490 (__CFRunLoopRun + 1810)
10  CoreFoundation                  0x01f2bf44 0x1efa000 + 204612 (CFRunLoopRunSpecific + 276)
...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;方便的c开发助手&quot;&gt;方便的C++开发助手&lt;/h1&gt;
&lt;p&gt;如果你打开跟踪打印：
`
[KSCrash sharedInstance].printTraceToStdout = YES;
`
它会在你的app抛出未捕获C++异常的时候打印一个合适的堆栈跟踪信息到标准输出(stdout)上！否则调试器只会将你引向重新抛出异常的位置。&lt;/p&gt;

&lt;h1 id=&quot;自定义crash和堆栈跟踪&quot;&gt;自定义Crash和堆栈跟踪&lt;/h1&gt;
&lt;p&gt;你现在可以报导你自己自定义的crash和堆栈跟踪信息(想一下脚本语言)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;- (void) reportUserException:(NSString*) name
reason:(NSString*) reason
lineOfCode:(NSString*) lineOfCode
stackTrace:(NSArray*) stackTrace
terminateProgram:(BOOL) terminateProgram;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;详情见KSCrash.h文件。&lt;/p&gt;

&lt;h1 id=&quot;不稳定的特性&quot;&gt;不稳定的特性&lt;/h1&gt;
&lt;p&gt;下列特性被认为是”不稳定”的，并且默认禁用：
死锁检测&lt;/p&gt;

&lt;h1 id=&quot;不兼容api更改通知&quot;&gt;不兼容API更改通知&lt;/h1&gt;
&lt;p&gt;从2013年1月29日起，我修改了KSCrash主API，使用属性而不是初始化方法参数进行配置。有了所有的新选择后，事情开始变得有点棘手。这应该是最后一个主要的API更改。&lt;/p&gt;

&lt;p&gt;注意:初始化KSCrash的首选方法现在是通过安装对象，而不是直接使用过滤器。详见“如何使用KSCrash”。&lt;/p&gt;

&lt;h1 id=&quot;如何build-kscrash&quot;&gt;如何build KSCrash&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;1 选中KSCrash的scheme
2 选择iOS设备
3 Products菜单里选择Archive
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当build完成，会在Finder看到framework，你可以像使用任何其他framework一样使用它。&lt;/p&gt;

&lt;h1 id=&quot;如何使用kscrash&quot;&gt;如何使用KSCrash&lt;/h1&gt;
&lt;p&gt;1 添加这个framework到你的工程(或者添加KSCrash工程进来，作为依赖项)
2 添加下列系统framework和lib到你的工程&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;libc++.dylib
libz.dylib
MessageUI.framework (iOS only)
SystemConfiguration.framework
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3 在Build Setting是的Other Linker Flags里添加”-Objc”标识
4 添加下列内容到你app delegate的 &lt;code class=&quot;highlighter-rouge&quot;&gt;[application: didFinishLaunchingWithOptions:] &lt;/code&gt;方法里：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;#import &amp;lt;KSCrash/KSCrash.h&amp;gt;
// Include to use the standard reporter.
#import &amp;lt;KSCrash/KSCrashInstallationStandard.h&amp;gt;
// Include to use Quincy or Hockey.
#import &amp;lt;KSCrash/KSCrashInstallationQuincyHockey.h&amp;gt;
// Include to use the email reporter.
#import &amp;lt;KSCrash/KSCrashInstallationEmail.h&amp;gt;
// Include to use Victory.
#import &amp;lt;KSCrash/KSCrashInstallationVictory.h&amp;gt;

- (BOOL)application:(UIApplication*) application didFinishLaunchingWithOptions:(NSDictionary*) launchOptions
{
KSCrashInstallationStandard* installation = [KSCrashInstallationStandard sharedInstance];
installation.url = [NSURL URLWithString:@&quot;http://put.your.url.here&quot;];

// OR:

KSCrashInstallationQuincy* installation = [KSCrashInstallationQuincy sharedInstance];
installation.url = [NSURL URLWithString:@&quot;http://put.your.url.here&quot;];

// OR:

KSCrashInstallationHockey* installation = [KSCrashInstallationHockey sharedInstance];
installation.appIdentifier = @&quot;PUT_YOUR_HOCKEY_APP_ID_HERE&quot;;

// OR:

KSCrashInstallationEmail* installation = [KSCrashInstallationEmail sharedInstance];
installation.recipients = @[@&quot;some@email.address&quot;];

// Optional (Email): Send Apple-style reports instead of JSON
[installation setReportStyle:KSCrashEmailReportStyleApple useDefaultFilenameFormat:YES]; 

// Optional: Add an alert confirmation (recommended for email installation)
[installation addConditionalAlertWithTitle:@&quot;Crash Detected&quot;
message:@&quot;The app crashed last time it was launched. Send a crash report?&quot;
yesAnswer:@&quot;Sure!&quot;
noAnswer:@&quot;No thanks&quot;];

// OR:

KSCrashInstallationVictory* installation = [KSCrashInstallationVictory sharedInstance];
installation.url = [NSURL URLWithString:@&quot;https://put.your.url.here/api/v1/crash/&amp;lt;application key&amp;gt;&quot;];

[installation install];
…
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这将安装崩溃哨兵系统(可以拦截crashes并将报告存存盘)。不过注意，你还可以为各种安装设置其他你想要的其他属性。
一旦你准备发送任何的crash报告，调用如下方法：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;[installation sendAllReportsWithCompletion:^(NSArray *filteredReports, BOOL completed, NSError *error)
{
// Stuff to do when report sending is complete
}];
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h1&gt;
&lt;p&gt;如果可以的话，你应该阅读下列头文件来完全理解KSCrash所拥有的特性和如何使用它：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;KSCrash.h
KSCrashInstallation.h
KSCrashInstallation(SPECIFIC TYPE).h
Architecture.md
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;高端用法&quot;&gt;高端用法&lt;/h1&gt;

&lt;h2 id=&quot;允许设备内置符号化&quot;&gt;允许设备内置符号化&lt;/h2&gt;
&lt;h2 id=&quot;允许高级功能&quot;&gt;允许高级功能&lt;/h2&gt;
&lt;p&gt;KSCrash具有一些在一片茫然中检查崩溃报告时非常有用的高级功能。其中一些涉及到较小的权衡，因此大多数默认情况下是禁用的。&lt;/p&gt;
&lt;h3 id=&quot;自定义用户数据kscrashh中的userinfo&quot;&gt;自定义用户数据(KSCrash.h中的userInfo)&lt;/h3&gt;
&lt;p&gt;设置userInfo属性后，你可以将自定义用户数据存储到下一次的crash report上&lt;/p&gt;
&lt;h3 id=&quot;僵尸对象跟踪kscrashh中的zombiecachesize&quot;&gt;僵尸对象跟踪(KSCrash.h中的zombieCacheSize)&lt;/h3&gt;
&lt;p&gt;KSCrash具有检测僵尸对象(指向已释放对象的悬停指针)的能力。它通过记录已释放对象的类型和地址来做到这一点。它将这些值存储在缓存中，并切断已释放对象的地址。这意味着，设置缓存的大小越小，哈希冲突发生的几率越大。并且你将因此失去先前已释放对象的信息。&lt;/p&gt;

&lt;p&gt;启用僵尸跟踪后，KSCrash还将检测丢失的NSException并打印其内容。某些类型的内存损坏或堆栈损坏崩溃可能会导致异常提前释放，从而进一步影响调试应用程序的工作，因此该特性有时非常方便。&lt;/p&gt;

&lt;p&gt;权衡：僵尸跟踪的代价是向对象释放位置添加非常小的开销，并保留一些内存。&lt;/p&gt;

&lt;h3 id=&quot;死锁检测kscrashh中的deadlockwatchdoginterval&quot;&gt;死锁检测(KSCrash.h中的deadlockWatchdogInterval)&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;严正警告！！本功能是不稳定的！它会呈现假阳性并使你的app崩溃！&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;内存自省kscrashh中的introspectmemory&quot;&gt;内存自省(KSCrash.h中的introspectMemory)&lt;/h3&gt;
&lt;p&gt;当应用程序崩溃时，内存中通常残留有被栈、寄存器甚至异常消息引用的对象和字符串。当启用此功能时，KSCrash将内省这些内存区域并将它们的内容存储到crash report中。&lt;/p&gt;

&lt;p&gt;你也可以通过设置doNotIntrospectClasses属性，指定一个类的列表，来避免这些类的自省。&lt;/p&gt;
&lt;h3 id=&quot;自定义crash处理代码kscrashh中的oncrash&quot;&gt;自定义crash处理代码(KSCrash.h中的onCrash)&lt;/h3&gt;

&lt;p&gt;如果你想在crash发生时做一些额外操作(比如添加更多的上下文数据信息到报告中去)，你可以这么做。&lt;/p&gt;

&lt;p&gt;然而，你必须确保你只使用异步安全的代码。并且最重要的是，不要那个方法里调用OC代码！在很多情况下，你都可以这样做，但是在某些特定的崩溃类中，无视此警告的处理程序代码将导致崩溃处理程序崩溃! 注意，如果发生这种情况，KSCrash将检测它并编写完整的报告，尽管您的自定义处理程序代码可能没有完全运行！&lt;/p&gt;

&lt;p&gt;权衡： 你必须小心你所放入的自定义崩溃处理代码！&lt;/p&gt;

&lt;h3 id=&quot;kscrash-日志重定向&quot;&gt;KSCrash 日志重定向&lt;/h3&gt;

&lt;p&gt;这会将KSCrash将要打印到控制台的内容，写到一个文件里。我通常用这个功能来调试KSCrash自身，但它也可以拍派很多其他用场，所以我公开为它公开了一个API！&lt;/p&gt;

&lt;h1 id=&quot;例子&quot;&gt;例子&lt;/h1&gt;
&lt;p&gt;workspace中包含了几个例子app，用来演示常见的KSCrash用法。请看下每个AppDelegate.m文件的顶部信息来了解它做了什么。&lt;/p&gt;

&lt;p&gt;原链接: https://github.com/kstenerud/KSCrash&lt;/p&gt;

</description>
        <pubDate>Mon, 16 Sep 2019 12:00:01 +0000</pubDate>
        <link>http://localhost:4000/2019/09/16/KSCrash%E7%BF%BB%E8%AF%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/16/KSCrash%E7%BF%BB%E8%AF%91/</guid>
        
        <category>三方库</category>
        
        <category>翻译</category>
        
        
      </item>
    
  </channel>
</rss>
