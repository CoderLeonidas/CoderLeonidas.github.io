<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>luoyang Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 18 Sep 2019 00:26:52 +0800</pubDate>
    <lastBuildDate>Wed, 18 Sep 2019 00:26:52 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>macOS图形性能调试工具Quartz Debug</title>
        <description>&lt;p&gt;在macOS上有个专门来调试图形性能的工具，叫做，Quartz Debug 。它存在于一个叫做Additional_Tools_for_Xcode的扩展工具包中，每个xcode版本都有对应的扩展工具包dmg，如xcode10.1，需要下载Additional_Tools_for_Xcode_10.1，可以在&lt;a href=&quot;https://developer.apple.com/download/more/&quot;&gt;这里&lt;/a&gt;下载到。本文主要内容参考《&lt;a href=&quot;http://www.broadview.com.cn/book/4920&quot;&gt;iOS和macOS性能优化：Cocoa、Cocoa Touch、Objective-C和Swift&lt;/a&gt;》，Quartz Debug提供了许多工具来帮助您调试应用程序中与图形相关的问题。下面讨论Quartz调试的特性。&lt;/p&gt;

&lt;h2 id=&quot;quartz-debug-settings&quot;&gt;Quartz Debug Settings&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72pgm6aouj30ce0pp760.jpg&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用此面板切换常用加速和调试选项。提供以下选择:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Enable Quartz Debug&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;启用/禁用所有选项。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Disable 2D Acceleration&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;禁用所有2D加速。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
所谓2D加速是指2D图形硬件加速，即开启GPU。强制进行GPU渲染，指的是在CPU性能不足或者想要节省CPU资源的情况下，强制系统使用GPU对系统和软件的UI进行渲染，由于在图形方面GPU相比CPU具有天然优势，所以此情况下使用GPU渲染会得到更加流畅的界面体验；
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Autoflush drawing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每次绘图操作后刷新内容。
会关闭合并内存的访问模式，所以每个绘制操作都会直接展示在屏幕上(如果开启Flash identical screen updates和Flash screen updates2个选项，可能会造成闪烁)，这会产生更多的干扰信息，但是这样会将绘制过程划分的更细，展示的矩形越多，就越能让开发者了解系统是如何绘制的以及绘制过程发生了哪些变化。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Flash screen updates&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在屏幕区域更新之前用黄色高亮显示(正常)。DisableUpdate下的区域被涂成橙色。
该选项能让你区分出那些刷新次数过于频繁的地方。打开该选项可能会产生一些干扰数据。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Flash identical screen updates&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用红色高亮显示冗余屏幕更新。冗余更新是指重新绘制未更改像素的情况。&lt;/p&gt;

&lt;p&gt;开启该选项后，Quartz会用红色矩形块标注屏幕中重复刷新相同内容的区域，这表示红色区块的绘制操作是多余的，应该被删除。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;No delay after flash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;移除闪烁屏幕更新后的延迟。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Show tracking rectangles&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;跟踪矩形用绿色表示。活动跟踪矩形的轮廓是红色的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Vertical Sync&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;切换垂直波束同步开关的窗口服务器屏幕更新。&lt;/p&gt;

&lt;h2 id=&quot;ui-resolution&quot;&gt;UI Resolution&lt;/h2&gt;

&lt;p&gt;UI解析窗口允许控制用于用户界面的当前缩放因子。设置完成后，将立即向Dock应用新的分辨率，但是应用程序需要重新启动才能获取新的设置。&lt;/p&gt;

&lt;h2 id=&quot;framemeter&quot;&gt;Framemeter&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72phwve73j30fl0ddwex.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;帧表显示每秒屏幕更新的次数。还显示了CPU使用情况。帧表输出也可以在Quartz Debug Dock图标中获得。&lt;/p&gt;

&lt;h2 id=&quot;dock-icon&quot;&gt;Dock Icon&lt;/h2&gt;

&lt;p&gt;可以将dock图标配置为显示帧表和石英状态。右键单击dock图标或选择Tools -&amp;gt; dock来配置这些选项&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Show Framemeter History&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;帧速率绘制在每秒更新10次的图形上，并显示在dock中应用程序图标的位置。该图由当前FPS读取值着色，红线表示更新速率为0……一条黄线31……一条绿线61……90 fps。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;应该注意，随着Quartz Debug的运行，应用程序与平常的运行状态有一点区别，绘制这些额外的矩形会造成不小的开销，你甚至可以感觉到屏幕在刷新的过程中有一些延迟。开启一个Flash选项，然后尝试拖拽窗口，这时不仅能看到有很多闪烁效果，拖拽的过程也变的很迟钝。关闭延迟能让性能恢复正常，但闪烁会导致肉眼难以识别屏幕上的情况。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;参考资料：
《&lt;a href=&quot;http://www.broadview.com.cn/book/4920&quot;&gt;iOS和macOS性能优化：Cocoa、Cocoa Touch、Objective-C和Swift&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;《Quartz Debug 4.0 Help(位于Quartz Debug 的help中)》&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Sep 2019 02:50:02 +0800</pubDate>
        <link>http://localhost:4000/2019/09/18/macOS%E5%9B%BE%E5%BD%A2%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7Quartz-Debug/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/18/macOS%E5%9B%BE%E5%BD%A2%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7Quartz-Debug/</guid>
        
        <category>macOS</category>
        
        <category>Cocoa</category>
        
        <category>图形</category>
        
        
      </item>
    
      <item>
        <title>《kindle drm removal》 kindle电子书去除DRM的另一个工具</title>
        <description>&lt;p&gt;介绍如何去除DRM的方法，网上不胜枚举，我就不详细介绍了。主要是昨天尝试了网上的方法，使用《&lt;a href=&quot;[https://github.com/apprenticeharper/DeDRM_tools/releases/tag/v6.5.5](https://github.com/apprenticeharper/DeDRM_tools/releases/tag/v6.5.5)&quot;&gt;DeDRM&lt;/a&gt;》这个软件来去除DRM，每次都执行成功，但是真正用《&lt;a href=&quot;[http://calibre-ebook.com/download](http://calibre-ebook.com/download)&quot;&gt;calibre&lt;/a&gt;》来转换格式的时候却又报错&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72pbnyehzj30nm0d0q5i.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看着像是并没有成功解锁DRM。试了好几次都是如此。于是尝试寻求其他去除DRM限制的工具。最后发现了《&lt;a href=&quot;https://mac-kindle-drm-removal.en.softonic.com/mac&quot;&gt;kindle-drm-removal-for-mac&lt;/a&gt;》，使用很简单，提示导入电子书后，点击转换，最后提示解锁DRM成功。然后将去掉DRM的&lt;strong&gt;axw3&lt;/strong&gt;电子书使用calibre转换成pdf，最后转换成功。转换成功后的书名，有的会加上&lt;strong&gt;nodrm&lt;/strong&gt;后缀，如《iOS和macOS性能优化：Cocoa、Cocoa Touch、Objective-C和Swift_nodrm.pdf》&lt;/p&gt;

&lt;p&gt;参考链接：
《&lt;a href=&quot;https://www.jianshu.com/p/7e2bfacaba37&quot;&gt;Calibre和DeDrm插件破解亚马逊azw格式电子书&lt;/a&gt;》&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Sep 2019 02:39:02 +0800</pubDate>
        <link>http://localhost:4000/2019/09/18/kindle-drm-removal-kindle%E7%94%B5%E5%AD%90%E4%B9%A6%E5%8E%BB%E9%99%A4DRM%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%85%B7/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/18/kindle-drm-removal-kindle%E7%94%B5%E5%AD%90%E4%B9%A6%E5%8E%BB%E9%99%A4DRM%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%85%B7/</guid>
        
        <category>Kindle</category>
        
        <category>电子产品</category>
        
        
      </item>
    
      <item>
        <title>NSThread翻译</title>
        <description>&lt;h1 id=&quot;nsthread&quot;&gt;NSThread&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个执行的线程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;当你想让一个OC方法在它自己的执行线程中运行的时候，可以用这个类。当你想执行一个冗长任务，但不希望阻塞程序其余部分的执行的时候，线程显得特别有用。特别是你可以用线程来避免阻塞主线程(处理用户界面和事件相关动作)。线程还可以用来将一个大的工作划分为几个较小的工作，这将导致多核计算机的性能增加。&lt;/p&gt;

&lt;p&gt;NSThread 类支持和NSOperation类似的用来监控一个线程运行时条件的语义。你可以用这些语义来取消一个线程的执行或者决定线程是否继续执行还是完成当前任务。取消一个线程需要你的线程代码支持。详情见cancel方法的描述。&lt;/p&gt;

&lt;h1 id=&quot;子类化的注意点&quot;&gt;子类化的注意点&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;你可以子类化NSThread并重载&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;方法来实现你的线程的主要入口点。如果你重载&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;方法，就不需要调用&lt;code class=&quot;highlighter-rouge&quot;&gt;super&lt;/code&gt;来调用继承而来的行为。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;话题&quot;&gt;话题&lt;/h1&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;初始化一个nsthread对象&quot;&gt;初始化一个NSThread对象&lt;/h2&gt;
&lt;h1 id=&quot;---init&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; - init&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;返回一个初始化的 NSThread 对象&lt;/p&gt;
&lt;h1 id=&quot;--initwithtargetselectorobject&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- initWithTarget:selector:object:&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;返回一个用给定参数初始化的 NSThread 对象&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;启动一个线程&quot;&gt;启动一个线程&lt;/h2&gt;
&lt;h1 id=&quot;-detachnewthreadselectortotargetwithobject&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ detachNewThreadSelector:toTarget:withObject:&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;派发一个新线程并使用给定的selector作为线程的入口点&lt;/p&gt;

&lt;h1 id=&quot;--start&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- start&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;开启接收方(线程对象)&lt;/p&gt;

&lt;h1 id=&quot;--main&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- main&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;线程的主要入口点&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;停止一个线程&quot;&gt;停止一个线程&lt;/h2&gt;

&lt;h1 id=&quot;-sleepuntildate&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ sleepUntilDate:&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;阻塞当前线程知道指定的时间到了&lt;/p&gt;

&lt;h1 id=&quot;-sleepfortimeinterval&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ sleepForTimeInterval:&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;使线程在给定的时间内睡眠&lt;/p&gt;

&lt;h1 id=&quot;-exit&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ exit&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;终止当前线程&lt;/p&gt;

&lt;h1 id=&quot;--cancel&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- cancel&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;更改接收者(线程)的取消状态，以指示它应该退出(exit)&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;确定线程的执行状态&quot;&gt;确定线程的执行状态&lt;/h2&gt;
&lt;h1 id=&quot;executing&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;executing&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;一个布尔值，指示接受者(线程)是否正在执行&lt;/p&gt;

&lt;h1 id=&quot;finished&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;finished&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;一个布尔值，指示接受者(线程)是否已完成执行&lt;/p&gt;

&lt;h1 id=&quot;cancelled&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cancelled&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;一个布尔值，指示接受者(线程)是否已被取消&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;与主线程工作&quot;&gt;与主线程工作&lt;/h2&gt;

&lt;h1 id=&quot;ismainthread&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;isMainThread&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;一个布尔值，指示是否当前线程是主线程&lt;/p&gt;

&lt;h1 id=&quot;mainthread&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mainThread&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;返回代表主线程的 NSThread 对象&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;查询当前线程环境&quot;&gt;查询当前线程环境&lt;/h2&gt;

&lt;h1 id=&quot;-ismultithreaded&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ isMultiThreaded&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;返回是否程序是多线程的&lt;/p&gt;

&lt;h1 id=&quot;currentthread&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;currentThread&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;返回代表当前执行线程的 NSThread 对象&lt;/p&gt;

&lt;h1 id=&quot;callstackreturnaddresses&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callStackReturnAddresses&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;返回包含调用堆栈返回地址的数组&lt;/p&gt;

&lt;h1 id=&quot;callstacksymbols&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callStackSymbols&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;返回包含调用堆栈符号的数组&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;与线程属性工作&quot;&gt;与线程属性工作&lt;/h2&gt;

&lt;h1 id=&quot;threaddictionary&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;threadDictionary&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;线程对象的字典&lt;/p&gt;

&lt;h1 id=&quot;nsassertionhandlerkey&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSAssertionHandlerKey&lt;/code&gt;&lt;/h1&gt;

&lt;h1 id=&quot;name&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;接受者(线程)的名字&lt;/p&gt;

&lt;h1 id=&quot;stacksize&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stackSize&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;接受者(线程)的堆栈大小，以字节为单位&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;线程工作的优先级&quot;&gt;线程工作的优先级&lt;/h2&gt;
&lt;h1 id=&quot;qualityofservice&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;qualityOfService&lt;/code&gt;&lt;/h1&gt;

&lt;h1 id=&quot;nsqualityofservice&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSQualityOfService&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;用于指示系统工作的性质和重要性。在资源争用的情况下，高质量的服务类的工作比低质量的服务类工作接受的资源要多。&lt;/p&gt;

&lt;h1 id=&quot;-threadpriority&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ threadPriority&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;返回当前线程的优先级&lt;/p&gt;

&lt;h1 id=&quot;threadpriority&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;threadPriority&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;接受者(线程)的优先级&lt;/p&gt;

&lt;h1 id=&quot;-setthreadpriority&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ setThreadPriority:&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;设置当前线程的优先级&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;通知&quot;&gt;通知&lt;/h2&gt;

&lt;h1 id=&quot;nsdidbecomesinglethreadednotification&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSDidBecomeSingleThreadedNotification&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;已变成单线程？&lt;/p&gt;

&lt;h1 id=&quot;nsthreadwillexitnotification&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSThreadWillExitNotification&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;当线程接收到exit消息，并在线程退出之前，NSThread对象会发出这个通知。在线程退出之前，被调用以接受这个消息的观察者方法会在将要退出的线程中执行。&lt;/p&gt;

&lt;h1 id=&quot;nswillbecomemultithreadednotification&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSWillBecomeMultiThreadedNotification&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;当有第一个线程从当前线程中分离的时候抛出这个通知。NSThread类最多会发出一次这个通知，也就是在一个线程第一次使用&lt;code class=&quot;highlighter-rouge&quot;&gt;detachNewThreadSelector:toTarget:withObject: &lt;/code&gt;方法或者&lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt;方法被分离的时候。而随后这些方法的调用就不会发出这个通知了。这个通知的观察者在主线程中调用他们的线程处理方法， 而非在新线程中。观察者的通知处理方法总是会在新线程开始执行前执行。&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;初始化器&quot;&gt;初始化器&lt;/h2&gt;
&lt;h1 id=&quot;--initwithblock&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- initWithBlock:&lt;/code&gt;&lt;/h1&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;类型方法&quot;&gt;类型方法&lt;/h2&gt;

&lt;h1 id=&quot;-detachnewthreadwithblock&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ detachNewThreadWithBlock:&lt;/code&gt;&lt;/h1&gt;
</description>
        <pubDate>Wed, 18 Sep 2019 02:38:02 +0800</pubDate>
        <link>http://localhost:4000/2019/09/18/NSThread%E7%BF%BB%E8%AF%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/18/NSThread%E7%BF%BB%E8%AF%91/</guid>
        
        <category>翻译</category>
        
        <category>Cocoa</category>
        
        
      </item>
    
      <item>
        <title>MacOS工程替换MainMenu.xib</title>
        <description>&lt;p&gt;创建了一个新工程，勾选了storyboard。但是工程创建好后就后悔了，不想要storyboard，直接删除了，然后新建了一个MainMenu.xib，在这个xib下添加一个拖一个NSWindow，然后就想把这个window关联到AppDelegate.m里自己定义的一个window属性&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@proporty (weak) IBOutlet NSWindow *window;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后死活没法通过拖线关联上。查了一波资料，总算解决了，方法如下：&lt;/p&gt;

&lt;p&gt;Xcode默认创建的MainMenu.xib在Interface Builder中的Objects一栏中是有App Delegate这一项，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72pnwa085j309l06f3yu.jpg&quot; alt=&quot;屏幕快照 2017-03-06 下午7.31.01.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同时AppDelegate中也已经默认连接好了MainMenu.xib中的NSWindow：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@interface AppDelegate ()

@property (weak) IBOutlet NSWindow *window;

@end
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然而如果自己创建MainMenu.xib的话，这些都是没有的。在Interface Builder中的Objects一栏是这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72ptcyattj305e05o0st.jpg&quot; alt=&quot;屏幕快照 2017-03-06 下午7.31.23.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以我们要增加一个AppDelegate对象上去，并做好和window属性的关联。接下来是具体操作步骤：&lt;/p&gt;

&lt;p&gt;1、在Objects Library中找到Object：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2014369-52c63dcc7a92b3b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2017-03-06 下午7.31.33.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、手动将此Object拖到Interface Builder左侧的Objects一栏内。&lt;/p&gt;

&lt;p&gt;3、在右上的Identity Inspector中设置Class为AppDelegate,这样Object名字就变成了AppDelegate，也就是我们需要的AppDelegate对象：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72pov52cbj307g03oaa3.jpg&quot; alt=&quot;屏幕快照 2017-03-06 下午7.31.51.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4、拖线，把AppDelegate设置成File’s Owner的delegate&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72pp7znk2j30ar0ac3z9.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5、由于之前创建的是勾选StoryBoard的工程，所以target的General的Deployment Info中Main Interface记录的是StoryBoard.xib，此时需要将其改成MainMenu.xib。否则的话Run会崩溃。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72pphf4ccj30e802wq2x.jpg&quot; alt=&quot;屏幕快照 2017-03-06 下午7.32.08.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(当然也可以设置Info.plist中的Main nib file base name属性)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72ppwdwghj30m808djsi.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 18 Sep 2019 02:00:02 +0800</pubDate>
        <link>http://localhost:4000/2019/09/18/MacOS%E5%B7%A5%E7%A8%8B%E6%9B%BF%E6%8D%A2MainMenu.xib/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/18/MacOS%E5%B7%A5%E7%A8%8B%E6%9B%BF%E6%8D%A2MainMenu.xib/</guid>
        
        <category>Cocoa</category>
        
        <category>macOS</category>
        
        <category>XCode</category>
        
        
      </item>
    
      <item>
        <title>AnyDock</title>
        <description>&lt;h1 id=&quot;下载链接&quot;&gt;下载链接&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/CoderLeonidas/ProducedByLeonidas/&quot;&gt;AnyDock&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 17 Sep 2019 08:00:02 +0800</pubDate>
        <link>http://localhost:4000/2019/09/17/AnyDock/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/17/AnyDock/</guid>
        
        <category>个人作品</category>
        
        <category>macOS</category>
        
        <category>工具</category>
        
        
      </item>
    
      <item>
        <title>Masonry翻译</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Masonry以更漂亮的语法封装了AutoLayout，是一个轻量级的布局框架。
Masonry有自己的布局DSL(domain-specific language)，提供了一种链式写法来描述NSLayoutConstraints，这使得布局代码变得更加简洁和可读。
Masonry 支持 iOS 和 macOS。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;nslayoutconstraints怎么了&quot;&gt;NSLayoutConstraints怎么了？&lt;/h1&gt;
&lt;p&gt;在底层AutoLayout是一种很强大灵活的用于管理和布局视图的方式。但用代码创建约束(Constraints)显得非常冗长且不易描述。设想这样的简单场景：在父视图中填放一个子视图，且每一边留下10像素的边距。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;UIView *superview = self.view;

UIView *view1 = [[UIView alloc] init];
view1.translatesAutoresizingMaskIntoConstraints = NO;
view1.backgroundColor = [UIColor greenColor];
[superview addSubview:view1];

UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);
[superview addConstraints:@[
//view1 constraints
[NSLayoutConstraint constraintWithItem:view1
attribute:NSLayoutAttributeTop
relatedBy:NSLayoutRelationEqual
toItem:superview
attribute:NSLayoutAttributeTop
multiplier:1.0
constant:padding.top],

[NSLayoutConstraint constraintWithItem:view1
attribute:NSLayoutAttributeLeft
relatedBy:NSLayoutRelationEqual
toItem:superview
attribute:NSLayoutAttributeLeft
multiplier:1.0
constant:padding.left],

[NSLayoutConstraint constraintWithItem:view1
attribute:NSLayoutAttributeBottom
relatedBy:NSLayoutRelationEqual
toItem:superview
attribute:NSLayoutAttributeBottom
multiplier:1.0
constant:-padding.bottom],

[NSLayoutConstraint constraintWithItem:view1
attribute:NSLayoutAttributeRight
relatedBy:NSLayoutRelationEqual
toItem:superview
attribute:NSLayoutAttributeRight
multiplier:1
constant:-padding.right],

]];
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;即使这样简单的一个例子，代码就变得这么冗长，如果再多两三个视图，就立刻变得可读性很差。
另外一个选择是使用VFL，稍微不那么长和绕。但是ASKII类型的语法有它自己的隐患，并且动画很麻烦因为&lt;em&gt;NSLayoutConstraint constraintsWithVisualFormat:&lt;/em&gt;返回的是一个数组。&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;准备好见你的maker&quot;&gt;准备好见你的Maker！&lt;/h1&gt;

&lt;p&gt;以下是用&lt;strong&gt;MASConstraintMaker&lt;/strong&gt;创建的简单约束：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);

[view1 mas_makeConstraints:^(MASConstraintMaker *make) {
make.top.equalTo(superview.mas_top).with.offset(padding.top);
//with is an optional semantic filler
make.left.equalTo(superview.mas_left).with.offset(padding.left);
make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);
make.right.equalTo(superview.mas_right).with.offset(-padding.right);
}];
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还可以更短：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;[view1 mas_makeConstraints:^(MASConstraintMaker *make) {
make.edges.equalTo(superview).with.insets(padding);
}];
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不过需要注意在第一个例子中我们需要把约束添加到superview中，尽管Masonry会自动添加约束到合适的view中。
Masonry也会自动调用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;view1.translatesAutoresizidngMaskIntoConstraints = NO;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;不是所有的事情都是平等的&quot;&gt;不是所有的事情都是平等的&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;.equalTo 等价于 NSLayoutRelationEqual
.lessThanOrEqualTo 等价于 NSLayoutRelationLessThanOrEqual
.greaterThanOrEqualTo 等价于 NSLayoutRelationGreaterThanOrEqual
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这3个等价关系接受一个参数，可以是下面的任何一种：&lt;/p&gt;
&lt;h2 id=&quot;1masviewattribute&quot;&gt;1、MASViewAttribute&lt;/h2&gt;

&lt;p&gt;make.centerX.lessThanOrEqualTo(view2.mas_left);
以下是MASViewAttribute和NSLayoutAttribute 的对应关系：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;MASViewAttribute&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;NSLayoutAttribute&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_left&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeLeft&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_right&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeRight&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_top&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeTop&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_bottom&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeBottom&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_leading&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeLeading&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_trailing&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeTrailing&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_width&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeWidth&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_height&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeHeight&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_centerX&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeCenterX&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_centerY&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeCenterY&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;view.mas_baseline&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NSLayoutAttributeBaseline&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;2-uiviewnsview&quot;&gt;2. UIView/NSView&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;if you want view.left to be greater than or equal to label.left :
//这2中约束是等价的
make.left.greaterThanOrEqualTo(label);
make.left.greaterThanOrEqualTo(label.mas_left);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-nsnumber&quot;&gt;3. NSNumber&lt;/h2&gt;
&lt;p&gt;Auto Layout允许宽和高设置为常量。如果想设置view的最小和最大宽度，可以传一个number值:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;//width &amp;gt;= 200 &amp;amp;&amp;amp; width &amp;lt;= 400
make.width.greaterThanOrEqualTo(@200);
make.width.lessThanOrEqualTo(@400);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然而Auto Layout 不允许left, right, centerY等的对齐属性设置成常量值。所以，给这些属性传NSNumber，Masonry会转换到view的superview中去，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;//creates view.left = view.superview.left + 10
make.left.lessThanOrEqualTo(@10)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;除了NSNumber，也可以用原始值或结构体来建立约束，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;make.top.mas_equalTo(42);
make.height.mas_equalTo(20);
make.size.mas_equalTo(CGSizeMake(50, 100));
make.edges.mas_equalTo(UIEdgeInsetsMake(10, 0, 10, 0));
make.left.mas_equalTo(view).mas_offset(UIEdgeInsetsMake(10, 0, 10, 0));
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一般支持&lt;em&gt;自动装箱(autoboxing)&lt;/em&gt;的宏会有mas_前缀。没前缀的版本在导入Masronry前，通过定义&lt;strong&gt;MAS_SHORTHAND_GLOBALS&lt;/strong&gt;，也是可以用的。&lt;/p&gt;

&lt;h2 id=&quot;4-nsarray&quot;&gt;4. NSArray&lt;/h2&gt;
&lt;p&gt;包含前面任何类型元素的数组也是可以的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;make.height.equalTo(@[view1.mas_height, view2.mas_height]);
make.height.equalTo(@[view1, view2]);
make.left.equalTo(@[view1, @100, view3.right]);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;考虑优先级prioritize&quot;&gt;考虑优先级（prioritize）&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;.priority 允许你指定一个确定的优先级
.priorityHigh 等价于 UILayoutPriorityDefaultHigh
.priorityMedium 介于高优先级和低优先级之间
.priorityLow 等价于UILayoutPriorityDefaultLow
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;优先级可以添加在约束链后面，像这样:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;make.left.greaterThanOrEqualTo(label.mas_left).with.priorityLow();
make.top.equalTo(label.mas_top).with.priority(600);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;结构结构结构&quot;&gt;结构，结构，结构&lt;/h1&gt;
&lt;p&gt;Masonry也提供了一些简便方法来同时创建多种约束。这些被称为&lt;strong&gt;MASCompositeConstraints&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;edges&quot;&gt;edges&lt;/h3&gt;
&lt;p&gt;// make top, left, bottom, right equal view2&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make.edges.equalTo(view2);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;// make top = superview.top + 5, left = superview.left + 10,
// bottom = superview.bottom - 15, right = superview.right - 20&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make.edges.equalTo(superview).insets(UIEdgeInsetsMake(5, 10, 15, 20))&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;size&quot;&gt;size&lt;/h3&gt;
&lt;p&gt;// make width and height greater than or equal to titleLabel&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make.size.greaterThanOrEqualTo(titleLabel)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;// make width = superview.width + 100, height = superview.height - 50&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make.size.equalTo(superview).sizeOffset(CGSizeMake(100, -50))&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;center&quot;&gt;center&lt;/h3&gt;
&lt;p&gt;// make centerX and centerY = button1&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make.center.equalTo(button1)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;// make centerX = superview.centerX - 5, centerY = superview.centerY + 10&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make.center.equalTo(superview).centerOffset(CGPointMake(-5, 10))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为了可读性高也可以把属性连起来像这样:&lt;/p&gt;

&lt;p&gt;// All edges but the top should equal those of the superview&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;make.left.right.and.bottom.equalTo(superview);
make.top.equalTo(otherView);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;让美好持续发生&quot;&gt;让美好持续发生&lt;/h1&gt;

&lt;p&gt;有时你需要修改已存在的约束来支持动画或者移除、替换约束。在Masonry中有一些不同的方式来更新约束。&lt;/p&gt;

&lt;h2 id=&quot;1引用&quot;&gt;1、引用&lt;/h2&gt;
&lt;p&gt;可以通过创建变量或者属性来引用一个特定的约束。也可以通过数组保存的方式来引用多个约束。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// in public/private interface

@property (nonatomic, strong) MASConstraint *topConstraint;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;// when making constraints&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;[view1 mas_makeConstraints:^(MASConstraintMaker *make) {
self.topConstraint = make.top.equalTo(superview.mas_top).with.offset(padding.top);
make.left.equalTo(superview.mas_left).with.offset(padding.left);
}];

...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;// 然后你可以调用&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[self.topConstraint uninstall];&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-mas_updateconstraints&quot;&gt;2. mas_updateConstraints&lt;/h2&gt;
&lt;p&gt;如果只是更新约束中的常量值，你可以用这个&lt;strong&gt;mas_updateConstraints&lt;/strong&gt;方法来代替&lt;strong&gt;mas_makeConstraints&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// 这是苹果推荐的用来添加或更新约束的地方
// 这个方法会在响应setNeedsUpdateConstraints时被多次调用
// 会被UIKit内部或者在你的代码中当你需要触发约束的更新时调用
- (void)updateConstraints {
[self.growingButton mas_updateConstraints:^(MASConstraintMaker *make) {
make.center.equalTo(self);
make.width.equalTo(@(self.buttonSize.width)).priorityLow();
make.height.equalTo(@(self.buttonSize.height)).priorityLow();
make.width.lessThanOrEqualTo(self);
make.height.lessThanOrEqualTo(self);
}];

//according to apple super should be called at end of method
[super updateConstraints];
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3mas_remakeconstraints&quot;&gt;3、mas_remakeConstraints&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;mas_updateConstraints&lt;/em&gt;在更新一组约束时很有用，但是做一些更新约束值之外的事就显得力不从心了。这就是为何要引入&lt;strong&gt;mas_remakeConstraints&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mas_remakeConstraints&lt;/strong&gt;类似mas_updateConstraints，但是不同于更新常量值，它会在重新安装约束前移除所有的约束。这就让你能提供不同的约束，而不用时刻记住你要移除哪个约束了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;- (void)changeButtonPosition {
[self.button mas_remakeConstraints:^(MASConstraintMaker *make) {
make.size.equalTo(self.buttonSize);

if (topLeft) {
make.top.and.left.offset(10);
} else {
make.bottom.and.right.offset(-10);
}
}];
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;出现麻烦咋整&quot;&gt;出现麻烦咋整！&lt;/h1&gt;
&lt;p&gt;布局并不能像你意料的那样，所以当事情真的搞砸了的时候，你肯定不希望在控制台看到这样的输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Unable to simultaneously satisfy constraints.....blah blah blah....
(
&quot;&amp;lt;NSLayoutConstraint:0x7189ac0 V:[UILabel:0x7186980(&amp;gt;=5000)]&amp;gt;&quot;,
&quot;&amp;lt;NSAutoresizingMaskLayoutConstraint:0x839ea20 h=--&amp;amp; v=--&amp;amp; V:[MASExampleDebuggingView:0x7186560(416)]&amp;gt;&quot;,
&quot;&amp;lt;NSLayoutConstraint:0x7189c70 UILabel:0x7186980.bottom == MASExampleDebuggingView:0x7186560.bottom - 10&amp;gt;&quot;,
&quot;&amp;lt;NSLayoutConstraint:0x7189560 V:|-(1)-[UILabel:0x7186980]   (Names: '|':MASExampleDebuggingView:0x7186560 )&amp;gt;&quot;
)

Will attempt to recover by breaking constraint
&amp;lt;NSLayoutConstraint:0x7189ac0 V:[UILabel:0x7186980(&amp;gt;=5000)]&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Masonry在NSLayoutConstraint增加了一个分类，覆盖了&lt;em&gt;- (NSString *)description&lt;/em&gt;的默认实现。这样在给约束和view起名字后，能够很轻松的从中找出哪些是Masonry创建的约束。&lt;/p&gt;

&lt;p&gt;这意味着你的控制台输出看起来是这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Unable to simultaneously satisfy constraints......blah blah blah....
(
&quot;&amp;lt;NSAutoresizingMaskLayoutConstraint:0x8887740 MASExampleDebuggingView:superview.height == 416&amp;gt;&quot;,
&quot;&amp;lt;MASLayoutConstraint:ConstantConstraint UILabel:messageLabel.height &amp;gt;= 5000&amp;gt;&quot;,
&quot;&amp;lt;MASLayoutConstraint:BottomConstraint UILabel:messageLabel.bottom == MASExampleDebuggingView:superview.bottom - 10&amp;gt;&quot;,
&quot;&amp;lt;MASLayoutConstraint:ConflictingConstraint[0] UILabel:messageLabel.top == MASExampleDebuggingView:superview.top + 1&amp;gt;&quot;
)

Will attempt to recover by breaking constraint
&amp;lt;MASLayoutConstraint:ConstantConstraint UILabel:messageLabel.height &amp;gt;= 5000&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;应该在哪创建约束&quot;&gt;应该在哪创建约束？&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@implementation DIYCustomView

- (id)init {
self = [super init];
if (!self) return nil;

// --- Create your views here ---
self.button = [[UIButton alloc] init];

return self;
}

// 告诉UIKit你在使用AutoLayout
+ (BOOL)requiresConstraintBasedLayout {
return YES;
}

// 这是苹果推荐用来添加或更新约束的地方
- (void)updateConstraints {

// 在这里更新或者添加约束
[self.button remakeConstraints:^(MASConstraintMaker *make) {
make.width.equalTo(@(self.buttonSize.width));
make.height.equalTo(@(self.buttonSize.height));
}];

//根据苹果介绍super方法应该在方法的最后调用一下
[super updateConstraints];
}

- (void)didTapButton:(UIButton *)button {
// --- Do your changes ie change variables that affect your layout etc ---
self.buttonSize = CGSize(200, 200);

// 通知约束他们应该被更新了
[self setNeedsUpdateConstraints];
}

@end
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;安装&quot;&gt;安装：&lt;/h1&gt;
&lt;p&gt;使用CocoaPods.
在Podfile文件中写：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pod ‘Masonry'&lt;/code&gt;&lt;br /&gt;
即可。&lt;/p&gt;

&lt;p&gt;如果你在用Masonry时不想见到讨厌的mas_前缀，就添加&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#define MAS_SHORTHAND&lt;/code&gt;
到prefix.pch，并导入到Masonry中。&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;便捷代码块&quot;&gt;便捷代码块&lt;/h1&gt;
&lt;p&gt;将以下代码块拷贝到&lt;code class=&quot;highlighter-rouge&quot;&gt;~/Library/Developer/Xcode/UserData/CodeSnippets&lt;/code&gt;，写Masonry代码爽到飞起：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;mas_make -&amp;gt; [&amp;lt;view&amp;gt; mas_makeConstraints:^(MASConstraintMaker *make){&amp;lt;code&amp;gt;}];
mas_update -&amp;gt; [&amp;lt;view&amp;gt; mas_updateConstraints:^(MASConstraintMaker *make){&amp;lt;code&amp;gt;}];
mas_remake -&amp;gt; [&amp;lt;view&amp;gt; mas_remakeConstraints:^(MASConstraintMaker *make){&amp;lt;code&amp;gt;}];
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;特性&quot;&gt;特性：&lt;/h1&gt;

&lt;p&gt;1、不只是Auto Layout的子集，任何NSLayoutConstraint能做的，Masonry都能做
2、很棒的debug支持，只要你给约束和view取好有意义的名字
3、约束读起来像自然语句，通俗易懂
4、没有令人抓狂的宏魔法。Masonry有了宏不会污染全局的名字空间。
5、不基于字符串和字典，所以编译的时候就能检查出问题。&lt;/p&gt;

&lt;h1 id=&quot;原文链接&quot;&gt;原文链接&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/SnapKit/Masonry&quot;&gt;Masonry&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 16 Sep 2019 20:00:02 +0800</pubDate>
        <link>http://localhost:4000/2019/09/16/Masonry%E7%BF%BB%E8%AF%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/16/Masonry%E7%BF%BB%E8%AF%91/</guid>
        
        <category>三方库</category>
        
        <category>翻译</category>
        
        
      </item>
    
      <item>
        <title>KSCrash翻译</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;KSCrash：一个终极的iOS crash reporter&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;为何使用kscrash&quot;&gt;为何使用KSCrash？&lt;/h1&gt;

&lt;p&gt;因为在现有的一些crash reporter报告崩溃时，KSCrash还能比它们还能做得更多。以下是KSCrash的一些关键属性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;1. 支持离线重新符号化的设备上符号化(在iOS版本中，许多功能已经被修改)。
2. 生成完全的苹果报告，每个字段都不落下
3. 支持32或64位 
4. 能处理只能在mach级别捕获的错误，比如堆栈溢出。
5. 跟踪由于未捕获的c++异常导致的REAL。
6. 在crash自己的回调里处理crash(或者在用户的crash回调里)
7. 检测僵尸(释放)对象访问尝试
8. 在僵尸或内存损坏的情况下恢复丢失的NSException消息
9. 在寄存器和堆栈上自省对象(C字符串和Objective-C对象，包括ivars)。
10. 提取关于异常引用的对象的信息(例如&quot;unrecognized selector sent to instance 0xa26d9a0&quot;)
11. 它的可插入服务报告体系结构使其易于适应任何API服务。
12. 转储堆栈内容。
13. 诊断crash原因(Crash医生)
14. 以JSON格式记录苹果崩溃报告所不能记录的大量信息。
15. 支持包括程序员提供的额外数据(崩溃前和崩溃期间)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;kscrash支持处理以下类型的crash&quot;&gt;KSCrash支持处理以下类型的crash:&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;mach 内核异常
致命信号(Fatal signals)
C++ 异常
OC异常
主线程死锁
自定义crash(比如来自脚本语言的自定义crash)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;kscrash可以向以下服务器报导&quot;&gt;KSCrash可以向以下服务器报导：&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Hockey
QuincyKit
Victory
Email
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;新特性&quot;&gt;新特性：&lt;/h1&gt;

&lt;p&gt;C++异常处理：
是的，通常你的app由于未捕获的C++异常而终止，你会看到这样的堆栈：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   libsystem_kernel.dylib          0x9750ea6a 0x974fa000 + 84586 (__pthread_kill + 10)
1   libsystem_sim_c.dylib           0x04d56578 0x4d0f000 + 292216 (abort + 137)
2   libc++abi.dylib                 0x04ed6f78 0x4ed4000 + 12152 (abort_message + 102)
3   libc++abi.dylib                 0x04ed4a20 0x4ed4000 + 2592 (_ZL17default_terminatev + 29)
4   libobjc.A.dylib                 0x013110d0 0x130b000 + 24784 (_ZL15_objc_terminatev + 109)
5   libc++abi.dylib                 0x04ed4a60 0x4ed4000 + 2656 (_ZL19safe_handler_callerPFvvE + 8)
6   libc++abi.dylib                 0x04ed4ac8 0x4ed4000 + 2760 (_ZSt9terminatev + 18)
7   libc++abi.dylib                 0x04ed5c48 0x4ed4000 + 7240 (__cxa_rethrow + 77)
8   libobjc.A.dylib                 0x01310fb8 0x130b000 + 24504 (objc_exception_rethrow + 42)
9   CoreFoundation                  0x01f2af98 0x1ef9000 + 204696 (CFRunLoopRunSpecific + 360)
...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;根本没法跟踪这个异常是啥和在哪抛出的！
现在有了KSCrash，你可以从下面信息获得未捕获的异常类型、描述、和它抛出的地方：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Application Specific Information:
*** Terminating app due to uncaught exception 'MyException', reason: 'Something bad happened...'

Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   Crash-Tester                    0x0000ad80 0x1000 + 40320 (-[Crasher throwUncaughtCPPException] + 0)
1   Crash-Tester                    0x0000842e 0x1000 + 29742 (__32-[AppDelegate(UI) crashCommands]_block_invoke343 + 78)
2   Crash-Tester                    0x00009523 0x1000 + 34083 (-[CommandEntry executeWithViewController:] + 67)
3   Crash-Tester                    0x00009c0a 0x1000 + 35850 (-[CommandTVC tableView:didSelectRowAtIndexPath:] + 154)
4   UIKit                           0x0016f285 0xb4000 + 766597 (-[UITableView _selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:] + 1194)
5   UIKit                           0x0016f4ed 0xb4000 + 767213 (-[UITableView _userSelectRowAtPendingSelectionIndexPath:] + 201)
6   Foundation                      0x00b795b3 0xb6e000 + 46515 (__NSFireDelayedPerform + 380)
7   CoreFoundation                  0x01f45376 0x1efa000 + 308086 (__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ + 22)
8   CoreFoundation                  0x01f44e06 0x1efa000 + 306694 (__CFRunLoopDoTimer + 534)
9   CoreFoundation                  0x01f2ca82 0x1efa000 + 207490 (__CFRunLoopRun + 1810)
10  CoreFoundation                  0x01f2bf44 0x1efa000 + 204612 (CFRunLoopRunSpecific + 276)
...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;方便的c开发助手&quot;&gt;方便的C++开发助手&lt;/h1&gt;
&lt;p&gt;如果你打开跟踪打印：
`
[KSCrash sharedInstance].printTraceToStdout = YES;
`
它会在你的app抛出未捕获C++异常的时候打印一个合适的堆栈跟踪信息到标准输出(stdout)上！否则调试器只会将你引向重新抛出异常的位置。&lt;/p&gt;

&lt;h1 id=&quot;自定义crash和堆栈跟踪&quot;&gt;自定义Crash和堆栈跟踪&lt;/h1&gt;
&lt;p&gt;你现在可以报导你自己自定义的crash和堆栈跟踪信息(想一下脚本语言)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;- (void) reportUserException:(NSString*) name
reason:(NSString*) reason
lineOfCode:(NSString*) lineOfCode
stackTrace:(NSArray*) stackTrace
terminateProgram:(BOOL) terminateProgram;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;详情见KSCrash.h文件。&lt;/p&gt;

&lt;h1 id=&quot;不稳定的特性&quot;&gt;不稳定的特性&lt;/h1&gt;
&lt;p&gt;下列特性被认为是”不稳定”的，并且默认禁用：
死锁检测&lt;/p&gt;

&lt;h1 id=&quot;不兼容api更改通知&quot;&gt;不兼容API更改通知&lt;/h1&gt;
&lt;p&gt;从2013年1月29日起，我修改了KSCrash主API，使用属性而不是初始化方法参数进行配置。有了所有的新选择后，事情开始变得有点棘手。这应该是最后一个主要的API更改。&lt;/p&gt;

&lt;p&gt;注意:初始化KSCrash的首选方法现在是通过安装对象，而不是直接使用过滤器。详见“如何使用KSCrash”。&lt;/p&gt;

&lt;h1 id=&quot;如何build-kscrash&quot;&gt;如何build KSCrash&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;1 选中KSCrash的scheme
2 选择iOS设备
3 Products菜单里选择Archive
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当build完成，会在Finder看到framework，你可以像使用任何其他framework一样使用它。&lt;/p&gt;

&lt;h1 id=&quot;如何使用kscrash&quot;&gt;如何使用KSCrash&lt;/h1&gt;
&lt;p&gt;1 添加这个framework到你的工程(或者添加KSCrash工程进来，作为依赖项)
2 添加下列系统framework和lib到你的工程&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;libc++.dylib
libz.dylib
MessageUI.framework (iOS only)
SystemConfiguration.framework
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3 在Build Setting是的Other Linker Flags里添加”-Objc”标识
4 添加下列内容到你app delegate的 &lt;code class=&quot;highlighter-rouge&quot;&gt;[application: didFinishLaunchingWithOptions:] &lt;/code&gt;方法里：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;#import &amp;lt;KSCrash/KSCrash.h&amp;gt;
// Include to use the standard reporter.
#import &amp;lt;KSCrash/KSCrashInstallationStandard.h&amp;gt;
// Include to use Quincy or Hockey.
#import &amp;lt;KSCrash/KSCrashInstallationQuincyHockey.h&amp;gt;
// Include to use the email reporter.
#import &amp;lt;KSCrash/KSCrashInstallationEmail.h&amp;gt;
// Include to use Victory.
#import &amp;lt;KSCrash/KSCrashInstallationVictory.h&amp;gt;

- (BOOL)application:(UIApplication*) application didFinishLaunchingWithOptions:(NSDictionary*) launchOptions
{
KSCrashInstallationStandard* installation = [KSCrashInstallationStandard sharedInstance];
installation.url = [NSURL URLWithString:@&quot;http://put.your.url.here&quot;];

// OR:

KSCrashInstallationQuincy* installation = [KSCrashInstallationQuincy sharedInstance];
installation.url = [NSURL URLWithString:@&quot;http://put.your.url.here&quot;];

// OR:

KSCrashInstallationHockey* installation = [KSCrashInstallationHockey sharedInstance];
installation.appIdentifier = @&quot;PUT_YOUR_HOCKEY_APP_ID_HERE&quot;;

// OR:

KSCrashInstallationEmail* installation = [KSCrashInstallationEmail sharedInstance];
installation.recipients = @[@&quot;some@email.address&quot;];

// Optional (Email): Send Apple-style reports instead of JSON
[installation setReportStyle:KSCrashEmailReportStyleApple useDefaultFilenameFormat:YES]; 

// Optional: Add an alert confirmation (recommended for email installation)
[installation addConditionalAlertWithTitle:@&quot;Crash Detected&quot;
message:@&quot;The app crashed last time it was launched. Send a crash report?&quot;
yesAnswer:@&quot;Sure!&quot;
noAnswer:@&quot;No thanks&quot;];

// OR:

KSCrashInstallationVictory* installation = [KSCrashInstallationVictory sharedInstance];
installation.url = [NSURL URLWithString:@&quot;https://put.your.url.here/api/v1/crash/&amp;lt;application key&amp;gt;&quot;];

[installation install];
…
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这将安装崩溃哨兵系统(可以拦截crashes并将报告存存盘)。不过注意，你还可以为各种安装设置其他你想要的其他属性。
一旦你准备发送任何的crash报告，调用如下方法：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;[installation sendAllReportsWithCompletion:^(NSArray *filteredReports, BOOL completed, NSError *error)
{
// Stuff to do when report sending is complete
}];
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h1&gt;
&lt;p&gt;如果可以的话，你应该阅读下列头文件来完全理解KSCrash所拥有的特性和如何使用它：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;KSCrash.h
KSCrashInstallation.h
KSCrashInstallation(SPECIFIC TYPE).h
Architecture.md
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;高端用法&quot;&gt;高端用法&lt;/h1&gt;

&lt;h2 id=&quot;允许设备内置符号化&quot;&gt;允许设备内置符号化&lt;/h2&gt;
&lt;h2 id=&quot;允许高级功能&quot;&gt;允许高级功能&lt;/h2&gt;
&lt;p&gt;KSCrash具有一些在一片茫然中检查崩溃报告时非常有用的高级功能。其中一些涉及到较小的权衡，因此大多数默认情况下是禁用的。&lt;/p&gt;
&lt;h3 id=&quot;自定义用户数据kscrashh中的userinfo&quot;&gt;自定义用户数据(KSCrash.h中的userInfo)&lt;/h3&gt;
&lt;p&gt;设置userInfo属性后，你可以将自定义用户数据存储到下一次的crash report上&lt;/p&gt;
&lt;h3 id=&quot;僵尸对象跟踪kscrashh中的zombiecachesize&quot;&gt;僵尸对象跟踪(KSCrash.h中的zombieCacheSize)&lt;/h3&gt;
&lt;p&gt;KSCrash具有检测僵尸对象(指向已释放对象的悬停指针)的能力。它通过记录已释放对象的类型和地址来做到这一点。它将这些值存储在缓存中，并切断已释放对象的地址。这意味着，设置缓存的大小越小，哈希冲突发生的几率越大。并且你将因此失去先前已释放对象的信息。&lt;/p&gt;

&lt;p&gt;启用僵尸跟踪后，KSCrash还将检测丢失的NSException并打印其内容。某些类型的内存损坏或堆栈损坏崩溃可能会导致异常提前释放，从而进一步影响调试应用程序的工作，因此该特性有时非常方便。&lt;/p&gt;

&lt;p&gt;权衡：僵尸跟踪的代价是向对象释放位置添加非常小的开销，并保留一些内存。&lt;/p&gt;

&lt;h3 id=&quot;死锁检测kscrashh中的deadlockwatchdoginterval&quot;&gt;死锁检测(KSCrash.h中的deadlockWatchdogInterval)&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;严正警告！！本功能是不稳定的！它会呈现假阳性并使你的app崩溃！&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;内存自省kscrashh中的introspectmemory&quot;&gt;内存自省(KSCrash.h中的introspectMemory)&lt;/h3&gt;
&lt;p&gt;当应用程序崩溃时，内存中通常残留有被栈、寄存器甚至异常消息引用的对象和字符串。当启用此功能时，KSCrash将内省这些内存区域并将它们的内容存储到crash report中。&lt;/p&gt;

&lt;p&gt;你也可以通过设置doNotIntrospectClasses属性，指定一个类的列表，来避免这些类的自省。&lt;/p&gt;
&lt;h3 id=&quot;自定义crash处理代码kscrashh中的oncrash&quot;&gt;自定义crash处理代码(KSCrash.h中的onCrash)&lt;/h3&gt;

&lt;p&gt;如果你想在crash发生时做一些额外操作(比如添加更多的上下文数据信息到报告中去)，你可以这么做。&lt;/p&gt;

&lt;p&gt;然而，你必须确保你只使用异步安全的代码。并且最重要的是，不要那个方法里调用OC代码！在很多情况下，你都可以这样做，但是在某些特定的崩溃类中，无视此警告的处理程序代码将导致崩溃处理程序崩溃! 注意，如果发生这种情况，KSCrash将检测它并编写完整的报告，尽管您的自定义处理程序代码可能没有完全运行！&lt;/p&gt;

&lt;p&gt;权衡： 你必须小心你所放入的自定义崩溃处理代码！&lt;/p&gt;

&lt;h3 id=&quot;kscrash-日志重定向&quot;&gt;KSCrash 日志重定向&lt;/h3&gt;

&lt;p&gt;这会将KSCrash将要打印到控制台的内容，写到一个文件里。我通常用这个功能来调试KSCrash自身，但它也可以拍派很多其他用场，所以我公开为它公开了一个API！&lt;/p&gt;

&lt;h1 id=&quot;例子&quot;&gt;例子&lt;/h1&gt;
&lt;p&gt;workspace中包含了几个例子app，用来演示常见的KSCrash用法。请看下每个AppDelegate.m文件的顶部信息来了解它做了什么。&lt;/p&gt;

&lt;p&gt;原链接: https://github.com/kstenerud/KSCrash&lt;/p&gt;

</description>
        <pubDate>Mon, 16 Sep 2019 20:00:01 +0800</pubDate>
        <link>http://localhost:4000/2019/09/16/KSCrash%E7%BF%BB%E8%AF%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/16/KSCrash%E7%BF%BB%E8%AF%91/</guid>
        
        <category>三方库</category>
        
        <category>翻译</category>
        
        
      </item>
    
      <item>
        <title>IBInspectable与枚举</title>
        <description>&lt;p&gt;在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;IBInspectable&lt;/code&gt;定义可视化属性时，对于枚举类型，是没法在xib上可视化的。代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
#import &amp;lt;Cocoa/Cocoa.h&amp;gt;

NS_ASSUME_NONNULL_BEGIN
typedef enum : NSUInteger {
EMBorderViewTypeNone,
EMBorderViewTypeDash,  ///&amp;lt; 虚线边界线
EMBorderViewTypeSolid,  ///&amp;lt; 实线边界线
} EMBorderLineType;

typedef NS_OPTIONS(NSUInteger, EMBorderMode) {
EMBorderModeNone   = 1 &amp;lt;&amp;lt; 0,  ///&amp;lt; 没有边界线
EMBorderModeLeft   = 1 &amp;lt;&amp;lt; 1,  ///&amp;lt; 有左边界线
EMBorderModeRight  = 1 &amp;lt;&amp;lt; 2,  ///&amp;lt; 有右边界线
EMBorderModeTop    = 1 &amp;lt;&amp;lt; 3,  ///&amp;lt; 有上边界线
EMBorderModeBottom = 1 &amp;lt;&amp;lt; 4,  ///&amp;lt; 有下边界线
EMBorderModeAll    = 1 &amp;lt;&amp;lt; 5,  ///&amp;lt; 有全部边界线
};

IB_DESIGNABLE

@interface EMBorderView : NSView
@property (nonatomic,strong) IBInspectable NSColor *lineColor;
@property (nonatomic, assign) IBInspectable EMBorderLineType borderLineType;  ///&amp;lt; 边界线类型，对应EMBorderLineType枚举值
@property (nonatomic, assign) IBInspectable EMBorderMode borderMode; ///&amp;lt; 边界线模式，对应EMBorderMode枚举值
@property (nonatomic, assign) IBInspectable CGFloat lineWidth; ///&amp;lt; 线宽

- (instancetype)initWithLineType:(EMBorderLineType)lineType mode:(EMBorderMode)mode;

@end

NS_ASSUME_NONNULL_END
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码中，只有lineColor、lineWidth是可以可视化的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72pl74alpj30jz0hxdh6.jpg&quot; alt=&quot;clip_6.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而2个枚举属性borderLineType和borderMode无法在属性监视器上显示。
查了下资料，对于&lt;code class=&quot;highlighter-rouge&quot;&gt;IBInspectable&lt;/code&gt;关键字支持的属性类型，发现它仅支持以下几种基础数据类型的属性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Int
CGFloat
Double
String
Bool
CGPoint
CGSize
CGRect
UIColor
NSColor
UIImage
NSImage
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们知道枚举本质也就是NSIngeger或NSUInteger，所以为了让这2个枚举属性可视化，我们可以将属性这样定义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@property (nonatomic, assign) IBInspectable NSUInteger borderLineType;  ///&amp;lt; 边界线类型，对应EMBorderLineType枚举值
@property (nonatomic, assign) IBInspectable NSUInteger borderMode; ///&amp;lt; 边界线模式，对应EMBorderMode枚举值
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;同时注意setter方法中也需要将其类型改为NSUInteger，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;- (void)setBorderMode:(NSUInteger)borderMode {
if (_borderMode == borderMode) {
return;
}
_borderMode = borderMode;
[self refresh];
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样我们就能在属性监视器上看到我们定义的属性：
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g72plrl4yuj30k509fq3o.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然，这个方法的缺点就是，在属性监视器中设置枚举类型属性时，要自己对所需的枚举值做运算。这或许不是最好的方法，如果大家有什么更好的方法来优雅的使用&lt;code class=&quot;highlighter-rouge&quot;&gt;IBInspectable&lt;/code&gt;定义可视化属性，欢迎大家讨论不吝赐教~&lt;/p&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/28749598/ibinspectable-with-enum&quot;&gt;@IBInspectable with enum?&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 16 Sep 2019 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/09/16/IBInspectable-%E4%B8%8E%E6%9E%9A%E4%B8%BE/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/16/IBInspectable-%E4%B8%8E%E6%9E%9A%E4%B8%BE/</guid>
        
        <category>Cocoa</category>
        
        <category>XCode</category>
        
        
      </item>
    
  </channel>
</rss>
